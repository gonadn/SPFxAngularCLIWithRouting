import { DirectionalHint } from '../common/DirectionalHint';
import { Rectangle as FullRectangle, IRectangle } from '../Utilities';
export declare enum RectangleEdge {
    top = 1,
    bottom = -1,
    left = 2,
    right = -2,
}
export declare enum Position {
    top = 0,
    bottom = 1,
    start = 2,
    end = 3,
}
export declare class Rectangle extends FullRectangle {
    [key: string]: number | boolean | any;
}
export interface IPositionProps {
    target?: HTMLElement | MouseEvent | IPoint;
    /** how the element should be positioned */
    directionalHint?: DirectionalHint;
    /**
     * How the element should be positioned in RTL layouts.
     * If not specified, a mirror of `directionalHint` will be used instead
     */
    directionalHintForRTL?: DirectionalHint;
    /** The gap between the callout and the target */
    gapSpace?: number;
    /** The width of the beak. */
    beakWidth?: number;
    /**
     * The bounding rectangle for which  the contextual menu can appear in.
     */
    bounds?: IRectangle;
    /** If true then the beak is visible. If false it will not be shown. */
    isBeakVisible?: boolean;
    /**
     * If true the position returned will have the menu element cover the target.
     * If false then it will position next to the target;
     */
    coverTarget?: boolean;
    /**
     * If true the position will not change edges in an attempt to fit the rectangle within bounds.
     * It will still attempt to align it to whatever bounds are given.
     * @default false
     */
    directionalHintFixed?: boolean;
}
export interface IPositionInfo {
    calloutPosition: ICalloutPositon;
    beakPosition: {
        position: ICalloutPositon;
        display: string;
    };
    directionalClassName: string;
    submenuDirection: DirectionalHint;
}
export interface ICalloutPositon {
    top?: number;
    left?: number;
    bottom?: number;
    right?: number;
    [key: string]: number | undefined;
}
export interface IPoint {
    x: number;
    y: number;
}
export interface IPositionData {
    targetEdge: RectangleEdge;
    alignmentEdge?: RectangleEdge;
    isAuto?: boolean;
}
export declare module positioningFunctions {
    interface ICallout {
        calloutRectangle: Rectangle;
        targetEdge: RectangleEdge;
        alignmentEdge: RectangleEdge | undefined;
    }
    type PartialIRectangle = Partial<IRectangle>;
    interface IPartialIRectangle extends PartialIRectangle {
        [key: string]: number | undefined;
    }
    function _calculateActualBeakWidthInPixels(beakWidth: number): number;
    /**
     * Returns the appropriate IPositionData based on the props altered for RTL.
     * If directionalHintForRTL is passed in that is used if the page is RTL.
     * If a directionalHint is specified and no directionalHintForRTL is available and the page is RTL the hint will be flipped.
     * For instance bottomLeftEdge would become bottomRightEdge.
     * If there is no directionalHint passed in bottomAutoEdge is chosen automatically.
     *
     * @param {IPositionProps} props
     * @returns {IPositionData}
     */
    function _getPositionData(directionalHint?: DirectionalHint, directionalHintForRTL?: DirectionalHint): IPositionData;
    function _positionCalloutWithinBounds(callout: Rectangle, target: Rectangle, bounding: Rectangle, positionData: IPositionData, gap: number, directionalHintFixed?: boolean, coverTarget?: boolean): ICallout;
    function _positionBeak(beakWidth: number, callout: ICallout, target: Rectangle, alignmentEdge?: RectangleEdge): IPartialIRectangle;
    function _getRectangleFromHTMLElement(element: HTMLElement): Rectangle;
    function _getRectangleFromIRect(rect: IRectangle): Rectangle;
    function _getTargetRect(bounds: Rectangle, target: HTMLElement | MouseEvent | IPoint | undefined): Rectangle;
    /**
     * If max height is less than zero it returns the bounds height instead.
     */
    function _getMaxHeightFromTargetRectangle(targetRectangle: Rectangle, targetEdge: DirectionalHint, gapSpace: number, bounds: Rectangle): number;
    function _getRelativePositions(props: IPositionProps, hostElement: HTMLElement, calloutElement: HTMLElement): IPositionInfo;
}
export declare function getRelativePositions(props: IPositionProps, hostElement: HTMLElement, calloutElement: HTMLElement): IPositionInfo;
/**
 * Get's the maximum height that a rectangle can have in order to fit below or above a target.
 * If the directional hint specifies a left or right edge (i.e. leftCenter) it will limit the height to the topBorder
 * of the target given.
 * If no bounds are provided then the window is treated as the bounds.
 */
export declare function getMaxHeight(target: HTMLElement | MouseEvent | IPoint, targetEdge: DirectionalHint, gapSpace?: number, bounds?: IRectangle): number;
