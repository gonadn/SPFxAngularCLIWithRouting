define(["require", "exports", "tslib"], function (require, exports, tslib_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Injection mode for the stylesheet.
     *
     * @public
     */
    var InjectionMode;
    (function (InjectionMode) {
        /**
         * Avoids style injection, use getRules() to read the styles.
         */
        InjectionMode[InjectionMode["none"] = 0] = "none";
        /**
         * Inserts rules using the insertRule api.
         */
        InjectionMode[InjectionMode["insertNode"] = 1] = "insertNode";
        /**
         * Appends rules using appendChild.
         */
        InjectionMode[InjectionMode["appendChild"] = 2] = "appendChild";
    })(InjectionMode = exports.InjectionMode || (exports.InjectionMode = {}));
    var STYLESHEET_SETTING = '__stylesheet__';
    var _stylesheet;
    /**
     * Represents the state of styles registered in the page. Abstracts
     * the surface for adding styles to the stylesheet, exposes helpers
     * for reading the styles registered in server rendered scenarios.
     *
     * @public
     */
    var Stylesheet = /** @class */ (function () {
        function Stylesheet(config) {
            this._config = tslib_1.__assign({ injectionMode: 1 /* insertNode */, defaultPrefix: 'css' }, config);
            this.reset();
        }
        /**
         * Gets the singleton instance.
         */
        Stylesheet.getInstance = function () {
            // tslint:disable-next-line:no-any
            var win = typeof window !== 'undefined' ? window : {};
            _stylesheet = win[STYLESHEET_SETTING];
            if (!_stylesheet) {
                // tslint:disable-next-line:no-string-literal
                var fabricConfig = (win && win['FabricConfig']) || {};
                _stylesheet = win[STYLESHEET_SETTING] = new Stylesheet(fabricConfig.mergeStyles);
            }
            return _stylesheet;
        };
        /**
         * Configures the stylesheet.
         */
        Stylesheet.prototype.setConfig = function (config) {
            this._config = tslib_1.__assign({}, this._config, config);
        };
        /**
         * Generates a unique classname.
         *
         * @param displayName - Optional value to use as a prefix.
         */
        Stylesheet.prototype.getClassName = function (displayName) {
            var prefix = displayName || this._config.defaultPrefix;
            return prefix + "-" + this._counter++;
        };
        /**
         * Used internally to cache information about a class which was
         * registered with the stylesheet.
         */
        Stylesheet.prototype.cacheClassName = function (className, key, args, rules) {
            this._keyToClassName[key] = className;
            this._classNameToArgs[className] = {
                args: args,
                rules: rules
            };
        };
        /**
         * Gets the appropriate classname given a key which was previously
         * registered using cacheClassName.
         */
        Stylesheet.prototype.classNameFromKey = function (key) {
            return this._keyToClassName[key];
        };
        /**
         * Gets the arguments associated with a given classname which was
         * previously registered using cacheClassName.
         */
        Stylesheet.prototype.argsFromClassName = function (className) {
            var entry = this._classNameToArgs[className];
            return (entry && entry.args);
        };
        /**
       * Gets the arguments associated with a given classname which was
       * previously registered using cacheClassName.
       */
        Stylesheet.prototype.insertedRulesFromClassName = function (className) {
            var entry = this._classNameToArgs[className];
            return (entry && entry.rules);
        };
        /**
         * Inserts a css rule into the stylesheet.
         */
        Stylesheet.prototype.insertRule = function (rule) {
            var element = this._getElement();
            var injectionMode = element ? this._config.injectionMode : 0 /* none */;
            switch (injectionMode) {
                case 1 /* insertNode */:
                    var sheet = element.sheet;
                    try {
                        // tslint:disable-next-line:no-any
                        sheet.insertRule(rule, sheet.cssRules.length);
                    }
                    catch (e) {
                        /* no-op on errors */
                    }
                    break;
                case 2 /* appendChild */:
                    _createStyleElement(rule);
                    break;
                default:
                    this._rules.push(rule);
                    break;
            }
            if (this._config.onInsertRule) {
                this._config.onInsertRule(rule);
            }
        };
        /**
         * Gets all rules registered with the stylesheet; only valid when
         * using InsertionMode.none.
         */
        Stylesheet.prototype.getRules = function () {
            return (this._rules.join('') || '') + (this._rulesToInsert.join('') || '');
        };
        /**
         * Resets the internal state of the stylesheet. Only used in server
         * rendered scenarios where we're using InsertionMode.none.
         */
        Stylesheet.prototype.reset = function () {
            this._rules = [];
            this._rulesToInsert = [];
            this._counter = 0;
            this._classNameToArgs = {};
            this._keyToClassName = {};
            if (this._timerId) {
                clearTimeout(this._timerId);
                this._timerId = 0;
            }
        };
        Stylesheet.prototype._getElement = function () {
            if (!this._styleElement && typeof document !== 'undefined') {
                this._styleElement = _createStyleElement();
            }
            return this._styleElement;
        };
        return Stylesheet;
    }());
    exports.Stylesheet = Stylesheet;
    function _createStyleElement(content) {
        var styleElement = document.createElement('style');
        styleElement.setAttribute('data-merge-styles', 'true');
        styleElement.type = 'text/css';
        if (content) {
            styleElement.appendChild(document.createTextNode(content));
        }
        document.head.appendChild(styleElement);
        return styleElement;
    }
});
//# sourceMappingURL=Stylesheet.js.map