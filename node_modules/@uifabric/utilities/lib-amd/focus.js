/* tslint:disable:no-string-literal */
define(["require", "exports", "./dom"], function (require, exports, dom_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var IS_FOCUSABLE_ATTRIBUTE = 'data-is-focusable';
    var IS_VISIBLE_ATTRIBUTE = 'data-is-visible';
    var FOCUSZONE_ID_ATTRIBUTE = 'data-focuszone-id';
    var FOCUSZONE_SUB_ATTRIBUTE = 'data-is-sub-focuszone';
    /**
     * Gets the first focusable element.
     *
     * @public
     */
    function getFirstFocusable(rootElement, currentElement, includeElementsInFocusZones) {
        return getNextElement(rootElement, currentElement, true, false, false, includeElementsInFocusZones);
    }
    exports.getFirstFocusable = getFirstFocusable;
    /**
     * Gets the last focusable element.
     *
     * @public
     */
    function getLastFocusable(rootElement, currentElement, includeElementsInFocusZones) {
        return getPreviousElement(rootElement, currentElement, true, false, true, includeElementsInFocusZones);
    }
    exports.getLastFocusable = getLastFocusable;
    /**
     * Gets the last tabbable element.
     *
     * @public
     */
    function getLastTabbable(rootElement, currentElement, includeElementsInFocusZones) {
        return getPreviousElement(rootElement, currentElement, true, false, true, includeElementsInFocusZones, false, true);
    }
    exports.getLastTabbable = getLastTabbable;
    /**
     * Attempts to focus the first focusable element that is a child or child's child of the rootElement.
     *
     * @public
     * @param rootElement - Element to start the search for a focusable child.
     * @returns True if focus was set, false if it was not.
     */
    function focusFirstChild(rootElement) {
        var element = getNextElement(rootElement, rootElement, true, false, false, true);
        if (element) {
            focusAsync(element);
            return true;
        }
        return false;
    }
    exports.focusFirstChild = focusFirstChild;
    /**
     * Traverse to find the previous element.
     *
     * @public
     */
    function getPreviousElement(rootElement, currentElement, checkNode, suppressParentTraversal, traverseChildren, includeElementsInFocusZones, allowFocusRoot, tabbable) {
        if (!currentElement ||
            (!allowFocusRoot && currentElement === rootElement)) {
            return null;
        }
        var isCurrentElementVisible = isElementVisible(currentElement);
        // Check its children.
        if (traverseChildren && isCurrentElementVisible &&
            (includeElementsInFocusZones || !(isElementFocusZone(currentElement) || isElementFocusSubZone(currentElement)))) {
            var childMatch = getPreviousElement(rootElement, currentElement.lastElementChild, true, true, true, includeElementsInFocusZones, allowFocusRoot, tabbable);
            if (childMatch) {
                if ((tabbable && (isElementTabbable(childMatch, true))) || !tabbable) {
                    return childMatch;
                }
                var childMatchSiblingMatch = getPreviousElement(rootElement, childMatch.previousElementSibling, true, true, true, includeElementsInFocusZones, allowFocusRoot, tabbable);
                if (childMatchSiblingMatch) {
                    return childMatchSiblingMatch;
                }
                var childMatchParent = childMatch.parentElement;
                // At this point if we have not found any potential matches
                // start looking at the rest of the subtree under the currentParent.
                // NOTE: We do not want to recurse here because doing so could
                // cause elements to get skipped.
                while (childMatchParent && childMatchParent !== currentElement) {
                    var childMatchParentMatch = getPreviousElement(rootElement, childMatchParent.previousElementSibling, true, true, true, includeElementsInFocusZones, allowFocusRoot, tabbable);
                    if (childMatchParentMatch) {
                        return childMatchParentMatch;
                    }
                    childMatchParent = childMatchParent.parentElement;
                }
            }
        }
        // Check the current node, if it's not the first traversal.
        if (checkNode && isCurrentElementVisible && isElementTabbable(currentElement)) {
            return currentElement;
        }
        // Check its previous sibling.
        var siblingMatch = getPreviousElement(rootElement, currentElement.previousElementSibling, true, true, true, includeElementsInFocusZones, allowFocusRoot, tabbable);
        if (siblingMatch) {
            return siblingMatch;
        }
        // Check its parent.
        if (!suppressParentTraversal) {
            return getPreviousElement(rootElement, currentElement.parentElement, true, false, false, includeElementsInFocusZones, allowFocusRoot, tabbable);
        }
        return null;
    }
    exports.getPreviousElement = getPreviousElement;
    /**
     * Traverse to find the next focusable element.
     *
     * @public
     */
    function getNextElement(rootElement, currentElement, checkNode, suppressParentTraversal, suppressChildTraversal, includeElementsInFocusZones, allowFocusRoot) {
        if (!currentElement ||
            (currentElement === rootElement && suppressChildTraversal && !allowFocusRoot)) {
            return null;
        }
        var isCurrentElementVisible = isElementVisible(currentElement);
        // Check the current node, if it's not the first traversal.
        if (checkNode && isCurrentElementVisible && isElementTabbable(currentElement)) {
            return currentElement;
        }
        // Check its children.
        if (!suppressChildTraversal && isCurrentElementVisible &&
            (includeElementsInFocusZones || !(isElementFocusZone(currentElement) || isElementFocusSubZone(currentElement)))) {
            var childMatch = getNextElement(rootElement, currentElement.firstElementChild, true, true, false, includeElementsInFocusZones, allowFocusRoot);
            if (childMatch) {
                return childMatch;
            }
        }
        if (currentElement === rootElement) {
            return null;
        }
        // Check its sibling.
        var siblingMatch = getNextElement(rootElement, currentElement.nextElementSibling, true, true, false, includeElementsInFocusZones, allowFocusRoot);
        if (siblingMatch) {
            return siblingMatch;
        }
        if (!suppressParentTraversal) {
            return getNextElement(rootElement, currentElement.parentElement, false, false, true, includeElementsInFocusZones, allowFocusRoot);
        }
        return null;
    }
    exports.getNextElement = getNextElement;
    /**
     * Determines if an element is visible.
     *
     * @public
     */
    function isElementVisible(element) {
        // If the element is not valid, return false.
        if (!element || !element.getAttribute) {
            return false;
        }
        var visibilityAttribute = element.getAttribute(IS_VISIBLE_ATTRIBUTE);
        // If the element is explicitly marked with the visibility attribute, return that value as boolean.
        if (visibilityAttribute !== null && visibilityAttribute !== undefined) {
            return visibilityAttribute === 'true';
        }
        // Fallback to other methods of determining actual visibility.
        return (element.offsetHeight !== 0 ||
            element.offsetParent !== null ||
            // tslint:disable-next-line:no-any
            element.isVisible === true); // used as a workaround for testing.
    }
    exports.isElementVisible = isElementVisible;
    /**
     * Determines if an element can receive focus.
     *
     * @public
     */
    function isElementTabbable(element, checkTabIndex) {
        // If this element is null or is disabled, it is not considered tabbable.
        if (!element || element.disabled) {
            return false;
        }
        var tabIndex = 0;
        var tabIndexAttributeValue = null;
        if (element && element.getAttribute) {
            tabIndexAttributeValue = element.getAttribute('tabIndex');
            if (tabIndexAttributeValue) {
                tabIndex = parseInt(tabIndexAttributeValue, 10);
            }
        }
        var isFocusableAttribute = element.getAttribute ? element.getAttribute(IS_FOCUSABLE_ATTRIBUTE) : null;
        var isTabIndexSet = tabIndexAttributeValue !== null && tabIndex >= 0;
        var result = !!element &&
            isFocusableAttribute !== 'false' &&
            (element.tagName === 'A' ||
                (element.tagName === 'BUTTON') ||
                (element.tagName === 'INPUT') ||
                (element.tagName === 'TEXTAREA') ||
                isFocusableAttribute === 'true' ||
                isTabIndexSet ||
                element.getAttribute && element.getAttribute('role') === 'button');
        return checkTabIndex ? (tabIndex !== -1) && result : result;
    }
    exports.isElementTabbable = isElementTabbable;
    /**
     * Determines if a given element is a focus zone.
     *
     * @public
     */
    function isElementFocusZone(element) {
        return !!(element && element.getAttribute && !!element.getAttribute(FOCUSZONE_ID_ATTRIBUTE));
    }
    exports.isElementFocusZone = isElementFocusZone;
    /**
     * Determines if a given element is a focus sub zone.
     *
     * @public
     */
    function isElementFocusSubZone(element) {
        return !!(element && element.getAttribute && element.getAttribute(FOCUSZONE_SUB_ATTRIBUTE) === 'true');
    }
    exports.isElementFocusSubZone = isElementFocusSubZone;
    /**
     * Determines if an element, or any of its children, contain focus.
     *
     * @public
     */
    function doesElementContainFocus(element) {
        var document = dom_1.getDocument(element);
        var currentActiveElement = document && document.activeElement;
        if (currentActiveElement && dom_1.elementContains(element, currentActiveElement)) {
            return true;
        }
        return false;
    }
    exports.doesElementContainFocus = doesElementContainFocus;
    /**
     * Determines if an, or any of its ancestors, sepcificies that it doesn't want focus to wrap
     * @param element - element to start searching from
     * @param noWrapDataAttribute - the no wrap data attribute to match (either)
     * @returns true if focus should wrap, false otherwise
     */
    function shouldWrapFocus(element, noWrapDataAttribute) {
        return dom_1.elementContainsAttribute(element, noWrapDataAttribute) === 'true' ? false : true;
    }
    exports.shouldWrapFocus = shouldWrapFocus;
    var targetToFocusOnNextRepaint = undefined;
    /**
     * Sets focus to an element asynchronously. The focus will be set at the next browser repaint,
     * meaning it won't cause any extra recalculations. If more than one focusAsync is called during one frame,
     * only the latest called focusAsync element will actually be focused
     * @param element The element to focus
     */
    function focusAsync(element) {
        if (element) {
            // An element was already queued to be focused, so replace that one with the new element
            if (targetToFocusOnNextRepaint) {
                targetToFocusOnNextRepaint = element;
                return;
            }
            targetToFocusOnNextRepaint = element;
            // element.focus() is a no-op if the element is no longer in the DOM, meaning this is always safe
            element.ownerDocument.defaultView.requestAnimationFrame(function () {
                targetToFocusOnNextRepaint && targetToFocusOnNextRepaint.focus();
                // We are done focusing for this frame, so reset the queued focus element
                targetToFocusOnNextRepaint = undefined;
            });
        }
    }
    exports.focusAsync = focusAsync;
});
//# sourceMappingURL=focus.js.map