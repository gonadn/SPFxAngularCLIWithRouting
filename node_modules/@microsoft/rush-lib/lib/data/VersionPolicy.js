"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = require("lodash");
const semver = require("semver");
/**
 * Type of version bumps
 * @beta
 */
var BumpType;
(function (BumpType) {
    // No version bump
    BumpType[BumpType["none"] = 0] = "none";
    // Prerelease version bump
    BumpType[BumpType["prerelease"] = 1] = "prerelease";
    // Patch version bump
    BumpType[BumpType["patch"] = 2] = "patch";
    // Preminor version bump
    BumpType[BumpType["preminor"] = 3] = "preminor";
    // Minor version bump
    BumpType[BumpType["minor"] = 4] = "minor";
    // Major version bump
    BumpType[BumpType["major"] = 5] = "major";
})(BumpType = exports.BumpType || (exports.BumpType = {}));
/**
 * Version policy base type names
 * @beta
 */
var VersionPolicyDefinitionName;
(function (VersionPolicyDefinitionName) {
    VersionPolicyDefinitionName[VersionPolicyDefinitionName["lockStepVersion"] = 0] = "lockStepVersion";
    VersionPolicyDefinitionName[VersionPolicyDefinitionName["individualVersion"] = 1] = "individualVersion";
})(VersionPolicyDefinitionName = exports.VersionPolicyDefinitionName || (exports.VersionPolicyDefinitionName = {}));
/**
 * This is the base class for version policy which controls how versions get bumped.
 * @beta
 */
class VersionPolicy {
    /**
     * Loads from version policy json
     *
     * @param versionPolicyJson - version policy Json
     *
     * @internal
     */
    static load(versionPolicyJson) {
        const definition = VersionPolicyDefinitionName[versionPolicyJson.definitionName];
        if (definition === VersionPolicyDefinitionName.lockStepVersion) {
            // tslint:disable-next-line:no-use-before-declare
            return new LockStepVersionPolicy(versionPolicyJson);
        }
        else if (definition === VersionPolicyDefinitionName.individualVersion) {
            // tslint:disable-next-line:no-use-before-declare
            return new IndividualVersionPolicy(versionPolicyJson);
        }
        return undefined;
    }
    /**
     * @internal
     */
    constructor(versionPolicyJson) {
        this._policyName = versionPolicyJson.policyName;
        this._definitionName = VersionPolicyDefinitionName[versionPolicyJson.definitionName];
    }
    /**
     * Version policy name
     */
    get policyName() {
        return this._policyName;
    }
    /**
     * Version policy definition name
     */
    get definitionName() {
        return this._definitionName;
    }
}
exports.VersionPolicy = VersionPolicy;
/**
 * This policy indicates all related projects should use the same version.
 * @beta
 */
class LockStepVersionPolicy extends VersionPolicy {
    /**
     * @internal
     */
    constructor(versionPolicyJson) {
        super(versionPolicyJson);
        this._version = new semver.SemVer(versionPolicyJson.version);
        this._nextBump = BumpType[versionPolicyJson.nextBump];
    }
    /**
     * The value of the lockstep version
     */
    get version() {
        return this._version;
    }
    /**
     * The type of bump for next bump.
     */
    get nextBump() {
        return this._nextBump;
    }
    /**
     * Serialized json for this policy
     *
     * @internal
     */
    get _json() {
        return {
            policyName: this.policyName,
            definitionName: VersionPolicyDefinitionName[this.definitionName],
            version: this.version.format(),
            nextBump: BumpType[this.nextBump]
        };
    }
    /**
     * Returns an updated package json that satisfies the version policy.
     *
     * @param project - input package json
     */
    ensure(project) {
        const packageVersion = new semver.SemVer(project.version);
        const compareResult = packageVersion.compare(this._version);
        if (compareResult === 0) {
            return undefined;
        }
        else if (compareResult > 0) {
            const errorMessage = `Version ${project.version} in package ${project.name}`
                + ` is higher than locked version ${this._version.format()}.`;
            throw new Error(errorMessage);
        }
        return this._updatePackageVersion(project, this._version);
    }
    /**
     * Bumps the version of the lockstep policy
     *
     * @param bumpType - Overwrite bump type in version-policy.json with the provided value.
     * @param identifier - Prerelease identifier if bump type is prerelease.
     */
    bump(bumpType, identifier) {
        this.version.inc(this._getReleaseType(bumpType || this.nextBump), identifier);
    }
    /**
     * Validates the specified version and throws if the version does not satisfy lockstep version.
     *
     * @param versionString - version string
     * @param packageName - package name
     */
    validate(versionString, packageName) {
        const versionToTest = new semver.SemVer(versionString, false);
        if (this.version.compare(versionToTest) !== 0) {
            throw new Error(`Invalid version ${versionString} in ${packageName}`);
        }
    }
    _updatePackageVersion(project, newVersion) {
        const updatedProject = lodash_1.cloneDeep(project);
        updatedProject.version = newVersion.format();
        return updatedProject;
    }
    _getReleaseType(bumpType) {
        // Eventually we should just use ReleaseType and get rid of bump type.
        return BumpType[bumpType];
    }
}
exports.LockStepVersionPolicy = LockStepVersionPolicy;
/**
 * This policy indicates all related projects get version bump driven by their own changes.
 * @beta
 */
class IndividualVersionPolicy extends VersionPolicy {
    /**
     * @internal
     */
    constructor(versionPolicyJson) {
        super(versionPolicyJson);
        this._lockedMajor = versionPolicyJson.lockedMajor;
    }
    /**
     * The major version that has been locked
     */
    get lockedMajor() {
        return this._lockedMajor;
    }
    /**
     * Serialized json for this policy
     *
     * @internal
     */
    get _json() {
        return {
            policyName: this.policyName,
            definitionName: VersionPolicyDefinitionName[this.definitionName],
            lockedMajor: this.lockedMajor
        };
    }
    /**
     * Returns an updated package json that satisfies the version policy.
     *
     * @param project - input package json
     */
    ensure(project) {
        if (this.lockedMajor) {
            const version = new semver.SemVer(project.version);
            if (version.major < this.lockedMajor) {
                const updatedProject = lodash_1.cloneDeep(project);
                updatedProject.version = `${this._lockedMajor}.0.0`;
                return updatedProject;
            }
            else if (version.major > this.lockedMajor) {
                const errorMessage = `Version ${project.version} in package ${project.name}`
                    + ` is higher than locked major version ${this._lockedMajor}.`;
                throw new Error(errorMessage);
            }
        }
        return undefined;
    }
    /**
     * Bumps version.
     * Individual version policy lets change files drive version bump. This method currently does not do anything.
     *
     * @param bumpType - bump type
     * @param identifier - prerelease id
     */
    bump(bumpType, identifier) {
        // individual version policy lets change files drive version bump.
    }
    /**
     * Validates the specified version and throws if the version does not satisfy the policy.
     *
     * @param versionString - version string
     * @param packageName - package name
     */
    validate(versionString, packageName) {
        const versionToTest = new semver.SemVer(versionString, false);
        if (this._lockedMajor !== undefined) {
            if (this._lockedMajor !== versionToTest.major) {
                throw new Error(`Invalid major version ${versionString} in ${packageName}`);
            }
        }
    }
}
exports.IndividualVersionPolicy = IndividualVersionPolicy;

//# sourceMappingURL=VersionPolicy.js.map
