"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @public
 */
class VersionMismatchFinder {
    constructor(_projects) {
        this._projects = _projects;
        this._mismatches = new Map();
        this._analyze();
    }
    get numberOfMismatches() {
        return this._mismatches.size;
    }
    getMismatches() {
        return this._getKeys(this._mismatches);
    }
    getVersionsOfMismatch(mismatch) {
        return this._mismatches.has(mismatch)
            ? this._getKeys(this._mismatches.get(mismatch))
            : undefined;
    }
    getConsumersOfMismatch(mismatch, version) {
        const mismatchedPackage = this._mismatches.get(mismatch);
        if (!mismatchedPackage) {
            return undefined;
        }
        const mismatchedVersion = mismatchedPackage.get(version);
        return mismatchedVersion;
    }
    _analyze() {
        this._projects.forEach((project) => {
            this._addDependenciesToList(project.packageName, project.packageJson.dependencies, project.cyclicDependencyProjects);
            this._addDependenciesToList(project.packageName, project.packageJson.devDependencies, project.cyclicDependencyProjects);
            this._addDependenciesToList(project.packageName, project.packageJson.peerDependencies, project.cyclicDependencyProjects);
            this._addDependenciesToList(project.packageName, project.packageJson.optionalDependencies, project.cyclicDependencyProjects);
        });
        this._mismatches.forEach((mismatches, project) => {
            if (mismatches.size <= 1) {
                this._mismatches.delete(project);
            }
        });
    }
    _addDependenciesToList(project, dependencyMap, exclude) {
        if (dependencyMap) {
            Object.keys(dependencyMap).forEach((dependency) => {
                if (!exclude || !exclude.has(dependency)) {
                    const version = dependencyMap[dependency];
                    if (!this._mismatches.has(dependency)) {
                        this._mismatches.set(dependency, new Map());
                    }
                    const dependencyVersions = this._mismatches.get(dependency);
                    if (!dependencyVersions.has(version)) {
                        dependencyVersions.set(version, []);
                    }
                    dependencyVersions.get(version).push(project);
                }
            });
        }
    }
    // tslint:disable-next-line:no-any
    _getKeys(iterable) {
        const keys = [];
        if (iterable) {
            // tslint:disable-next-line:no-any
            iterable.forEach((value, key) => {
                keys.push(key);
            });
        }
        return keys;
    }
}
exports.VersionMismatchFinder = VersionMismatchFinder;

//# sourceMappingURL=VersionMismatchFinder.js.map
