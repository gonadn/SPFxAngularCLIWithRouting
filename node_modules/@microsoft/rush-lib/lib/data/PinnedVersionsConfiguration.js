"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const semver = require("semver");
const node_core_library_1 = require("@microsoft/node-core-library");
/**
 * Pinned Versions is a Rush feature designed to mimic the behavior of NPM
 * when performing an install. Essentially, for a project, NPM installs all of
 * the first level dependencies before starting any second-level dependencies.
 * This means that you can control the specific version of a second-level dependency
 * by promoting it to a 1st level dependency and using a version number that would satisfy.
 * However, since rush uses the /common/package.json file, NPM treats each rush project
 * as a top-level dependency, and treats the actual 1st level dependencies as second order.
 * This means you could have cases where there is unnecessary inversion and side-by-side versioning
 * in your shrinkwrap file. To mitigate this issue, we promote some dependencies and list them
 * directly in the /common/package.json, ensuring that the selected version will be installed first
 * and at the root.
 * @public
 */
class PinnedVersionsConfiguration {
    /**
     * Preferred to use PinnedVersionsConfiguration.loadFromFile()
     */
    constructor(pinnedVersionJson, _filename) {
        this._filename = _filename;
        this._data = new Map();
        if (pinnedVersionJson) {
            for (const dependency of Object.keys(pinnedVersionJson)) {
                this.set(dependency, pinnedVersionJson[dependency]);
            }
        }
    }
    /** Attempts to load pinned versions configuration from a given file */
    static tryLoadFromFile(jsonFilename) {
        let pinnedVersionJson = undefined;
        if (fs.existsSync(jsonFilename)) {
            pinnedVersionJson = node_core_library_1.JsonFile.load(jsonFilename);
        }
        return new PinnedVersionsConfiguration(pinnedVersionJson, jsonFilename);
    }
    /** Set a pinned version. Checks that the version is a valid semver. */
    set(dependency, version) {
        if (!semver.valid(version) && !semver.validRange(version)) {
            throw new Error(`The pinned version "${version}" for "${dependency}" project is not a valid semantic version.`);
        }
        this._data.set(dependency, version);
        return this;
    }
    get(dependency) {
        return this._data.get(dependency);
    }
    has(dependency) {
        return this._data.has(dependency);
    }
    forEach(cb) {
        this._data.forEach(cb);
        return this;
    }
    save() {
        node_core_library_1.JsonFile.save(this._serialize(), this._filename);
        return this;
    }
    delete(dependency) {
        return this._data.delete(dependency);
    }
    clear() {
        this._data.clear();
        return this;
    }
    get size() {
        return this._data.size;
    }
    _serialize() {
        const rawJson = {};
        this._data.forEach((version, dependency) => {
            rawJson[dependency] = version;
        });
        return rawJson;
    }
}
exports.PinnedVersionsConfiguration = PinnedVersionsConfiguration;

//# sourceMappingURL=PinnedVersionsConfiguration.js.map
