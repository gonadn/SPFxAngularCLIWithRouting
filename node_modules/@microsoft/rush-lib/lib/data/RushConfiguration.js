"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const fsx = require("fs-extra");
const semver = require("semver");
const node_core_library_1 = require("@microsoft/node-core-library");
const Rush_1 = require("../Rush");
const RushConfigurationProject_1 = require("./RushConfigurationProject");
const PinnedVersionsConfiguration_1 = require("./PinnedVersionsConfiguration");
const Utilities_1 = require("../utilities/Utilities");
const RushConstants_1 = require("../RushConstants");
const ApprovedPackagesPolicy_1 = require("./ApprovedPackagesPolicy");
const EventHooks_1 = require("./EventHooks");
const VersionPolicyConfiguration_1 = require("./VersionPolicyConfiguration");
const MINIMUM_SUPPORTED_RUSH_JSON_VERSION = '0.0.0';
/**
 * A list of known config filenames that are expected to appear in the "./common/config/rush" folder.
 * To avoid confusion/mistakes, any extra files will be reported as an error.
 */
const knownRushConfigFilenames = [
    '.npmrc',
    RushConstants_1.RushConstants.npmShrinkwrapFilename,
    RushConstants_1.RushConstants.pinnedVersionsFilename,
    RushConstants_1.RushConstants.browserApprovedPackagesFilename,
    RushConstants_1.RushConstants.nonbrowserApprovedPackagesFilename,
    RushConstants_1.RushConstants.versionPoliciesFileName,
    RushConstants_1.RushConstants.commandLineFilename
];
/**
 * This represents the Rush configuration for a repository, based on the Rush.json
 * configuration file.
 * @public
 */
class RushConfiguration {
    /**
     * Use RushConfiguration.loadFromConfigurationFile() or Use RushConfiguration.loadFromDefaultLocation()
     * instead.
     */
    constructor(rushConfigurationJson, rushJsonFilename) {
        if (rushConfigurationJson.nodeSupportedVersionRange) {
            if (!semver.validRange(rushConfigurationJson.nodeSupportedVersionRange)) {
                throw new Error('Error parsing the node-semver expression in the "nodeSupportedVersionRange"'
                    + ` field from rush.json: "${rushConfigurationJson.nodeSupportedVersionRange}"`);
            }
            if (!semver.satisfies(process.version, rushConfigurationJson.nodeSupportedVersionRange)) {
                throw new Error(`Your dev environment is running Node.js version ${process.version} which does`
                    + ` not meet the requirements for building this repository.  (The rush.json configuration`
                    + ` requires nodeSupportedVersionRange="${rushConfigurationJson.nodeSupportedVersionRange}")`);
            }
        }
        this._rushJsonFile = rushJsonFilename;
        this._rushJsonFolder = path.dirname(rushJsonFilename);
        this._commonFolder = path.resolve(path.join(this._rushJsonFolder, RushConstants_1.RushConstants.commonFolderName));
        this._commonRushConfigFolder = path.join(this._commonFolder, 'config', 'rush');
        RushConfiguration._validateCommonRushConfigFolder(this._commonRushConfigFolder);
        this._commonTempFolder = path.join(this._commonFolder, RushConstants_1.RushConstants.rushTempFolderName);
        this._npmCacheFolder = path.resolve(path.join(this._commonTempFolder, 'npm-cache'));
        this._npmTmpFolder = path.resolve(path.join(this._commonTempFolder, 'npm-tmp'));
        this._changesFolder = path.join(this._commonFolder, RushConstants_1.RushConstants.changeFilesFolderName);
        this._committedShrinkwrapFilename = path.join(this._commonRushConfigFolder, RushConstants_1.RushConstants.npmShrinkwrapFilename);
        this._tempShrinkwrapFilename = path.join(this._commonTempFolder, RushConstants_1.RushConstants.npmShrinkwrapFilename);
        this._homeFolder = RushConfiguration.getHomeDirectory();
        this._rushLinkJsonFilename = path.join(this._commonTempFolder, 'rush-link.json');
        this._npmToolVersion = rushConfigurationJson.npmVersion;
        this._npmToolFilename = path.resolve(path.join(this._commonTempFolder, 'npm-local', 'node_modules', '.bin', 'npm'));
        this._projectFolderMinDepth = rushConfigurationJson.projectFolderMinDepth !== undefined
            ? rushConfigurationJson.projectFolderMinDepth : 1;
        if (this._projectFolderMinDepth < 1) {
            throw new Error('Invalid projectFolderMinDepth; the minimum possible value is 1');
        }
        this._projectFolderMaxDepth = rushConfigurationJson.projectFolderMaxDepth !== undefined
            ? rushConfigurationJson.projectFolderMaxDepth : 2;
        if (this._projectFolderMaxDepth < this._projectFolderMinDepth) {
            throw new Error('The projectFolderMaxDepth cannot be smaller than the projectFolderMinDepth');
        }
        this._approvedPackagesPolicy = new ApprovedPackagesPolicy_1.ApprovedPackagesPolicy(this, rushConfigurationJson);
        this._gitAllowedEmailRegExps = [];
        this._gitSampleEmail = '';
        if (rushConfigurationJson.gitPolicy) {
            if (rushConfigurationJson.gitPolicy.sampleEmail) {
                this._gitSampleEmail = rushConfigurationJson.gitPolicy.sampleEmail;
            }
            if (rushConfigurationJson.gitPolicy.allowedEmailRegExps) {
                this._gitAllowedEmailRegExps = rushConfigurationJson.gitPolicy.allowedEmailRegExps;
                if (this._gitSampleEmail.trim().length < 1) {
                    throw new Error('The rush.json file is missing the "sampleEmail" option, ' +
                        'which is required when using "allowedEmailRegExps"');
                }
            }
        }
        if (rushConfigurationJson.repository) {
            this._repositoryUrl = rushConfigurationJson.repository.url;
        }
        this._telemetryEnabled = !!rushConfigurationJson.telemetryEnabled;
        if (rushConfigurationJson.eventHooks) {
            this._eventHooks = new EventHooks_1.default(rushConfigurationJson.eventHooks);
        }
        const versionPolicyConfigFile = path.join(this._commonRushConfigFolder, RushConstants_1.RushConstants.versionPoliciesFileName);
        this._versionPolicyConfiguration = new VersionPolicyConfiguration_1.VersionPolicyConfiguration(versionPolicyConfigFile);
        this._projects = [];
        this._projectsByName = new Map();
        // We sort the projects array in alphabetical order.  This ensures that the packages
        // are processed in a deterministic order by the various Rush algorithms.
        const sortedProjectJsons = rushConfigurationJson.projects.slice(0);
        sortedProjectJsons.sort((a, b) => a.packageName.localeCompare(b.packageName));
        const tempNamesByProject = RushConfiguration._generateTempNamesForProjects(sortedProjectJsons);
        for (const projectJson of sortedProjectJsons) {
            const tempProjectName = tempNamesByProject.get(projectJson);
            if (tempProjectName) {
                const project = new RushConfigurationProject_1.default(projectJson, this, tempProjectName);
                this._projects.push(project);
                if (this._projectsByName.get(project.packageName)) {
                    throw new Error(`The project name "${project.packageName}" was specified more than once`
                        + ` in the rush.json configuration file.`);
                }
                this._projectsByName.set(project.packageName, project);
            }
        }
        for (const project of this._projects) {
            project.cyclicDependencyProjects.forEach((cyclicDependencyProject) => {
                if (!this.getProjectByName(cyclicDependencyProject)) {
                    throw new Error(`In rush.json, the "${cyclicDependencyProject}" project does not exist,`
                        + ` but was referenced by the cyclicDependencyProjects for ${project.packageName}`);
                }
            });
            // Compute the downstream dependencies within the list of Rush projects.
            this._populateDownstreamDependencies(project.packageJson.dependencies, project.packageName);
            this._populateDownstreamDependencies(project.packageJson.devDependencies, project.packageName);
        }
        // Example: "./common/config/rush/pinnedVersions.json"
        const pinnedVersionsFile = path.join(this.commonRushConfigFolder, RushConstants_1.RushConstants.pinnedVersionsFilename);
        this._pinnedVersions = PinnedVersionsConfiguration_1.PinnedVersionsConfiguration.tryLoadFromFile(pinnedVersionsFile);
    }
    /**
     * Loads the configuration data from an Rush.json configuration file and returns
     * an RushConfiguration object.
     */
    static loadFromConfigurationFile(rushJsonFilename) {
        const rushConfigurationJson = node_core_library_1.JsonFile.load(rushJsonFilename);
        // Check the Rush version *before* we validate the schema, since if the version is outdated
        // then the schema may have changed. This should no longer be a problem after Rush 4.0 and the C2R wrapper,
        // but we'll validate anyway.
        const expectedRushVersion = rushConfigurationJson.rushVersion;
        // If the version is missing or malformed, fall through and let the schema handle it.
        if (expectedRushVersion && semver.valid(expectedRushVersion)) {
            if (semver.lt(Rush_1.default.version, expectedRushVersion)) {
                throw new Error(`Your rush tool is version ${Rush_1.default.version}, but rush.json ` +
                    `requires version ${rushConfigurationJson.rushVersion}. To upgrade, ` +
                    `run "npm install @microsoft/rush -g".`);
            }
            else if (semver.lt(expectedRushVersion, MINIMUM_SUPPORTED_RUSH_JSON_VERSION)) {
                throw new Error(`rush.json is version ${expectedRushVersion}, which is too old for this tool. ` +
                    `The minimum supported version is ${MINIMUM_SUPPORTED_RUSH_JSON_VERSION}.`);
            }
        }
        RushConfiguration._jsonSchema.validateObject(rushConfigurationJson, rushJsonFilename);
        return new RushConfiguration(rushConfigurationJson, rushJsonFilename);
    }
    static loadFromDefaultLocation() {
        const rushJsonLocation = RushConfiguration.tryFindRushJsonLocation();
        if (rushJsonLocation) {
            return RushConfiguration.loadFromConfigurationFile(rushJsonLocation);
        }
        else {
            throw new Error('Unable to find rush.json configuration file');
        }
    }
    /**
     * Find the rush.json location and return the path, or undefined if a rush.json can't be found.
     */
    static tryFindRushJsonLocation(verbose = true) {
        let currentFolder = process.cwd();
        // Look upwards at parent folders until we find a folder containing rush.json
        for (let i = 0; i < 10; ++i) {
            const rushJsonFilename = path.join(currentFolder, 'rush.json');
            if (fsx.existsSync(rushJsonFilename)) {
                if (i > 0 && verbose) {
                    console.log('Found configuration in ' + rushJsonFilename);
                }
                if (verbose) {
                    console.log('');
                }
                return rushJsonFilename;
            }
            const parentFolder = path.dirname(currentFolder);
            if (parentFolder === currentFolder) {
                break;
            }
            currentFolder = parentFolder;
        }
        return undefined;
    }
    /**
     * Get the user's home directory. On windows this looks something like "C:\users\username\" and on UNIX
     * this looks something like "/usr/username/"
     */
    static getHomeDirectory() {
        const unresolvedUserFolder = process.env[(process.platform === 'win32') ? 'USERPROFILE' : 'HOME'];
        const homeFolder = path.resolve(unresolvedUserFolder);
        if (!fsx.existsSync(homeFolder)) {
            throw new Error('Unable to determine the current user\'s home directory');
        }
        return homeFolder;
    }
    /**
     * This generates the unique names that are used to create temporary projects
     * in the Rush common folder.
     * NOTE: sortedProjectJsons is sorted by the caller.
     */
    static _generateTempNamesForProjects(sortedProjectJsons) {
        const tempNamesByProject = new Map();
        const usedTempNames = new Set();
        // NOTE: projectJsons was already sorted in alphabetical order by the caller.
        for (const projectJson of sortedProjectJsons) {
            // If the name is "@ms/MyProject", extract the "MyProject" part
            const unscopedName = Utilities_1.default.parseScopedPackageName(projectJson.packageName).name;
            // Generate a unique like name "@rush-temp/MyProject", or "@rush-temp/MyProject-2" if
            // there is a naming conflict
            let counter = 0;
            let tempProjectName = `${RushConstants_1.RushConstants.rushTempNpmScope}/${unscopedName}`;
            while (usedTempNames.has(tempProjectName)) {
                ++counter;
                tempProjectName = `${RushConstants_1.RushConstants.rushTempNpmScope}/${unscopedName}-${counter}`;
            }
            usedTempNames.add(tempProjectName);
            tempNamesByProject.set(projectJson, tempProjectName);
        }
        return tempNamesByProject;
    }
    /**
     * If someone adds a config file in the "common/rush/config" folder, it would be a bad
     * experience for Rush to silently ignore their file simply because they misspelled the
     * filename, or maybe it's an old format that's no longer supported.  The
     * _validateCommonRushConfigFolder() function makes sure that this folder only contains
     * recognized config files.
     */
    static _validateCommonRushConfigFolder(commonRushConfigFolder) {
        if (!fsx.existsSync(commonRushConfigFolder)) {
            console.log(`Creating folder: ${commonRushConfigFolder}`);
            fsx.mkdirsSync(commonRushConfigFolder);
            return;
        }
        const filenames = fsx.readdirSync(commonRushConfigFolder);
        for (const filename of filenames) {
            const resolvedFilename = path.resolve(commonRushConfigFolder, filename);
            // Ignore things that aren't actual files
            const stat = fsx.lstatSync(resolvedFilename);
            if (!stat.isFile() && !stat.isSymbolicLink()) {
                continue;
            }
            // Ignore harmless file extensions
            const fileExtension = path.extname(filename);
            if (['.bak', '.disabled', '.md', '.old', '.orig'].indexOf(fileExtension) >= 0) {
                continue;
            }
            const knownSet = new Set(knownRushConfigFilenames.map(x => x.toUpperCase()));
            // Is the filename something we know?  If not, report an error.
            if (!knownSet.has(filename.toUpperCase())) {
                throw new Error(`An unrecognized file "${filename}" was found in the Rush config folder:`
                    + ` ${commonRushConfigFolder}`);
            }
        }
    }
    /**
     * The Rush configuration file
     */
    get rushJsonFile() {
        return this._rushJsonFile;
    }
    /**
     * The folder that contains rush.json for this project.
     */
    get rushJsonFolder() {
        return this._rushJsonFolder;
    }
    /**
     * The folder that contains all change files.
     */
    get changesFolder() {
        return this._changesFolder;
    }
    /**
     * The fully resolved path for the "common" folder where Rush will store settings that
     * affect all Rush projects.  This is always a subfolder of the folder containing "rush.json".
     * Example: "C:\MyRepo\common"
     */
    get commonFolder() {
        return this._commonFolder;
    }
    /**
     * The folder where Rush's additional config files are stored.  This folder is always a
     * subfolder called "config\rush" inside the common folder.  (The "common\config" folder
     * is reserved for configuration files used by other tools.)  To avoid confusion or mistakes,
     * Rush will report an error if this this folder contains any unrecognized files.
     *
     * Example: "C:\MyRepo\common\config\rush"
     */
    get commonRushConfigFolder() {
        return this._commonRushConfigFolder;
    }
    /**
     * The folder where temporary files will be stored.  This is always a subfolder called "temp"
     * inside the common folder.
     * Example: "C:\MyRepo\common\temp"
     */
    get commonTempFolder() {
        return this._commonTempFolder;
    }
    /**
     * The local folder that will store the NPM package cache.  Rush does not rely on the
     * NPM's default global cache folder, because NPM's caching implementation does not
     * reliably handle multiple processes.  (For example, if a build box is running
     * "rush install" simultaneously for two different working folders, it may fail randomly.)
     *
     * Example: "C:\MyRepo\common\temp\npm-cache"
     */
    get npmCacheFolder() {
        return this._npmCacheFolder;
    }
    /**
     * The local folder where NPM's temporary files will be written during installation.
     * Rush does not rely on the global default folder, because it may be on a different
     * hard disk.
     *
     * Example: "C:\MyRepo\common\temp\npm-tmp"
     */
    get npmTmpFolder() {
        return this._npmTmpFolder;
    }
    /**
     * The filename of the NPM shrinkwrap file that is tracked e.g. by Git.  (The "rush install"
     * command uses a temporary copy, whose path is tempShrinkwrapFilename.)
     * This property merely reports the filename; the file itself may not actually exist.
     * Example: "C:\MyRepo\common\npm-shrinkwrap.json"
     */
    get committedShrinkwrapFilename() {
        return this._committedShrinkwrapFilename;
    }
    /**
     * The filename of the temporary NPM shrinkwrap file that is used by "rush install".
     * (The master copy is tempShrinkwrapFilename.)
     * This property merely reports the filename; the file itself may not actually exist.
     * Example: "C:\MyRepo\common\temp\npm-shrinkwrap.json"
     */
    get tempShrinkwrapFilename() {
        return this._tempShrinkwrapFilename;
    }
    /**
     * The absolute path to the home directory for the current user.  On Windows,
     * it would be something like "C:\Users\YourName".
     */
    get homeFolder() {
        return this._homeFolder;
    }
    /**
     * The filename of the build dependency data file.  By default this is
     * called 'rush-link.json' resides in the Rush common folder.
     * Its data structure is defined by IRushLinkJson.
     *
     * Example: "C:\MyRepo\common\temp\rush-link.json"
     */
    get rushLinkJsonFilename() {
        return this._rushLinkJsonFilename;
    }
    /**
     * The version of the locally installed NPM tool.  (Example: "1.2.3")
     */
    get npmToolVersion() {
        return this._npmToolVersion;
    }
    /**
     * The absolute path to the locally installed NPM tool.  If "rush install" has not
     * been run, then this file may not exist yet.
     * Example: "C:\MyRepo\common\temp\npm-local\node_modules\.bin\npm"
     */
    get npmToolFilename() {
        return this._npmToolFilename;
    }
    /**
     * The minimum allowable folder depth for the projectFolder field in the rush.json file.
     * This setting provides a way for repository maintainers to discourage nesting of project folders
     * that makes the directory tree more difficult to navigate.  The default value is 2,
     * which implements a standard 2-level hierarchy of <categoryFolder>/<projectFolder>/package.json.
     */
    get projectFolderMinDepth() {
        return this._projectFolderMinDepth;
    }
    /**
     * The maximum allowable folder depth for the projectFolder field in the rush.json file.
     * This setting provides a way for repository maintainers to discourage nesting of project folders
     * that makes the directory tree more difficult to navigate.  The default value is 2,
     * which implements on a standard convention of <categoryFolder>/<projectFolder>/package.json.
     */
    get projectFolderMaxDepth() {
        return this._projectFolderMaxDepth;
    }
    /**
     * The "approvedPackagesPolicy" settings.
     */
    get approvedPackagesPolicy() {
        return this._approvedPackagesPolicy;
    }
    /**
     * [Part of the "gitPolicy" feature.]
     * A list of regular expressions describing allowable e-mail patterns for Git commits.
     * They are case-insensitive anchored JavaScript RegExps.
     * Example: ".*@example\.com"
     * This array will never be undefined.
     */
    get gitAllowedEmailRegExps() {
        return this._gitAllowedEmailRegExps;
    }
    /**
     * [Part of the "gitPolicy" feature.]
     * An example valid e-mail address that conforms to one of the allowedEmailRegExps.
     * Example: "foxtrot@example\.com"
     * This will never be undefined, and will always be nonempty if gitAllowedEmailRegExps is used.
     */
    get gitSampleEmail() {
        return this._gitSampleEmail;
    }
    /**
     * The remote url of the repository. It helps 'Rush change' finds the right remote to compare against.
     */
    get repositoryUrl() {
        return this._repositoryUrl;
    }
    /**
     * Indicates whether telemetry collection is enabled for Rush runs.
     * @beta
     */
    get telemetryEnabled() {
        return this._telemetryEnabled;
    }
    get projects() {
        return this._projects;
    }
    get projectsByName() {
        return this._projectsByName;
    }
    /**
     * The PinnedVersionsConfiguration object.  If the pinnedVersions.json file is missing,
     * this property will NOT be undefined.  Instead it will be initialized in an empty state,
     * and calling PinnedVersionsConfiguration.save() will create the file.
     */
    get pinnedVersions() {
        return this._pinnedVersions;
    }
    /**
     * The rush hooks. It allows customized scripts to run at the specified point.
     * @beta
     */
    get eventHooks() {
        return this._eventHooks;
    }
    /**
     * Looks up a project in the projectsByName map.  If the project is not found,
     * then undefined is returned.
     */
    getProjectByName(projectName) {
        return this._projectsByName.get(projectName);
    }
    /**
     * This is used e.g. by command-line interfaces such as "rush build --to example".
     * If "example" is not a project name, then it also looks for a scoped name
     * like "@something/example".  If exactly one project matches this heuristic, it
     * is returned.  Otherwise, undefined is returned.
     */
    findProjectByShorthandName(shorthandProjectName) {
        // Is there an exact match?
        let result = this._projectsByName.get(shorthandProjectName);
        if (result) {
            return result;
        }
        // Is there an approximate match?
        for (const project of this._projects) {
            if (Utilities_1.default.parseScopedPackageName(project.packageName).name === shorthandProjectName) {
                if (result) {
                    // Ambiguous -- there is more than one match
                    return undefined;
                }
                else {
                    result = project;
                }
            }
        }
        return result;
    }
    /**
     * Looks up a project by its RushConfigurationProject.tempProjectName field.
     * @returns The found project, or undefined if no match was found.
     */
    findProjectByTempName(tempProjectName) {
        // Is there an approximate match?
        for (const project of this._projects) {
            if (project.tempProjectName === tempProjectName) {
                return project;
            }
        }
        return undefined;
    }
    /**
     * @beta
     */
    get versionPolicyConfiguration() {
        return this._versionPolicyConfiguration;
    }
    _populateDownstreamDependencies(dependencies, packageName) {
        if (!dependencies) {
            return;
        }
        Object.keys(dependencies).forEach(dependencyName => {
            const depProject = this._projectsByName.get(dependencyName);
            if (depProject) {
                depProject.downstreamDependencyProjects.push(packageName);
            }
        });
    }
}
RushConfiguration._jsonSchema = node_core_library_1.JsonSchema.fromFile(path.join(__dirname, '../schemas/rush.schema.json'));
exports.default = RushConfiguration;

//# sourceMappingURL=RushConfiguration.js.map
