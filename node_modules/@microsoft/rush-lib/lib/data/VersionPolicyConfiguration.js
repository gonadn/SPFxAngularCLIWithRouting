"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const fsx = require("fs-extra");
const node_core_library_1 = require("@microsoft/node-core-library");
const VersionPolicy_1 = require("./VersionPolicy");
/**
 * @beta
 */
class VersionPolicyConfiguration {
    /**
     * @internal
     */
    constructor(_jsonFileName) {
        this._jsonFileName = _jsonFileName;
        this._versionPolicies = new Map();
        this._loadFile();
    }
    /**
     * Gets the version policy by its name.
     * Throws error if the version policy is not found.
     * @param policyName - Name of the version policy
     */
    getVersionPolicy(policyName) {
        const policy = this._versionPolicies.get(policyName);
        if (!policy) {
            throw new Error(`Failed to find version policy by name \'${policyName}\'`);
        }
        return policy;
    }
    /**
     * Gets all the version policies
     */
    get versionPolicies() {
        return this._versionPolicies;
    }
    /**
     * Bumps up versions for the specified version policy or all version policies
     *
     * @param versionPolicyName - version policy name
     * @param bumpType - bump type to override what policy has defined.
     * @param identifier - prerelease identifier to override what policy has defined.
     * @param shouldCommit - should save to disk
     */
    bump(versionPolicyName, bumpType, identifier, shouldCommit) {
        if (versionPolicyName) {
            const policy = this.versionPolicies.get(versionPolicyName);
            if (policy) {
                policy.bump(bumpType, identifier);
            }
        }
        else {
            this.versionPolicies.forEach((versionPolicy) => {
                if (versionPolicy) {
                    versionPolicy.bump(bumpType, identifier);
                }
            });
        }
        const versionPolicyJson = [];
        this.versionPolicies.forEach((versionPolicy) => {
            versionPolicyJson.push(versionPolicy._json);
        });
        if (shouldCommit) {
            node_core_library_1.JsonFile.save(versionPolicyJson, this._jsonFileName);
        }
    }
    _loadFile() {
        if (!fsx.existsSync(this._jsonFileName)) {
            return;
        }
        const versionPolicyJson = node_core_library_1.JsonFile.loadAndValidate(this._jsonFileName, VersionPolicyConfiguration._jsonSchema);
        versionPolicyJson.forEach(policyJson => {
            const policy = VersionPolicy_1.VersionPolicy.load(policyJson);
            if (policy) {
                this._versionPolicies.set(policy.policyName, policy);
            }
        });
    }
}
VersionPolicyConfiguration._jsonSchema = node_core_library_1.JsonSchema.fromFile(path.join(__dirname, '../schemas/version-policies.schema.json'));
exports.VersionPolicyConfiguration = VersionPolicyConfiguration;

//# sourceMappingURL=VersionPolicyConfiguration.js.map
