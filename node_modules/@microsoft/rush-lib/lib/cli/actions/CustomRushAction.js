"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const fsx = require("fs-extra");
const os = require("os");
const colors = require("colors");
const index_1 = require("../../index");
const BaseRushAction_1 = require("./BaseRushAction");
const TaskSelector_1 = require("../utilities/TaskSelector");
const Stopwatch_1 = require("../../utilities/Stopwatch");
class CustomRushAction extends BaseRushAction_1.BaseRushAction {
    constructor(_parser, options, _parallelized = false) {
        super(options);
        this._parser = _parser;
        this._parallelized = _parallelized;
        this.customOptions = new Map();
    }
    /**
     * Registers a custom option to a task. This custom option is then registered during onDefineParameters()
     * @param longName the long name of the option, e.g. "--verbose"
     * @param option the Custom Option definition
     */
    addCustomOption(longName, option) {
        if (this.customOptions.get(longName)) {
            throw new Error(`Cannot define two custom options with the same name: "${longName}"`);
        }
        this.customOptions.set(longName, {
            optionDefinition: option
        });
    }
    run() {
        if (!fsx.existsSync(this.rushConfiguration.rushLinkJsonFilename)) {
            throw new Error(`File not found: ${this.rushConfiguration.rushLinkJsonFilename}` +
                `${os.EOL}Did you run "rush link"?`);
        }
        this.eventHooksManager.handle(index_1.Event.preRushBuild);
        const stopwatch = Stopwatch_1.Stopwatch.start();
        const isQuietMode = !(this._verboseParameter.value);
        // if this is parallizable, then use the value from the flag (undefined or a number),
        // if this is not parallelized, then use 1 core
        const parallelism = this._isParallelized()
            ? this._parallelismParameter.value
            : 1;
        // collect all custom flags here
        const customFlags = [];
        this.customOptions.forEach((customOption, longName) => {
            if (customOption.parameterValue.value) {
                if (customOption.optionDefinition.optionType === 'flag') {
                    customFlags.push(longName);
                }
                else if (customOption.optionDefinition.optionType === 'enum') {
                    customFlags.push(`${longName} ${customOption.parameterValue.value}`);
                }
            }
        });
        const tasks = new TaskSelector_1.TaskSelector({
            rushConfiguration: this._parser.rushConfig,
            toFlags: this._toFlag.value,
            fromFlags: this._fromFlag.value,
            commandToRun: this.options.actionVerb,
            customFlags,
            isQuietMode,
            parallelism,
            isIncrementalBuildAllowed: this.options.actionVerb === 'build'
        });
        tasks.execute().then(() => {
            stopwatch.stop();
            console.log(colors.green(`rush ${this.options.actionVerb} (${stopwatch.toString()})`));
            this._collectTelemetry(stopwatch, true);
            this._parser.flushTelemetry();
            this.eventHooksManager.handle(index_1.Event.postRushBuild, this._parser.isDebug);
        }, () => {
            stopwatch.stop();
            console.log(colors.red(`rush ${this.options.actionVerb} - Errors! (${stopwatch.toString()})`));
            this._collectTelemetry(stopwatch, false);
            this._parser.flushTelemetry();
            this.eventHooksManager.handle(index_1.Event.postRushBuild, this._parser.isDebug);
            this._parser.exitWithError();
        });
    }
    onDefineParameters() {
        if (this._isParallelized()) {
            this._parallelismParameter = this.defineIntegerParameter({
                parameterLongName: '--parallelism',
                parameterShortName: '-p',
                key: 'COUNT',
                description: 'Specify the number of concurrent build processes.'
                    + ' If omitted, the parallelism will be based on the number of CPU cores.'
            });
        }
        this._toFlag = this.defineStringListParameter({
            parameterLongName: '--to',
            parameterShortName: '-t',
            key: 'PROJECT1',
            description: 'Run command in the specified project and all of its dependencies'
        });
        this._fromFlag = this.defineStringListParameter({
            parameterLongName: '--from',
            parameterShortName: '-f',
            key: 'PROJECT2',
            description: 'Run command in all projects that directly or indirectly depend on the specified project'
        });
        this._verboseParameter = this.defineFlagParameter({
            parameterLongName: '--verbose',
            parameterShortName: '-v',
            description: 'Display the logs during the build, rather than just displaying the build status summary'
        });
        // @TODO we should throw if they are trying to overwrite built in flags
        this.customOptions.forEach((customOption, longName) => {
            if (customOption.optionDefinition.optionType === 'flag') {
                customOption.parameterValue = this.defineFlagParameter({
                    parameterShortName: customOption.optionDefinition.shortName,
                    parameterLongName: longName,
                    description: customOption.optionDefinition.description
                });
            }
            else if (customOption.optionDefinition.optionType === 'enum') {
                customOption.parameterValue = this.defineOptionParameter({
                    parameterShortName: customOption.optionDefinition.shortName,
                    parameterLongName: longName,
                    description: customOption.optionDefinition.description,
                    defaultValue: customOption.optionDefinition.defaultValue,
                    options: customOption.optionDefinition.enumValues.map((enumValue) => {
                        return enumValue.name;
                    })
                });
            }
        });
    }
    _isParallelized() {
        return this.options.actionVerb === 'build'
            || this.options.actionVerb === 'rebuild'
            || this._parallelized;
    }
    _collectTelemetry(stopwatch, success) {
        const extraData = {
            command_to: (!!this._toFlag.value).toString(),
            command_from: (!!this._fromFlag.value).toString()
        };
        this.customOptions.forEach((customOption, longName) => {
            if (customOption.parameterValue.value) {
                extraData[`${this.options.actionVerb}_${longName}`] =
                    customOption.parameterValue.value.toString();
            }
        });
        if (this._parser.telemetry) {
            this._parser.telemetry.log({
                name: this.options.actionVerb,
                duration: stopwatch.duration,
                result: success ? 'Succeeded' : 'Failed',
                extraData
            });
        }
    }
}
exports.CustomRushAction = CustomRushAction;

//# sourceMappingURL=CustomRushAction.js.map
