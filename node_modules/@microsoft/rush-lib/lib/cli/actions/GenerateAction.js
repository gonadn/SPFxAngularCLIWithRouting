"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const colors = require("colors");
const os = require("os");
const fsx = require("fs-extra");
const Utilities_1 = require("../../utilities/Utilities");
const Stopwatch_1 = require("../../utilities/Stopwatch");
const InstallManager_1 = require("../utilities/InstallManager");
const LinkManager_1 = require("../utilities/LinkManager");
const ApprovedPackagesChecker_1 = require("../utilities/ApprovedPackagesChecker");
const ShrinkwrapFile_1 = require("../utilities/ShrinkwrapFile");
const BaseRushAction_1 = require("./BaseRushAction");
class GenerateAction extends BaseRushAction_1.BaseRushAction {
    constructor(parser) {
        super({
            actionVerb: 'generate',
            summary: 'Generate a new shrinkwrap file containing the latest semver-compatible versions.',
            documentation: 'Run the "rush generate" command only if: (1) you are setting up a new repo, or'
                + ' (2) you want to upgrade to the latest versions of your dependencies, or (3)'
                + ' you modified a package.json file and "rush install" can\'t find what it needs.'
                + ' The "rush generate" command will do a clean install of your Rush "common" folder,'
                + ' upgrading you to the latest semver-compatible versions of all dependencies.'
                + ' Then, it will create a new shrinkwrap file, which you should commit to source control.'
                + ' Afterwards, it will run "rush link" to create symlinks for all your projects.'
        });
        this._parser = parser;
    }
    onDefineParameters() {
        this._lazyParameter = this.defineFlagParameter({
            parameterLongName: '--lazy',
            parameterShortName: '-l',
            description: 'Use this to save time in situations where you need to run "rush generate" repeatedly'
                + ' while editing package.json files.  It performs a much quicker incremental install,'
                + ' but does not generate a shrinkwrap file; you will still need to run a full "rush generate"'
                + ' (without --lazy) before committing your changes.'
        });
        this._forceParameter = this.defineFlagParameter({
            parameterLongName: '--force',
            parameterShortName: '-f',
            description: 'Use this to bypass checking the shrinkwrap file, which forces rush generate to run even if all'
                + ' dependencies already exist in the shrinkwrap file'
        });
        this._noLinkParameter = this.defineFlagParameter({
            parameterLongName: '--no-link',
            description: 'Do not automatically run the "rush link" action after "rush generate"'
        });
    }
    run() {
        const stopwatch = Stopwatch_1.Stopwatch.start();
        const isLazy = this._lazyParameter.value;
        ApprovedPackagesChecker_1.ApprovedPackagesChecker.rewriteConfigFiles(this.rushConfiguration);
        const installManager = new InstallManager_1.default(this.rushConfiguration);
        try {
            const shrinkwrapFile = ShrinkwrapFile_1.default.loadFromFile(this.rushConfiguration.committedShrinkwrapFilename);
            if (shrinkwrapFile
                && !this._forceParameter.value
                && installManager.createTempModulesAndCheckShrinkwrap(shrinkwrapFile)) {
                console.log();
                console.log(colors.yellow('Skipping generate, since all project dependencies are already satisfied.'));
                console.log();
                console.log(`If you want to force an upgrade to the latest compatible versions, use ` +
                    `${colors.yellow('rush generate --force')}. Otherwise, just run ${colors.green('rush install')}.)`);
                return;
            }
        }
        catch (ex) {
            console.log();
            console.log('There was a problem reading the shrinkwrap file. Proceeeding with "rush generate".');
        }
        installManager.ensureLocalNpmTool(false);
        installManager.createTempModules();
        // Delete both copies of the shrinkwrap file
        if (fsx.existsSync(this.rushConfiguration.committedShrinkwrapFilename)) {
            console.log(os.EOL + 'Deleting ' + this.rushConfiguration.committedShrinkwrapFilename);
            fsx.unlinkSync(this.rushConfiguration.committedShrinkwrapFilename);
        }
        if (fsx.existsSync(this.rushConfiguration.tempShrinkwrapFilename)) {
            fsx.unlinkSync(this.rushConfiguration.tempShrinkwrapFilename);
        }
        if (isLazy) {
            console.log(colors.green(`${os.EOL}Rush is running in "--lazy" mode. ` +
                `You will need to run a normal "rush generate" before committing.`));
            // Do an incremental install
            installManager.installCommonModules(InstallManager_1.InstallType.Normal);
            console.log(os.EOL + colors.bold('(Skipping "npm shrinkwrap")') + os.EOL);
        }
        else {
            // Do a clean install
            installManager.installCommonModules(InstallManager_1.InstallType.ForceClean);
            console.log(os.EOL + colors.bold('Running "npm shrinkwrap"...'));
            const npmArgs = ['shrinkwrap'];
            installManager.pushConfigurationNpmArgs(npmArgs);
            Utilities_1.default.executeCommand(this.rushConfiguration.npmToolFilename, npmArgs, this.rushConfiguration.commonTempFolder);
            console.log('"npm shrinkwrap" completed' + os.EOL);
            // Copy (or delete) common\temp\npm-shrinkwrap.json --> common\npm-shrinkwrap.json
            installManager.syncFile(this.rushConfiguration.tempShrinkwrapFilename, this.rushConfiguration.committedShrinkwrapFilename);
            // The flag file is normally created by installCommonModules(), but "rush install" will
            // compare its timestamp against the shrinkwrap file.  Since we just generated a new
            // npm-shrinkwrap file, it's safe to bump the timestamp, which ensures that "rush install"
            // won't do anything immediately after "rush generate".  This is a minor performance
            // optimization, but it helps people to understand the semantics of the commands.
            if (fsx.existsSync(installManager.commonNodeModulesMarkerFilename)) {
                fsx.writeFileSync(installManager.commonNodeModulesMarkerFilename, '');
            }
            else {
                // Sanity check -- since we requested a clean install above, this should never occur
                throw new Error('The install flag file is missing');
            }
        }
        stopwatch.stop();
        console.log(os.EOL + colors.green(`Rush generate finished successfully. (${stopwatch.toString()})`));
        if (!this._noLinkParameter.value) {
            const linkManager = new LinkManager_1.default(this.rushConfiguration);
            // NOTE: Setting force=true here shouldn't be strictly necessary, since installCommonModules()
            // above should have already deleted the marker file, but it doesn't hurt to be explicit.
            this._parser.catchSyncErrors(linkManager.createSymlinksForProjects(true));
        }
        else {
            console.log(os.EOL + 'Next you should probably run: "rush link"');
        }
    }
}
exports.default = GenerateAction;

//# sourceMappingURL=GenerateAction.js.map
