"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const VersionPolicy_1 = require("../../data/VersionPolicy");
const RushConfiguration_1 = require("../../data/RushConfiguration");
const Utilities_1 = require("../../utilities/Utilities");
const VersionControl_1 = require("../../utilities/VersionControl");
const VersionMismatchFinder_1 = require("../../data/VersionMismatchFinder");
const GitPolicy_1 = require("../utilities/GitPolicy");
const BaseRushAction_1 = require("./BaseRushAction");
const VersionManager_1 = require("../utilities/VersionManager");
const Git_1 = require("../utilities/Git");
class VersionAction extends BaseRushAction_1.BaseRushAction {
    constructor(parser) {
        super({
            actionVerb: 'version',
            summary: '(EXPERIMENTAL) Manage package versions in the repo.',
            documentation: '(EXPERIMENTAL) use this "rush version" command to ensure version policies and bump versions.'
        });
        this._parser = parser;
    }
    onDefineParameters() {
        this._targetBranch = this.defineStringParameter({
            parameterLongName: '--target-branch',
            parameterShortName: '-b',
            key: 'BRANCH',
            description: 'If this flag is specified, changes will be committed and merged into the target branch.'
        });
        this._ensureVersionPolicy = this.defineFlagParameter({
            parameterLongName: '--ensure-version-policy',
            parameterShortName: '-e',
            description: 'Updates package versions if needed to satisfy version policies.'
        });
        this._bumpVersion = this.defineFlagParameter({
            parameterLongName: '--bump',
            description: 'Bumps package version based on version policies.'
        });
        this._bypassPolicy = this.defineFlagParameter({
            parameterLongName: '--bypass-policy',
            description: 'Overrides "gitPolicy" enforcement (use honorably!)'
        });
        this._versionPolicy = this.defineStringParameter({
            parameterLongName: '--version-policy',
            parameterShortName: '-p',
            description: 'The name of the version policy'
        });
        this._overwriteBump = this.defineStringParameter({
            parameterLongName: '--override-bump',
            description: 'Overrides the bump type in the version-policy.json for the specified version policy.' +
                'Valid values include: prerelease, patch, preminor, minor, major. ' +
                'This setting only works for lock-step version policy in bump action.'
        });
        this._prereleaseIdentifier = this.defineStringParameter({
            parameterLongName: '--override-prerelease-id',
            description: 'Overrides the prerelease identifier in the version value of version-policy.json ' +
                'for the specified version policy. ' +
                'This setting only works for lock-step version policy in bump action.'
        });
    }
    run() {
        if (!this._bypassPolicy.value) {
            if (!GitPolicy_1.default.check(this.rushConfiguration)) {
                process.exit(1);
                return;
            }
        }
        this._validateInput();
        this._versionManager = new VersionManager_1.VersionManager(this.rushConfiguration, this._getUserEmail());
        if (this._ensureVersionPolicy.value) {
            const tempBranch = 'version/ensure-' + new Date().getTime();
            this._versionManager.ensure(this._versionPolicy.value, true);
            const updatedPackages = this._versionManager.updatedProjects;
            if (updatedPackages.size > 0) {
                console.log(`${updatedPackages.size} packages are getting updated.`);
                this._gitProcess(tempBranch);
            }
        }
        else if (this._bumpVersion.value) {
            const tempBranch = 'version/bump-' + new Date().getTime();
            this._versionManager.bump(this._versionPolicy.value, VersionPolicy_1.BumpType[this._overwriteBump.value], this._prereleaseIdentifier.value, true);
            this._gitProcess(tempBranch);
        }
    }
    _validateInput() {
        if (this._bumpVersion.value && this._ensureVersionPolicy.value) {
            throw new Error('Please choose --bump or --ensure-version-policy but not together.');
        }
        if (this._overwriteBump.value && !VersionPolicy_1.BumpType[this._overwriteBump.value]) {
            throw new Error('The value of override-bump is not valid.  ' +
                'Valid values include prerelease, patch, preminor, minor, and major');
        }
    }
    _validateResult() {
        // Load the config from file to avoid using inconsistent in-memory data.
        const rushConfig = RushConfiguration_1.default.loadFromConfigurationFile(this.rushConfiguration.rushJsonFile);
        const mismatchFinder = new VersionMismatchFinder_1.VersionMismatchFinder(rushConfig.projects);
        if (mismatchFinder.numberOfMismatches) {
            throw new Error('Unable to finish version bump because inconsistencies were encountered.' +
                ' Run \"rush check\" to find more details.');
        }
    }
    _getUserEmail() {
        return Utilities_1.default.executeCommandAndCaptureOutput('git', ['config', 'user.email'], '.').trim();
    }
    _gitProcess(tempBranch) {
        // Validate the result before commit.
        this._validateResult();
        const git = new Git_1.Git(this._targetBranch.value);
        // Make changes in temp branch.
        git.checkout(tempBranch, true);
        // Stage, commit, and push the changes to remote temp branch.
        // Need to commit the change log updates in its own commit
        const changeLogUpdated = VersionControl_1.default.getUncommittedChanges().some((changePath) => {
            return changePath.indexOf('CHANGELOG.json') > 0;
        });
        if (changeLogUpdated) {
            git.addChanges('.', this.rushConfiguration.changesFolder);
            git.addChanges('**/CHANGELOG.json');
            git.addChanges('**/CHANGELOG.md');
            git.commit('Deleting change files and updating change logs for package updates.');
        }
        // Commit the package.json and change files updates.
        git.addChanges();
        git.commit();
        git.push(tempBranch);
        // Now merge to target branch.
        git.checkout(this._targetBranch.value);
        git.pull();
        git.merge(tempBranch);
        git.push(this._targetBranch.value);
        git.deleteBranch(tempBranch);
    }
}
exports.default = VersionAction;

//# sourceMappingURL=VersionAction.js.map
