"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const colors = require("colors");
const os_1 = require("os");
const ChangeManagement_1 = require("../../data/ChangeManagement");
const Npm_1 = require("../../utilities/Npm");
const PublishUtilities_1 = require("../utilities/PublishUtilities");
const ChangelogGenerator_1 = require("../utilities/ChangelogGenerator");
const GitPolicy_1 = require("../utilities/GitPolicy");
const PrereleaseToken_1 = require("../utilities/PrereleaseToken");
const ChangeManager_1 = require("../utilities/ChangeManager");
const BaseRushAction_1 = require("./BaseRushAction");
const Git_1 = require("../utilities/Git");
class PublishAction extends BaseRushAction_1.BaseRushAction {
    constructor(parser) {
        super({
            actionVerb: 'publish',
            summary: 'Reads and processes package publishing change requests generated by "rush change".',
            documentation: 'Reads and processes package publishing change requests generated by "rush change". This will perform a ' +
                'read-only operation by default, printing operations executed to the console. To commit ' +
                'changes and publish packages, you must use the --commit flag and/or the --publish flag.'
        });
        this._parser = parser;
    }
    onDefineParameters() {
        this._apply = this.defineFlagParameter({
            parameterLongName: '--apply',
            parameterShortName: '-a',
            description: 'If this flag is specified, the change requests will be applied to package.json files.'
        });
        this._targetBranch = this.defineStringParameter({
            parameterLongName: '--target-branch',
            parameterShortName: '-b',
            key: 'BRANCH',
            description: 'If this flag is specified, applied changes and deleted change requests will be' +
                'committed and merged into the target branch.'
        });
        this._publish = this.defineFlagParameter({
            parameterLongName: '--publish',
            parameterShortName: '-p',
            description: 'If this flag is specified, applied changes will be published to npm.'
        });
        this._addCommitDetails = this.defineFlagParameter({
            parameterLongName: '--add-commit-details',
            parameterShortName: undefined,
            description: 'Adds commit author and hash to the changelog.json files for each change.'
        });
        this._regenerateChangelogs = this.defineFlagParameter({
            parameterLongName: '--regenerate-changelogs',
            parameterShortName: undefined,
            description: 'Regenerates all changelog files based on the current JSON content.'
        });
        this._registryUrl = this.defineStringParameter({
            parameterLongName: '--registry',
            parameterShortName: '-r',
            key: 'REGISTRY',
            description: `Publishes to a specified NPM registry. If this is specified, it will prevent the current commit will not be ` +
                'tagged.'
        });
        this._npmAuthToken = this.defineStringParameter({
            parameterLongName: '--npm-auth-token',
            parameterShortName: '-n',
            key: 'TOKEN',
            description: 'Provide the default scope npm auth token to be passed into npm publish for global package publishing.'
        });
        this._npmTag = this.defineStringParameter({
            parameterLongName: '--tag',
            parameterShortName: '-t',
            key: 'TAG',
            description: `The tag option to pass to npm publish. By default npm will publish using the 'latest' tag, even if ` +
                `the package is older than the current latest, so in publishing workflows for older releases, providing ` +
                `a tag is important.`
        });
        this._includeAll = this.defineFlagParameter({
            parameterLongName: '--include-all',
            parameterShortName: undefined,
            description: 'If this flag is specified, all packages with shouldPublish=true in rush.json ' +
                'or with a specified version policy ' +
                'will be published if their version is newer than published version.'
        });
        this._versionPolicy = this.defineStringParameter({
            parameterLongName: '--version-policy',
            parameterShortName: '-vp',
            key: 'VERSIONPOLICY',
            description: 'Version policy name. Only projects with this version policy will be published if used ' +
                'with --include-all.'
        });
        this._prereleaseName = this.defineStringParameter({
            parameterLongName: '--prerelease-name',
            parameterShortName: '-pn',
            key: 'NAME',
            description: 'Bump up to a prerelease version with the provided prerelease name. Cannot be used with --suffix'
        });
        this._suffix = this.defineStringParameter({
            parameterLongName: '--suffix',
            key: 'SUFFIX',
            description: 'Append a suffix to all changed versions. Cannot be used with --prerelease-name.'
        });
        this._force = this.defineFlagParameter({
            parameterLongName: '--force',
            parameterShortName: undefined,
            description: 'If this flag is specified with --publish, packages will be published with --force on npm'
        });
    }
    /**
     * Executes the publish action, which will read change request files, apply changes to package.jsons,
     */
    run() {
        if (!GitPolicy_1.default.check(this.rushConfiguration)) {
            process.exit(1);
            return;
        }
        const allPackages = this.rushConfiguration.projectsByName;
        if (this._regenerateChangelogs.value) {
            console.log('Regenerating changelogs');
            ChangelogGenerator_1.default.regenerateChangelogs(allPackages);
            return;
        }
        if (this._includeAll.value) {
            this._publishAll(allPackages);
        }
        else {
            this._prereleaseToken = new PrereleaseToken_1.default(this._prereleaseName.value, this._suffix.value);
            this._publishChanges(allPackages);
        }
        console.log(os_1.EOL + colors.green('Rush publish finished successfully.'));
    }
    _publishChanges(allPackages) {
        const changeManager = new ChangeManager_1.default(this.rushConfiguration);
        changeManager.load(this.rushConfiguration.changesFolder, this._prereleaseToken, this._addCommitDetails.value);
        if (changeManager.hasChanges()) {
            const orderedChanges = changeManager.changes;
            const git = new Git_1.Git(this._targetBranch.value);
            const tempBranch = 'publish-' + new Date().getTime();
            // Make changes in temp branch.
            git.checkout(tempBranch, true);
            // Make changes to package.json and change logs.
            changeManager.apply(this._apply.value);
            changeManager.updateChangelog(this._apply.value);
            // Stage, commit, and push the changes to remote temp branch.
            git.addChanges();
            git.commit();
            git.push(tempBranch);
            // NPM publish the things that need publishing.
            for (const change of orderedChanges) {
                if (change.changeType && change.changeType > ChangeManagement_1.ChangeType.dependency) {
                    const project = allPackages.get(change.packageName);
                    if (project) {
                        this._npmPublish(change.packageName, project.projectFolder);
                    }
                }
            }
            // Create and push appropriate git tags.
            this._gitAddTags(git, orderedChanges);
            git.push(tempBranch);
            // Now merge to target branch.
            git.checkout(this._targetBranch.value);
            git.pull();
            git.merge(tempBranch);
            git.push(this._targetBranch.value);
            git.deleteBranch(tempBranch);
        }
    }
    _publishAll(allPackages) {
        console.log(`Rush publish starts with includeAll and version policy ${this._versionPolicy.value}`);
        let updated = false;
        const git = new Git_1.Git(this._targetBranch.value);
        allPackages.forEach((packageConfig, packageName) => {
            if (packageConfig.shouldPublish &&
                (!this._versionPolicy.value || this._versionPolicy.value === packageConfig.versionPolicyName)) {
                if (this._force.value || !this._packageExists(packageConfig)) {
                    this._npmPublish(packageName, packageConfig.projectFolder);
                    git.addTag(!!this._publish.value && !this._registryUrl.value, packageName, packageConfig.packageJson.version);
                    updated = true;
                }
                else {
                    console.log(`Skip ${packageName}. Not updated.`);
                }
            }
        });
        if (updated) {
            git.push(this._targetBranch.value);
        }
    }
    _gitAddTags(git, orderedChanges) {
        for (const change of orderedChanges) {
            if (change.changeType &&
                change.changeType > ChangeManagement_1.ChangeType.dependency &&
                this.rushConfiguration.projectsByName.get(change.packageName).shouldPublish) {
                git.addTag(!!this._publish.value && !this._registryUrl.value, change.packageName, change.newVersion);
            }
        }
    }
    _npmPublish(packageName, packagePath) {
        const env = PublishUtilities_1.default.getEnvArgs();
        const args = ['publish'];
        if (this.rushConfiguration.projectsByName.get(packageName).shouldPublish) {
            let registry = '//registry.npmjs.org/';
            if (this._registryUrl.value) {
                const registryUrl = this._registryUrl.value;
                env['npm_config_registry'] = registryUrl; // tslint:disable-line:no-string-literal
                registry = registryUrl.substring(registryUrl.indexOf('//'));
            }
            if (this._npmAuthToken.value) {
                args.push(`--${registry}:_authToken=${this._npmAuthToken.value}`);
            }
            if (this._npmTag.value) {
                args.push(`--tag`, this._npmTag.value);
            }
            if (this._force.value) {
                args.push(`--force`);
            }
            PublishUtilities_1.default.execCommand(!!this._publish.value, this.rushConfiguration.npmToolFilename, args, packagePath, env);
        }
    }
    _packageExists(packageConfig) {
        const env = PublishUtilities_1.default.getEnvArgs();
        if (this._registryUrl.value) {
            env['npm_config_registry'] = this._registryUrl.value; // tslint:disable-line:no-string-literal
        }
        const publishedVersions = Npm_1.default.publishedVersions(packageConfig.packageName, packageConfig.projectFolder, env);
        return publishedVersions.indexOf(packageConfig.packageJson.version) >= 0;
    }
}
exports.default = PublishAction;

//# sourceMappingURL=PublishAction.js.map
