"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const fsx = require("fs-extra");
const os = require("os");
const path = require("path");
const child_process = require("child_process");
const colors = require("colors");
const inquirer = require("inquirer");
const VersionControl_1 = require("../../utilities/VersionControl");
const ChangeFile_1 = require("../../data/ChangeFile");
const BaseRushAction_1 = require("./BaseRushAction");
const ChangeFiles_1 = require("../utilities/ChangeFiles");
const VersionPolicy_1 = require("../../data/VersionPolicy");
class ChangeAction extends BaseRushAction_1.BaseRushAction {
    constructor(parser) {
        super({
            actionVerb: 'change',
            summary: 'Records changes made to projects, indicating how the package version number should be bumped ' +
                'for the next publish.',
            documentation: ['Asks a series of questions and then generates a <branchname>-<timstamp>.json file ' +
                    'in the common folder. The `publish` command will consume these files and perform the proper ' +
                    'version bumps. Note these changes will eventually be published in a changelog.md file in each package.',
                '',
                'The possible types of changes are: ',
                '',
                'MAJOR - these are breaking changes that are not backwards compatible. ' +
                    'Examples are: renaming a public class, adding/removing a non-optional ' +
                    'parameter from a public API, or renaming an variable or function that ' +
                    'is exported.',
                '',
                'MINOR - these are changes that are backwards compatible (but not ' +
                    'forwards compatible). Examples are: adding a new public API or adding an ' +
                    'optional parameter to a public API',
                '',
                'PATCH - these are changes that are backwards and forwards compatible. ' +
                    'Examples are: Modifying a private API or fixing a bug in the logic ' +
                    'of how an existing API works.',
                ''].join(os.EOL)
        });
        this._parser = parser;
    }
    onDefineParameters() {
        this._verifyParameter = this.defineFlagParameter({
            parameterLongName: '--verify',
            parameterShortName: '-v',
            description: 'Verify the change file has been generated and that it is a valid JSON file'
        });
        this._targetBranchParameter = this.defineStringParameter({
            parameterLongName: '--target-branch',
            parameterShortName: '-b',
            key: 'BRANCH',
            description: 'If this parameter is specified, compare current branch with the target branch to get changes. ' +
                'If this parameter is not specified, the current branch is compared against the "master" branch.'
        });
    }
    run() {
        console.log(`Target branch is ${this._targetBranch}`);
        if (this._verifyParameter.value) {
            return this._verify();
        }
        this._sortedProjectList = this._getChangedPackageNames()
            .sort();
        if (this._sortedProjectList.length === 0) {
            console.log('No change file is needed.');
            this._warnUncommittedChanges();
            return;
        }
        this._prompt = inquirer.createPromptModule();
        this._changeFileData = new Map();
        this._changeComments = ChangeFiles_1.default.getChangeComments(this._getChangeFiles(), this._sortedProjectList);
        // We should consider making onExecute either be an async/await or have it return a promise
        this._promptLoop()
            .catch((error) => {
            console.error('There was an error creating the changefile:' + os.EOL + error.toString());
        });
    }
    _verify() {
        const changedPackages = this._getChangedPackageNames();
        if (changedPackages.length > 0) {
            this._validateChangeFile(changedPackages);
        }
        else {
            console.log('No change is needed.');
        }
    }
    get _targetBranch() {
        if (!this._targetBranchName) {
            this._targetBranchName = this._targetBranchParameter.value ||
                VersionControl_1.default.getRemoteMasterBranch(this.rushConfiguration.repositoryUrl);
        }
        return this._targetBranchName;
    }
    _getChangedPackageNames() {
        const changedFolders = VersionControl_1.default.getChangedFolders(this._targetBranch);
        if (!changedFolders) {
            return [];
        }
        return this.rushConfiguration.projects
            .filter(project => project.shouldPublish)
            .filter(project => this._hasProjectChanged(changedFolders, project))
            .map(project => project.packageName);
    }
    _validateChangeFile(changedPackages) {
        const files = this._getChangeFiles();
        if (files.length === 0) {
            throw new Error(`No change file is found. Run 'rush change' to generate a change file.`);
        }
        ChangeFiles_1.default.validate(files, changedPackages);
    }
    _getChangeFiles() {
        return VersionControl_1.default.getChangedFiles(`common/changes/`, this._targetBranch).map(relativePath => {
            return path.join(this.rushConfiguration.rushJsonFolder, relativePath);
        });
    }
    _hasProjectChanged(changedFolders, project) {
        let normalizedFolder = project.projectRelativeFolder;
        if (normalizedFolder.charAt(normalizedFolder.length - 1) !== '/') {
            normalizedFolder = normalizedFolder + '/';
        }
        const pathRegex = new RegExp(`^${normalizedFolder}`, 'i');
        for (const folder of changedFolders) {
            if (folder && folder.match(pathRegex)) {
                return true;
            }
        }
        return false;
    }
    /**
     * The main loop which continually asks user for questions about changes until they don't
     * have any more, at which point we collect their email and write the change file.
     */
    _promptLoop() {
        // If there are still projects, ask about the next one
        if (this._sortedProjectList.length) {
            return this._askQuestions(this._sortedProjectList.pop())
                .then((answers) => {
                if (answers) {
                    // Save the info into the changefile
                    let changeFile = this._changeFileData.get(answers.packageName);
                    if (!changeFile) {
                        changeFile = {
                            changes: [],
                            packageName: answers.packageName,
                            email: undefined
                        };
                        this._changeFileData.set(answers.packageName, changeFile);
                    }
                    changeFile.changes.push(answers);
                }
                // Continue to loop
                return this._promptLoop();
            });
        }
        else {
            this._warnUncommittedChanges();
            // We are done, collect their e-mail
            return this._detectOrAskForEmail().then((email) => {
                this._changeFileData.forEach((changeFile) => {
                    changeFile.email = email;
                });
                return this._writeChangeFiles();
            });
        }
    }
    /**
     * Asks all questions which are needed to generate changelist for a project.
     */
    _askQuestions(packageName) {
        console.log(`${os.EOL}${packageName}`);
        const comments = this._changeComments.get(packageName);
        if (comments && comments.length) {
            console.log(`Found existing comments:`);
            comments.forEach(comment => {
                console.log(`    > ${comment}`);
            });
            return this._prompt({
                name: 'appendComment',
                type: 'list',
                default: 'skip',
                message: 'Append to existing comments or skip?',
                choices: [
                    {
                        'name': 'Skip',
                        'value': 'skip'
                    },
                    {
                        'name': 'Append',
                        'value': 'append'
                    }
                ]
            })
                .then(({ appendComment }) => {
                if (appendComment === 'skip') {
                    return undefined;
                }
                else {
                    return this._promptForComments(packageName);
                }
            });
        }
        else {
            return this._promptForComments(packageName);
        }
    }
    _promptForComments(packageName) {
        const bumpOptions = this._getBumpOptions(packageName);
        return this._prompt({
            name: 'comment',
            type: 'input',
            message: `Describe changes, or ENTER if no changes:`
        })
            .then(({ comment }) => {
            if (Object.keys(bumpOptions).length === 0 || !comment) {
                return {
                    comment: comment || '',
                    packageName: packageName,
                    type: 'none'
                };
            }
            else {
                return this._prompt({
                    choices: Object.keys(bumpOptions).map(option => {
                        return {
                            'value': option,
                            'name': bumpOptions[option]
                        };
                    }),
                    default: 'patch',
                    message: 'Select the type of change:',
                    name: 'bumpType',
                    type: 'list'
                }).then(({ bumpType }) => {
                    return {
                        packageName: packageName,
                        comment: comment,
                        type: bumpType
                    };
                });
            }
        });
    }
    _getBumpOptions(packageName) {
        const project = this.rushConfiguration.getProjectByName(packageName);
        const versionPolicy = project.versionPolicy;
        let bumpOptions = {
            'major': 'major - for changes that break compatibility, e.g. removing an API',
            'minor': 'minor - for backwards compatible changes, e.g. adding a new API',
            'patch': 'patch - for changes that do not affect compatibility, e.g. fixing a bug'
        };
        if (versionPolicy) {
            if (versionPolicy.definitionName === VersionPolicy_1.VersionPolicyDefinitionName.lockStepVersion) {
                // No need to ask for bump types if project is lockstep versioned.
                bumpOptions = {};
            }
            else if (versionPolicy.definitionName === VersionPolicy_1.VersionPolicyDefinitionName.individualVersion) {
                const individualPolicy = versionPolicy;
                if (individualPolicy.lockedMajor !== undefined) {
                    // tslint:disable-next-line:no-string-literal
                    delete bumpOptions['major'];
                }
            }
        }
        return bumpOptions;
    }
    /**
     * Will determine a user's email by first detecting it from their git config,
     * or will ask for it if it is not found or the git config is wrong.
     */
    _detectOrAskForEmail() {
        return this._detectAndConfirmEmail().then((email) => {
            if (email) {
                return Promise.resolve(email);
            }
            else {
                return this._promptForEmail();
            }
        });
    }
    /**
     * Detects the user's email address from their git configuration, prompts the user to approve the
     * detected email. It returns undefined if it cannot be detected.
     */
    _detectAndConfirmEmail() {
        let email;
        try {
            email = child_process.execSync('git config user.email')
                .toString()
                .replace(/(\r\n|\n|\r)/gm, '');
        }
        catch (err) {
            console.log('There was an issue detecting your git email...');
            email = undefined;
        }
        if (email) {
            return this._prompt([
                {
                    type: 'confirm',
                    name: 'isCorrectEmail',
                    default: 'Y',
                    message: `Is your email address ${email} ?`
                }
            ]).then(({ isCorrectEmail }) => {
                return isCorrectEmail ? email : undefined;
            });
        }
        else {
            return Promise.resolve(undefined);
        }
    }
    /**
     * Asks the user for their e-mail address
     */
    _promptForEmail() {
        return this._prompt([
            {
                type: 'input',
                name: 'email',
                message: 'What is your email address?',
                validate: (input) => {
                    return true; // @todo should be an email
                }
            }
        ])
            .then((answers) => {
            return answers.email;
        });
    }
    _warnUncommittedChanges() {
        try {
            if (VersionControl_1.default.hasUncommittedChanges()) {
                console.log(os.EOL +
                    colors.yellow('Warning: You have uncommitted changes, which do not trigger a change entry.'));
            }
        }
        catch (error) {
            console.log('Ignore the failure of checking uncommitted changes');
        }
    }
    /**
     * Writes changefile to the common/changes folder. Will prompt for overwrite if file already exists.
     */
    _writeChangeFiles() {
        const promises = [];
        this._changeFileData.forEach((changeFile) => {
            promises.push(this._writeChangeFile(changeFile));
        });
        return new Promise((resolve, reject) => {
            Promise.all(promises).then(() => {
                resolve();
            })
                .catch(e => {
                reject(e);
            });
        });
    }
    _writeChangeFile(changeFileData) {
        const output = JSON.stringify(changeFileData, undefined, 2);
        const changeFile = new ChangeFile_1.ChangeFile(changeFileData, this.rushConfiguration);
        const filePath = changeFile.generatePath();
        if (fsx.existsSync(filePath)) {
            // prompt about overwrite
            this._prompt([
                {
                    name: 'overwrite',
                    type: 'confirm',
                    message: `Overwrite ${filePath} ?`
                }
            ]).then(({ overwrite }) => {
                if (overwrite) {
                    return this._writeFile(filePath, output);
                }
                else {
                    console.log(`Not overwriting ${filePath}...`);
                    return Promise.resolve();
                }
            });
        }
        return this._writeFile(filePath, output);
    }
    /**
     * Writes a file to disk, ensuring the directory structure up to that point exists
     */
    _writeFile(fileName, output) {
        return new Promise((resolve, reject) => {
            // tslint:disable-next-line:no-any
            fsx.mkdirs(path.dirname(fileName), (err) => {
                if (err) {
                    reject(err);
                }
                fsx.writeFile(fileName, output, (error) => {
                    if (error) {
                        reject(error);
                    }
                    else {
                        console.log('Created file: ' + fileName);
                        resolve();
                    }
                });
            });
        });
    }
}
exports.default = ChangeAction;

//# sourceMappingURL=ChangeAction.js.map
