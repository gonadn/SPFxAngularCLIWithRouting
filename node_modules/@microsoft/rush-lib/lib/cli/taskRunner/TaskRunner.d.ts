import { ITaskDefinition } from './ITask';
/**
 * A class which manages the execution of a set of tasks with interdependencies.
 * Any class of task definition may be registered, and dependencies between tasks are
 * easily specified. Initially, and at the end of each task execution, all unblocked tasks
 * are added to a ready queue which is then executed. This is done continually until all
 * tasks are complete, or prematurely fails if any of the tasks fail. Note that all task
 * definitions must
 * @todo #168352: add unit tests
 */
export default class TaskRunner {
    private _tasks;
    private _buildQueue;
    private _quietMode;
    private _hasAnyFailures;
    private _parallelism;
    private _currentActiveTasks;
    constructor(quietMode: boolean, parallelism: number | undefined);
    /**
     * Registers a task definition to the map of defined tasks
     */
    addTask(taskDefinition: ITaskDefinition): void;
    /**
     * Returns true if a task with that name has been registered
     */
    hasTask(taskName: string): boolean;
    /**
     * Defines the list of dependencies for an individual task.
     * @param taskName - the string name of the task for which we are defining dependencies. A task with this
     * name must already have been registered.
     * @taskDependencies
     */
    addDependencies(taskName: string, taskDependencies: string[]): void;
    /**
     * Executes all tasks which have been registered, returning a promise which is resolved when all the
     * tasks are completed successfully, or rejects when any task fails.
     */
    execute(): Promise<void>;
    /**
     * Pulls the next task with no dependencies off the build queue
     * Removes any non-ready tasks from the build queue (this should only be blocked tasks)
     */
    private _getNextTask();
    /**
     * Helper function which finds any tasks which are available to run and begins executing them.
     * It calls the complete callback when all tasks are completed, or rejects if any task fails.
     */
    private _startAvailableTasks(complete, reject);
    /**
     * Marks a task as having failed and marks each of its dependents as blocked
     */
    private _markTaskAsFailed(task);
    /**
     * Marks a task and all its dependents as blocked
     */
    private _markTaskAsBlocked(task, failedTask);
    /**
     * Marks a task as being completed, and removes it from the dependencies list of all its dependents
     */
    private _markTaskAsSuccess(task);
    /**
     * Marks a task as being completed, but with warnings written to stderr, and removes it from the dependencies
     * list of all its dependents
     */
    private _markTaskAsSuccessWithWarning(task);
    /**
     * Marks a task as skipped.
     */
    private _markTaskAsSkipped(task);
    /**
     * Do any Ready or Executing tasks exist?
     */
    private _areAnyTasksReadyOrExecuting();
    /**
     * Checks for projects that indirectly depend on themselves.
     */
    private _checkForCyclicDependencies(tasks, dependencyChain);
    /**
     * Calculate the number of packages which must be built before we reach
     * the furthest away "root" node
     */
    private _calculateCriticalPaths(task);
    /**
     * Prints out a report of the status of each project
     */
    private _printTaskStatus();
    private _printStatus(status, tasks, color);
}
