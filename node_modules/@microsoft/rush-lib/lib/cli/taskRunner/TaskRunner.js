"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const colors = require("colors");
const os = require("os");
const stream_collator_1 = require("@microsoft/stream-collator");
const Stopwatch_1 = require("../../utilities/Stopwatch");
const TaskStatus_1 = require("./TaskStatus");
/**
 * A class which manages the execution of a set of tasks with interdependencies.
 * Any class of task definition may be registered, and dependencies between tasks are
 * easily specified. Initially, and at the end of each task execution, all unblocked tasks
 * are added to a ready queue which is then executed. This is done continually until all
 * tasks are complete, or prematurely fails if any of the tasks fail. Note that all task
 * definitions must
 * @todo #168352: add unit tests
 */
class TaskRunner {
    constructor(quietMode, parallelism) {
        this._tasks = new Map();
        this._buildQueue = [];
        this._quietMode = quietMode;
        this._hasAnyFailures = false;
        if (parallelism) {
            this._parallelism = parallelism;
        }
        else {
            // If an explicit parallelism number wasn't provided, then choose a sensible
            // default.
            const numberOfCores = os.cpus().length;
            if (os.platform() === 'win32') {
                // On desktop Windows, some people have complained that their system becomes
                // sluggish if Rush is using all the CPU cores.  Leave one thread for
                // other operations.
                this._parallelism = Math.max(numberOfCores - 1, 1);
            }
            else {
                // Unix-like operating systems have more balanced scheduling, so default
                // to the number of CPU cores
                this._parallelism = numberOfCores;
            }
        }
    }
    /**
     * Registers a task definition to the map of defined tasks
     */
    addTask(taskDefinition) {
        if (this._tasks.has(taskDefinition.name)) {
            throw new Error('A task with that name has already been registered.');
        }
        const task = taskDefinition;
        task.dependencies = new Set();
        task.dependents = new Set();
        task.errors = new Set();
        task.status = TaskStatus_1.default.Ready;
        task.criticalPathLength = undefined;
        this._tasks.set(task.name, task);
        if (!this._quietMode) {
            console.log(`Registered ${task.name}`);
        }
    }
    /**
     * Returns true if a task with that name has been registered
     */
    hasTask(taskName) {
        return this._tasks.has(taskName);
    }
    /**
     * Defines the list of dependencies for an individual task.
     * @param taskName - the string name of the task for which we are defining dependencies. A task with this
     * name must already have been registered.
     * @taskDependencies
     */
    addDependencies(taskName, taskDependencies) {
        const task = this._tasks.get(taskName);
        if (!task) {
            throw new Error(`The task '${taskName}' has not been registered`);
        }
        if (!taskDependencies) {
            throw new Error('The list of dependencies must be defined');
        }
        for (const dependencyName of taskDependencies) {
            if (!this._tasks.has(dependencyName)) {
                throw new Error(`The project '${dependencyName}' has not been registered.`);
            }
            const dependency = this._tasks.get(dependencyName);
            task.dependencies.add(dependency);
            dependency.dependents.add(task);
        }
    }
    /**
     * Executes all tasks which have been registered, returning a promise which is resolved when all the
     * tasks are completed successfully, or rejects when any task fails.
     */
    execute() {
        this._currentActiveTasks = 0;
        console.log(`Executing a maximum of ${this._parallelism} simultaneous processes...${os.EOL}`);
        this._checkForCyclicDependencies(this._tasks.values(), []);
        // Precalculate the number of dependent packages
        this._tasks.forEach((task) => {
            this._calculateCriticalPaths(task);
        });
        // Add everything to the buildQueue
        this._tasks.forEach((task) => {
            this._buildQueue.push(task);
        });
        // Sort the queue in descending order, nothing will mess with the order
        this._buildQueue.sort((taskA, taskB) => {
            return taskB.criticalPathLength - taskA.criticalPathLength;
        });
        return new Promise((complete, reject) => {
            this._startAvailableTasks(complete, reject);
        });
    }
    /**
     * Pulls the next task with no dependencies off the build queue
     * Removes any non-ready tasks from the build queue (this should only be blocked tasks)
     */
    _getNextTask() {
        for (let i = 0; i < this._buildQueue.length; i++) {
            const task = this._buildQueue[i];
            if (task.status !== TaskStatus_1.default.Ready) {
                // It shouldn't be on the queue, remove it
                this._buildQueue.splice(i, 1);
                // Decrement since we modified the array
                i--;
            }
            else if (task.dependencies.size === 0 && task.status === TaskStatus_1.default.Ready) {
                // this is a task which is ready to go. remove it and return it
                return this._buildQueue.splice(i, 1)[0];
            }
            // Otherwise task is still waiting
        }
        return undefined; // There are no tasks ready to go at this time
    }
    /**
     * Helper function which finds any tasks which are available to run and begins executing them.
     * It calls the complete callback when all tasks are completed, or rejects if any task fails.
     */
    _startAvailableTasks(complete, reject) {
        if (!this._areAnyTasksReadyOrExecuting()) {
            this._printTaskStatus();
            if (this._hasAnyFailures) {
                reject();
            }
            else {
                complete();
            }
        }
        let ctask;
        while (this._currentActiveTasks < this._parallelism && (ctask = this._getNextTask())) {
            this._currentActiveTasks++;
            const task = ctask;
            task.status = TaskStatus_1.default.Executing;
            console.log(colors.white(`> Starting task [${task.name}]`));
            task.stopwatch = Stopwatch_1.Stopwatch.start();
            task.writer = stream_collator_1.Interleaver.registerTask(task.name, this._quietMode);
            task.execute(task.writer)
                .then((result) => {
                task.stopwatch.stop();
                task.writer.close();
                this._currentActiveTasks--;
                switch (result) {
                    case TaskStatus_1.default.Success:
                        this._markTaskAsSuccess(task);
                        break;
                    case TaskStatus_1.default.SuccessWithWarning:
                        this._markTaskAsSuccessWithWarning(task);
                        break;
                    case TaskStatus_1.default.Skipped:
                        this._markTaskAsSkipped(task);
                        break;
                    case TaskStatus_1.default.Failure:
                        this._hasAnyFailures = true;
                        this._markTaskAsFailed(task);
                        break;
                }
                this._startAvailableTasks(complete, reject);
            }).catch((errors) => {
                task.writer.close();
                this._currentActiveTasks--;
                this._hasAnyFailures = true;
                task.errors = new Set(errors);
                this._markTaskAsFailed(task);
                this._startAvailableTasks(complete, reject);
            });
        }
    }
    /**
     * Marks a task as having failed and marks each of its dependents as blocked
     */
    _markTaskAsFailed(task) {
        console.log(colors.red(`${os.EOL}> Completed task [${task.name}] with errors!`));
        task.status = TaskStatus_1.default.Failure;
        task.dependents.forEach((dependent) => {
            this._markTaskAsBlocked(dependent, task);
        });
    }
    /**
     * Marks a task and all its dependents as blocked
     */
    _markTaskAsBlocked(task, failedTask) {
        if (task.status === TaskStatus_1.default.Ready) {
            console.log(colors.red(`> [${task.name}] blocked by [${failedTask.name}]!`));
            task.status = TaskStatus_1.default.Blocked;
            task.dependents.forEach((dependent) => {
                this._markTaskAsBlocked(dependent, failedTask);
            });
        }
    }
    /**
     * Marks a task as being completed, and removes it from the dependencies list of all its dependents
     */
    _markTaskAsSuccess(task) {
        console.log(colors.green(`> Completed task [${task.name}] in ${task.stopwatch.toString()}`));
        task.status = TaskStatus_1.default.Success;
        task.dependents.forEach((dependent) => {
            dependent.isIncrementalBuildAllowed = false;
            dependent.dependencies.delete(task);
        });
    }
    /**
     * Marks a task as being completed, but with warnings written to stderr, and removes it from the dependencies
     * list of all its dependents
     */
    _markTaskAsSuccessWithWarning(task) {
        console.log(colors.yellow(`> Completed task [${task.name}] with warnings in ${task.stopwatch.toString()}`));
        task.status = TaskStatus_1.default.SuccessWithWarning;
        task.dependents.forEach((dependent) => {
            dependent.isIncrementalBuildAllowed = false;
            dependent.dependencies.delete(task);
        });
    }
    /**
     * Marks a task as skipped.
     */
    _markTaskAsSkipped(task) {
        console.log(colors.green(`> Skipped task [${task.name}] in ${task.stopwatch.toString()}`));
        task.status = TaskStatus_1.default.Skipped;
        task.dependents.forEach((dependent) => {
            dependent.dependencies.delete(task);
        });
    }
    /**
     * Do any Ready or Executing tasks exist?
     */
    _areAnyTasksReadyOrExecuting() {
        let anyNonCompletedTasks = false;
        this._tasks.forEach((task) => {
            if (task.status === TaskStatus_1.default.Executing || task.status === TaskStatus_1.default.Ready) {
                anyNonCompletedTasks = true;
            }
        });
        return anyNonCompletedTasks;
    }
    /**
     * Checks for projects that indirectly depend on themselves.
     */
    _checkForCyclicDependencies(tasks, dependencyChain) {
        for (const task of tasks) {
            if (dependencyChain.indexOf(task.name) >= 0) {
                throw new Error('A cyclic dependency was encountered:\n'
                    + '  ' + [...dependencyChain, task.name].reverse().join('\n  -> ')
                    + '\nConsider using the cyclicDependencyProjects option for rush.json.');
            }
            dependencyChain.push(task.name);
            this._checkForCyclicDependencies(task.dependents, dependencyChain);
            dependencyChain.pop();
        }
    }
    /**
     * Calculate the number of packages which must be built before we reach
     * the furthest away "root" node
     */
    _calculateCriticalPaths(task) {
        // Return the memoized value
        if (task.criticalPathLength !== undefined) {
            return task.criticalPathLength;
        }
        // If no dependents, we are in a "root"
        if (task.dependents.size === 0) {
            return task.criticalPathLength = 0;
        }
        else {
            // Otherwise we are as long as the longest package + 1
            const depsLengths = [];
            task.dependents.forEach(dep => this._calculateCriticalPaths(dep));
            return task.criticalPathLength = Math.max(...depsLengths) + 1;
        }
    }
    /**
     * Prints out a report of the status of each project
     */
    _printTaskStatus() {
        const tasksByStatus = {};
        this._tasks.forEach((task) => {
            if (tasksByStatus[task.status]) {
                tasksByStatus[task.status].push(task);
            }
            else {
                tasksByStatus[task.status] = [task];
            }
        });
        console.log('');
        this._printStatus('EXECUTING', tasksByStatus[TaskStatus_1.default.Executing], colors.yellow);
        this._printStatus('READY', tasksByStatus[TaskStatus_1.default.Ready], colors.white);
        this._printStatus('SKIPPED', tasksByStatus[TaskStatus_1.default.Skipped], colors.grey);
        this._printStatus('SUCCESS', tasksByStatus[TaskStatus_1.default.Success], colors.green);
        this._printStatus('SUCCESS WITH WARNINGS', tasksByStatus[TaskStatus_1.default.SuccessWithWarning], colors.yellow.underline);
        this._printStatus('BLOCKED', tasksByStatus[TaskStatus_1.default.Blocked], colors.red);
        this._printStatus('FAILURE', tasksByStatus[TaskStatus_1.default.Failure], colors.red);
        const tasksWithErrors = tasksByStatus[TaskStatus_1.default.Failure];
        if (tasksWithErrors) {
            tasksWithErrors.forEach((task) => {
                task.errors.forEach((error) => {
                    if (error) {
                        console.log(colors.red(`[${task.name}] ${error.toString()}`));
                    }
                });
            });
        }
        console.log('');
    }
    _printStatus(status, tasks, color) {
        if (tasks && tasks.length) {
            console.log(color(`${status} (${tasks.length})`));
            console.log(color('================================'));
            for (let i = 0; i < tasks.length; i++) {
                const task = tasks[i];
                console.log(color(task.name));
                if (task.writer) {
                    let stderr = task.writer.getStdError();
                    if (stderr && (task.status === TaskStatus_1.default.Failure || task.status === TaskStatus_1.default.SuccessWithWarning)) {
                        stderr = stderr.split(os.EOL)
                            .map(text => text.trim())
                            .filter(text => text)
                            .join(os.EOL);
                        console.log(stderr + (i !== tasks.length - 1 ? os.EOL : ''));
                    }
                }
            }
            console.log(color('================================' + os.EOL));
        }
    }
}
exports.default = TaskRunner;

//# sourceMappingURL=TaskRunner.js.map
