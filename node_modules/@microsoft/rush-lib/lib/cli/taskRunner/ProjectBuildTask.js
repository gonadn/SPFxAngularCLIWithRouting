"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const fsx = require("fs-extra");
const path = require("path");
const node_core_library_1 = require("@microsoft/node-core-library");
const RushConstants_1 = require("../../RushConstants");
const Utilities_1 = require("../../utilities/Utilities");
const TaskStatus_1 = require("./TaskStatus");
const TaskError_1 = require("./TaskError");
const PackageChangeAnalyzer_1 = require("../utilities/PackageChangeAnalyzer");
/**
 * A TaskRunner task which cleans and builds a project
 */
class ProjectBuildTask {
    constructor(_rushProject, _rushConfiguration, _commandToRun, _customFlags, isIncrementalBuildAllowed) {
        this._rushProject = _rushProject;
        this._rushConfiguration = _rushConfiguration;
        this._commandToRun = _commandToRun;
        this._customFlags = _customFlags;
        this.isIncrementalBuildAllowed = isIncrementalBuildAllowed;
    }
    get name() {
        return this._rushProject.packageName;
    }
    execute(writer) {
        return new Promise((resolve, reject) => {
            try {
                const build = this._getScriptToRun();
                const deps = this._getPackageDependencies(build, writer);
                this._executeTask(build, writer, deps, resolve, reject);
            }
            catch (error) {
                reject([new TaskError_1.default('executing', error.toString())]);
            }
        });
    }
    _getPackageDependencies(buildCommand, writer) {
        let deps = undefined;
        PackageChangeAnalyzer_1.PackageChangeAnalyzer.rushConfig = this._rushConfiguration;
        try {
            deps = {
                files: PackageChangeAnalyzer_1.PackageChangeAnalyzer.instance.getPackageDepsHash(this._rushProject.packageName).files,
                arguments: buildCommand
            };
        }
        catch (error) {
            writer.writeLine('Unable to calculate incremental build state. ' +
                'Instead running full rebuild. ' + error.toString());
        }
        return deps;
    }
    _executeTask(buildCommand, writer, currentPackageDeps, resolve, reject) {
        this._hasWarningOrError = false;
        const projectFolder = this._rushProject.projectFolder;
        let lastPackageDeps = undefined;
        try {
            writer.writeLine(`>>> ${this.name}`);
            const currentDepsPath = path.join(this._rushProject.projectFolder, RushConstants_1.RushConstants.packageDepsFilename);
            if (fsx.existsSync(currentDepsPath)) {
                lastPackageDeps = node_core_library_1.JsonFile.load(currentDepsPath);
            }
            const isPackageUnchanged = (!!(lastPackageDeps &&
                currentPackageDeps &&
                (currentPackageDeps.arguments === lastPackageDeps.arguments &&
                    _areShallowEqual(currentPackageDeps.files, lastPackageDeps.files, writer))));
            if (isPackageUnchanged && this.isIncrementalBuildAllowed) {
                resolve(TaskStatus_1.default.Skipped);
            }
            else {
                // If the deps file exists, remove it before starting a build.
                if (fsx.existsSync(currentDepsPath)) {
                    fsx.unlinkSync(currentDepsPath);
                }
                if (!buildCommand) {
                    // tslint:disable-next-line:max-line-length
                    writer.writeLine(`The 'build' or 'test' command was registered in the package.json but is blank, so no action will be taken.`);
                    resolve(TaskStatus_1.default.Success);
                    return;
                }
                // Run the build step
                writer.writeLine(buildCommand);
                const buildTask = Utilities_1.default.executeShellCommandAsync(buildCommand, projectFolder, process.env, true);
                // Hook into events, in order to get live streaming of build log
                buildTask.stdout.on('data', (data) => {
                    writer.write(data);
                });
                buildTask.stderr.on('data', (data) => {
                    writer.writeError(data);
                    this._hasWarningOrError = true;
                });
                buildTask.on('close', (code) => {
                    // Write the logs to disk
                    this._writeLogsToDisk(writer);
                    if (code) {
                        reject([new TaskError_1.default('error', `Returned error code: ${code}`)]);
                    }
                    else if (this._hasWarningOrError) {
                        resolve(TaskStatus_1.default.SuccessWithWarning);
                    }
                    else {
                        // Write deps on success.
                        if (currentPackageDeps) {
                            node_core_library_1.JsonFile.save(currentPackageDeps, currentDepsPath);
                        }
                        resolve(TaskStatus_1.default.Success);
                    }
                });
            }
        }
        catch (error) {
            console.log(error);
            // Write the logs to disk
            this._writeLogsToDisk(writer);
            reject([new TaskError_1.default('error', error.toString())]);
        }
    }
    _isBuildCommand() {
        return this._commandToRun === 'build' || this._commandToRun === 'rebuild';
    }
    _getScriptToRun() {
        let script = undefined;
        if (this._isBuildCommand()) {
            script = this._getScriptCommand('build');
            if (script === undefined) {
                // tslint:disable-next-line:max-line-length
                throw new Error(`The project [${this._rushProject.packageName}] does not define a 'build' command in the 'scripts' section of its package.json`);
            }
        }
        else {
            script = this._getScriptCommand(this._commandToRun);
            if (script === undefined) {
                // tslint:disable-next-line:max-line-length
                throw new Error(`The project [${this._rushProject.packageName}] does not define a '${this._commandToRun}' command in the 'scripts' section of its package.json`);
            }
        }
        if (script === '') {
            return script;
        }
        return `${script} ${this._customFlags.join(' ')}`;
    }
    _getScriptCommand(script) {
        // tslint:disable-next-line:no-string-literal
        if (!this._rushProject.packageJson.scripts) {
            return undefined;
        }
        const rawCommand = this._rushProject.packageJson.scripts[script];
        // tslint:disable-next-line:no-null-keyword
        if (rawCommand === undefined || rawCommand === null) {
            return undefined;
        }
        return rawCommand;
    }
    // @todo #179371: add log files to list of things that get gulp cleaned
    _writeLogsToDisk(writer) {
        const logFilename = path.basename(this._rushProject.projectFolder);
        const stdout = writer.getStdOutput().replace(/\x1B[[(?);]{0,2}(;?\d)*./g, '');
        if (stdout) {
            fsx.writeFileSync(path.join(this._rushProject.projectFolder, logFilename + '.build.log'), stdout);
        }
        const stderr = writer.getStdError().replace(/\x1B[[(?);]{0,2}(;?\d)*./g, '');
        if (stderr) {
            fsx.writeFileSync(path.join(this._rushProject.projectFolder, logFilename + '.build.error.log'), stderr);
        }
    }
}
exports.default = ProjectBuildTask;
function _areShallowEqual(object1, object2, writer) {
    for (const n in object1) {
        if (!(n in object2) || object1[n] !== object2[n]) {
            writer.writeLine(`Found mismatch: "${n}": "${object1[n]}" !== "${object2[n]}"`);
            return false;
        }
    }
    for (const n in object2) {
        if (!(n in object1)) {
            writer.writeLine(`Found new prop in obj2: "${n}" value="${object2[n]}"`);
            return false;
        }
    }
    return true;
}

//# sourceMappingURL=ProjectBuildTask.js.map
