"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const node_core_library_1 = require("@microsoft/node-core-library");
const TaskRunner_1 = require("../taskRunner/TaskRunner");
const ProjectBuildTask_1 = require("../taskRunner/ProjectBuildTask");
/**
 * This class is responsible for:
 *  - based on to/from flags, solving the dependency graph and figuring out which projects need to be run
 *  - creating a ProjectBuildTask for each project that needs to be built
 *  - registering the necessary ProjectBuildTasks with the TaskRunner, which actually orchestrates execution
 *
 * This class is currently only used by CustomRushAction
 */
class TaskSelector {
    constructor(_options) {
        this._options = _options;
        this._taskRunner = new TaskRunner_1.default(this._options.isQuietMode, this._options.parallelism);
        try {
            this._rushLinkJson = node_core_library_1.JsonFile.load(this._options.rushConfiguration.rushLinkJsonFilename);
        }
        catch (error) {
            throw new Error(`Could not read "${this._options.rushConfiguration.rushLinkJsonFilename}".`
                + ` Have you ran "rush install" and/or "rush link"?`);
        }
        if (this._options.toFlags) {
            this._registerToFlags(this._options.toFlags);
        }
        if (this._options.fromFlags) {
            this._registerFromFlags(this._options.fromFlags);
        }
        if (!this._options.toFlags && !this._options.fromFlags) {
            this._registerAll();
        }
    }
    execute() {
        return this._taskRunner.execute();
    }
    _registerToFlags(toFlags) {
        for (const toFlag of toFlags) {
            const toProject = this._options.rushConfiguration.findProjectByShorthandName(toFlag);
            if (!toProject) {
                throw new Error(`The project '${toFlag}' does not exist in rush.json`);
            }
            const deps = this._collectAllDependencies(toProject.packageName);
            // Register any dependencies it may have
            deps.forEach(dep => this._registerTask(this._options.rushConfiguration.getProjectByName(dep)));
            // Register the dependency graph to the TaskRunner
            deps.forEach(dep => this._taskRunner.addDependencies(dep, this._rushLinkJson.localLinks[dep] || []));
        }
    }
    _registerFromFlags(fromFlags) {
        for (const fromFlag of fromFlags) {
            const fromProject = this._options.rushConfiguration.findProjectByShorthandName(fromFlag);
            if (!fromProject) {
                throw new Error(`The project '${fromFlag}' does not exist in rush.json`);
            }
            // Only register projects which depend on the current package, as well as things that depend on them
            this._buildDependentGraph();
            // We will assume this project will be built, but act like it has no dependencies
            const dependents = this._collectAllDependents(fromProject.packageName);
            dependents.add(fromProject.packageName);
            // Register all downstream dependents
            dependents.forEach(dependent => {
                this._registerTask(this._options.rushConfiguration.getProjectByName(dependent));
            });
            // Only register dependencies graph for projects which have been registered
            // e.g. package C may depend on A & B, but if we are only building A's downstream, we will ignore B
            dependents.forEach(dependent => this._taskRunner.addDependencies(dependent, (this._rushLinkJson.localLinks[dependent] || []).filter(dep => dependents.has(dep))));
        }
    }
    _registerAll() {
        // Register all tasks
        for (const rushProject of this._options.rushConfiguration.projects) {
            this._registerTask(rushProject);
        }
        // Add all dependencies
        for (const projectName of Object.keys(this._rushLinkJson.localLinks)) {
            this._taskRunner.addDependencies(projectName, this._rushLinkJson.localLinks[projectName]);
        }
    }
    /**
     * Collects all upstream dependencies for a certain project
     */
    _collectAllDependencies(project) {
        const deps = new Set(this._rushLinkJson.localLinks[project]);
        deps.forEach(dep => this._collectAllDependencies(dep).forEach(innerDep => deps.add(innerDep)));
        deps.add(project);
        return deps;
    }
    /**
     * Collects all downstream dependents of a certain project
     */
    _collectAllDependents(project) {
        const deps = new Set();
        (this._dependentList.get(project) || new Set()).forEach((dep) => {
            deps.add(dep);
        });
        deps.forEach(dep => this._collectAllDependents(dep).forEach(innerDep => deps.add(innerDep)));
        return deps;
    }
    /**
     * Inverts the localLinks to arrive at the dependent graph, rather than using the dependency graph
     * this helps when using the --from flag
     */
    _buildDependentGraph() {
        this._dependentList = new Map();
        Object.keys(this._rushLinkJson.localLinks).forEach(project => {
            this._rushLinkJson.localLinks[project].forEach(dep => {
                if (!this._dependentList.has(dep)) {
                    this._dependentList.set(dep, new Set());
                }
                this._dependentList.get(dep).add(project);
            });
        });
    }
    _registerTask(project) {
        if (project) {
            const projectTask = new ProjectBuildTask_1.default(project, this._options.rushConfiguration, this._options.commandToRun, this._options.customFlags, this._options.isIncrementalBuildAllowed);
            if (!this._taskRunner.hasTask(projectTask.name)) {
                this._taskRunner.addTask(projectTask);
            }
        }
    }
}
exports.TaskSelector = TaskSelector;

//# sourceMappingURL=TaskSelector.js.map
