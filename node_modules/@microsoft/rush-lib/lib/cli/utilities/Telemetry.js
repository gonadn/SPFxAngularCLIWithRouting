"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const fsx = require("fs-extra");
const lodash_1 = require("lodash");
const Rush_1 = require("../../Rush");
const MAX_FILE_COUNT = 100;
class Telemetry {
    constructor(_rushConfiguration) {
        this._rushConfiguration = _rushConfiguration;
        this._enabled = this._rushConfiguration.telemetryEnabled;
        this._store = [];
        const folderName = 'telemetry';
        this._dataFolder = path.join(this._rushConfiguration.commonTempFolder, folderName);
    }
    log(telemetryData) {
        if (!this._enabled) {
            return;
        }
        const data = lodash_1.cloneDeep(telemetryData);
        data.timestamp = data.timestamp || new Date().getTime();
        data.platform = data.platform || process.platform;
        data.rushVersion = data.rushVersion || Rush_1.default.version;
        this._store.push(data);
    }
    flush(writeFile = fsx.writeFileSync) {
        if (!this._enabled || this._store.length === 0) {
            return;
        }
        const fullPath = this._getFilePath();
        fsx.ensureDirSync(this._dataFolder);
        writeFile(fullPath, JSON.stringify(this._store));
        this._store = [];
        this._cleanUp();
    }
    get store() {
        return this._store;
    }
    /**
     * When there are too many log files, delete the old ones.
     */
    _cleanUp() {
        if (fsx.existsSync(this._dataFolder)) {
            const files = fsx.readdirSync(this._dataFolder);
            if (files.length > MAX_FILE_COUNT) {
                const sortedFiles = files.map(fileName => {
                    const filePath = path.join(this._dataFolder, fileName);
                    const stats = fsx.statSync(filePath);
                    return {
                        filePath: filePath,
                        modifiedTime: stats.mtime.getTime(),
                        isFile: stats.isFile()
                    };
                })
                    .filter(value => {
                    // Only delete files
                    return value.isFile;
                })
                    .sort((a, b) => {
                    return a.modifiedTime - b.modifiedTime;
                })
                    .map(s => {
                    return s.filePath;
                });
                const filesToDelete = sortedFiles.length - MAX_FILE_COUNT;
                for (let i = 0; i < filesToDelete; i++) {
                    fsx.unlinkSync(sortedFiles[i]);
                }
            }
        }
    }
    _getFilePath() {
        let fileName = `telemetry_${new Date().toISOString()}`;
        fileName = fileName.replace(/[\-\:\.]/g, '_') + '.json';
        return path.join(this._dataFolder, fileName);
    }
}
exports.default = Telemetry;

//# sourceMappingURL=Telemetry.js.map
