"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * This file contains a set of helper functions that are unit tested and used with the PublishAction,
 * which itself it a thin wrapper around these helpers.
 */
const os_1 = require("os");
const fsx = require("fs-extra");
const path = require("path");
const semver = require("semver");
const ChangeManagement_1 = require("../../data/ChangeManagement");
const Utilities_1 = require("../../utilities/Utilities");
const child_process_1 = require("child_process");
class PublishUtilities {
    /**
     * Finds change requests in the given folder.
     * @param changesPath Path to the changes folder.
     * @returns Dictionary of all change requests, keyed by package name.
     */
    static findChangeRequests(allPackages, changeFiles, includeCommitDetails, prereleaseToken, projectsToExclude) {
        const allChanges = {};
        console.log(`Finding changes in: ${changeFiles.getChangesPath()}`);
        const files = changeFiles.getFiles();
        // Add the minimum changes defined by the change descriptions.
        files.forEach((fullPath) => {
            const changeRequest = JSON.parse(fsx.readFileSync(fullPath, 'utf8'));
            if (includeCommitDetails) {
                PublishUtilities._updateCommitDetails(fullPath, changeRequest.changes);
            }
            for (const change of changeRequest.changes) {
                PublishUtilities._addChange(change, allChanges, allPackages, prereleaseToken, projectsToExclude);
            }
        });
        // For each requested package change, ensure downstream dependencies are also updated.
        for (const packageName in allChanges) {
            if (allChanges.hasOwnProperty(packageName)) {
                PublishUtilities._updateDownstreamDependencies(allChanges[packageName], allChanges, allPackages, prereleaseToken, projectsToExclude);
            }
        }
        // Update orders so that downstreams are marked to come after upstreams.
        for (const packageName in allChanges) {
            if (allChanges.hasOwnProperty(packageName)) {
                const change = allChanges[packageName];
                const project = allPackages.get(packageName);
                const pkg = project.packageJson;
                const deps = project.downstreamDependencyProjects;
                // Write the new version expected for the change.
                const skipVersionBump = PublishUtilities._shouldSkipVersionBump(project, prereleaseToken, projectsToExclude);
                if (skipVersionBump) {
                    change.newVersion = pkg.version;
                }
                else {
                    change.newVersion = (change.changeType >= ChangeManagement_1.ChangeType.patch) ?
                        semver.inc(pkg.version, PublishUtilities._getReleaseType(change.changeType)) :
                        pkg.version;
                }
                if (deps) {
                    for (const depName of deps) {
                        const depChange = allChanges[depName];
                        if (depChange) {
                            depChange.order = Math.max(change.order + 1, depChange.order);
                        }
                    }
                }
            }
        }
        return allChanges;
    }
    /**
     * Given the changes hash, flattens them into a sorted array based on their dependency order.
     * @params allChanges - hash of change requests.
     * @returns Sorted array of change requests.
     */
    static sortChangeRequests(allChanges) {
        return Object
            .keys(allChanges)
            .map(key => allChanges[key])
            .sort((a, b) => a.order < b.order ? -1 : 1);
    }
    /**
     * Given a single change request, updates the package json file with updated versions on disk.
     */
    static updatePackages(allChanges, allPackages, shouldCommit, prereleaseToken, projectsToExclude) {
        const updatedPackages = new Map();
        Object.keys(allChanges).forEach(packageName => {
            const updatedPackage = PublishUtilities._writePackageChanges(allChanges[packageName], allChanges, allPackages, shouldCommit, prereleaseToken, projectsToExclude);
            updatedPackages.set(updatedPackage.name, updatedPackage);
        });
        return updatedPackages;
    }
    /**
     * Returns the generated tagname to use for a published commit, given package name and version.
     */
    static createTagname(packageName, version) {
        return packageName + '_v' + version;
    }
    static isRangeDependency(version) {
        const LOOSE_PKG_REGEX = />=?(?:\d+\.){2}\d+(\-[0-9A-Za-z-.]*)?\s+<(?:\d+\.){2}\d+/;
        return LOOSE_PKG_REGEX.test(version);
    }
    static getEnvArgs() {
        const env = {};
        // Copy existing process.env values (for nodist)
        Object.keys(process.env).forEach((key) => {
            env[key] = process.env[key];
        });
        return env;
    }
    static execCommand(shouldExecute, command, args = [], workingDirectory = process.cwd(), env) {
        let relativeDirectory = path.relative(process.cwd(), workingDirectory);
        const envArgs = PublishUtilities.getEnvArgs();
        if (relativeDirectory) {
            relativeDirectory = `(${relativeDirectory})`;
        }
        if (env) {
            Object.keys(env).forEach((name) => envArgs[name] = env[name]);
        }
        console.log(`${os_1.EOL}* ${shouldExecute ? 'EXECUTING' : 'DRYRUN'}: ${command} ${args.join(' ')} ${relativeDirectory}`);
        if (shouldExecute) {
            Utilities_1.default.executeCommand(command, args, workingDirectory, false, env);
        }
    }
    static getNewDependencyVersion(dependencies, dependencyName, newProjectVersion) {
        const currentDependencyVersion = dependencies[dependencyName];
        let newDependencyVersion;
        if (PublishUtilities.isRangeDependency(currentDependencyVersion)) {
            newDependencyVersion = PublishUtilities._getNewRangeDependency(newProjectVersion);
        }
        else if (currentDependencyVersion.lastIndexOf('~', 0) === 0) {
            newDependencyVersion = '~' + newProjectVersion;
        }
        else if (currentDependencyVersion.lastIndexOf('^', 0) === 0) {
            newDependencyVersion = '^' + newProjectVersion;
        }
        else {
            newDependencyVersion = newProjectVersion;
        }
        return newDependencyVersion;
    }
    static _getReleaseType(changeType) {
        switch (changeType) {
            case ChangeManagement_1.ChangeType.major:
                return 'major';
            case ChangeManagement_1.ChangeType.minor:
                return 'minor';
            case ChangeManagement_1.ChangeType.patch:
                return 'patch';
            default:
                throw new Error(`Wrong change type ${changeType}`);
        }
    }
    static _getNewRangeDependency(newVersion) {
        let upperLimit = newVersion;
        if (semver.prerelease(newVersion)) {
            // Remove the prerelease first, then bump major.
            upperLimit = semver.inc(newVersion, 'patch');
        }
        upperLimit = semver.inc(upperLimit, 'major');
        return `>=${newVersion} <${upperLimit}`;
    }
    static _shouldSkipVersionBump(project, prereleaseToken, projectsToExclude) {
        // Suffix does not bump up the version.
        // Excluded projects do not bump up version.
        return prereleaseToken && prereleaseToken.isSuffix ||
            projectsToExclude && projectsToExclude.has(project.packageName) ||
            !project.shouldPublish;
    }
    static _updateCommitDetails(filename, changes) {
        try {
            const fileLog = child_process_1.execSync('git log -n 1 ' + filename, { cwd: path.dirname(filename) }).toString();
            const author = fileLog.match(/Author: (.*)/)[1];
            const commit = fileLog.match(/commit (.*)/)[1];
            changes.forEach(change => {
                change.author = author;
                change.commit = commit;
            });
        }
        catch (e) { }
    }
    static _writePackageChanges(change, allChanges, allPackages, shouldCommit, prereleaseToken, projectsToExclude) {
        const project = allPackages.get(change.packageName);
        const pkg = project.packageJson;
        const shouldSkipVersionBump = !project.shouldPublish ||
            !!projectsToExclude && projectsToExclude.has(change.packageName);
        const newVersion = shouldSkipVersionBump ? pkg.version :
            PublishUtilities._getChangeInfoNewVersion(change, prereleaseToken);
        if (!shouldSkipVersionBump) {
            console.log(`${os_1.EOL}* ${shouldCommit ? 'APPLYING' : 'DRYRUN'}: ${ChangeManagement_1.ChangeType[change.changeType]} update ` +
                `for ${change.packageName} to ${newVersion}`);
        }
        else {
            console.log(`${os_1.EOL}* ${shouldCommit ? 'APPLYING' : 'DRYRUN'}: update ` + `for ${change.packageName} at ${newVersion}`);
        }
        const packagePath = path.join(project.projectFolder, 'package.json');
        pkg.version = newVersion;
        // Update the package's dependencies.
        PublishUtilities._updateDependencies(pkg.name, pkg.dependencies, allChanges, allPackages, prereleaseToken, projectsToExclude);
        // Update the package's dev dependencies.
        PublishUtilities._updateDependencies(pkg.name, pkg.devDependencies, allChanges, allPackages, prereleaseToken, projectsToExclude);
        change.changes.forEach(subChange => {
            if (subChange.comment) {
                console.log(` - [${ChangeManagement_1.ChangeType[subChange.changeType]}] ${subChange.comment}`);
            }
        });
        if (shouldCommit) {
            fsx.writeFileSync(packagePath, JSON.stringify(pkg, undefined, 2), { encoding: 'utf8' });
        }
        return pkg;
    }
    static _isCyclicDependency(allPackages, packageName, dependencyName) {
        const packageConfig = allPackages.get(packageName);
        return !!packageConfig && packageConfig.cyclicDependencyProjects.has(dependencyName);
    }
    static _updateDependencies(packageName, dependencies, allChanges, allPackages, prereleaseToken, projectsToExclude) {
        if (dependencies) {
            Object.keys(dependencies).forEach(depName => {
                if (!PublishUtilities._isCyclicDependency(allPackages, packageName, depName)) {
                    const depChange = allChanges[depName];
                    if (!depChange) {
                        return;
                    }
                    const depProject = allPackages.get(depName);
                    if (!depProject.shouldPublish || projectsToExclude && projectsToExclude.has(depName)) {
                        // No version change.
                        return;
                    }
                    else if (depChange && prereleaseToken && prereleaseToken.hasValue) {
                        // TODO: treat prerelease version the same as non-prerelease version.
                        // For prelease, the newVersion needs to be appended with prerelease name.
                        // And dependency should specify the specific prerelease version.
                        dependencies[depName] = PublishUtilities._getChangeInfoNewVersion(depChange, prereleaseToken);
                    }
                    else if (depChange && depChange.changeType >= ChangeManagement_1.ChangeType.patch) {
                        PublishUtilities._updateDependencyVersion(packageName, dependencies, depName, depChange, allChanges, allPackages);
                    }
                }
            });
        }
    }
    /**
     * Gets the new version from the ChangeInfo.
     * The value of newVersion in ChangeInfo remains unchanged when the change type is dependency,
     * However, for pre-release build, it won't pick up the updated pre-released dependencies. That is why
     * this function should return a pre-released patch for that case.
     */
    static _getChangeInfoNewVersion(change, prereleaseToken) {
        let newVersion = change.newVersion;
        if (prereleaseToken && prereleaseToken.hasValue) {
            if (prereleaseToken.isPrerelease && change.changeType === ChangeManagement_1.ChangeType.dependency) {
                newVersion = semver.inc(newVersion, 'patch');
            }
            return `${newVersion}-${prereleaseToken.name}`;
        }
        else {
            return newVersion;
        }
    }
    /**
     * Adds the given change to the allChanges map.
     *
     * @returns true if the change caused the dependency change type to increase.
     */
    static _addChange(change, allChanges, allPackages, prereleaseToken, projectsToExclude) {
        let hasChanged = false;
        const packageName = change.packageName;
        const project = allPackages.get(packageName);
        if (!project) {
            console.log(`The package ${packageName} was requested for publishing but ` +
                `does not exist. Skip this change.`);
            return false;
        }
        const pkg = project.packageJson;
        let currentChange;
        // If the given change does not have a changeType, derive it from the "type" string.
        if (change.changeType === undefined) {
            change.changeType = ChangeManagement_1.ChangeType[change.type];
        }
        if (!allChanges[packageName]) {
            hasChanged = true;
            currentChange = allChanges[packageName] = {
                packageName,
                changeType: change.changeType,
                order: 0,
                changes: [change]
            };
        }
        else {
            currentChange = allChanges[packageName];
            const oldChangeType = currentChange.changeType;
            currentChange.changeType = Math.max(currentChange.changeType, change.changeType);
            currentChange.changes.push(change);
            hasChanged = hasChanged || (oldChangeType !== currentChange.changeType);
        }
        const skipVersionBump = PublishUtilities._shouldSkipVersionBump(project, prereleaseToken, projectsToExclude);
        if (skipVersionBump) {
            currentChange.newVersion = pkg.version;
            hasChanged = false;
            currentChange.changeType = ChangeManagement_1.ChangeType.none;
        }
        else {
            currentChange.newVersion = change.changeType >= ChangeManagement_1.ChangeType.patch ?
                semver.inc(pkg.version, PublishUtilities._getReleaseType(currentChange.changeType)) :
                pkg.version;
            currentChange.newRangeDependency = PublishUtilities._getNewRangeDependency(currentChange.newVersion);
        }
        return hasChanged;
    }
    static _updateDownstreamDependencies(change, allChanges, allPackages, prereleaseToken, projectsToExclude) {
        const packageName = change.packageName;
        const downstreamNames = allPackages.get(packageName).downstreamDependencyProjects;
        // Iterate through all downstream dependencies for the package.
        if (downstreamNames) {
            if ((change.changeType >= ChangeManagement_1.ChangeType.patch) ||
                (prereleaseToken && prereleaseToken.hasValue)) {
                for (const depName of downstreamNames) {
                    const pkg = allPackages.get(depName).packageJson;
                    PublishUtilities._updateDownstreamDependency(pkg.name, pkg.dependencies, change, allChanges, allPackages, prereleaseToken, projectsToExclude);
                    PublishUtilities._updateDownstreamDependency(pkg.name, pkg.devDependencies, change, allChanges, allPackages, prereleaseToken, projectsToExclude);
                }
            }
        }
    }
    static _updateDownstreamDependency(parentPackageName, dependencies, change, allChanges, allPackages, prereleaseToken, projectsToExclude) {
        if (dependencies && dependencies[change.packageName]) {
            const requiredVersion = dependencies[change.packageName];
            const alwaysUpdate = !!prereleaseToken && prereleaseToken.hasValue &&
                !allChanges.hasOwnProperty(parentPackageName);
            // If the version range exists and has not yet been updated to this version, update it.
            if (requiredVersion !== change.newRangeDependency || alwaysUpdate) {
                // Either it already satisfies the new version, or doesn't.
                // If not, the downstream dep needs to be republished.
                const changeType = semver.satisfies(change.newVersion, requiredVersion) ?
                    ChangeManagement_1.ChangeType.dependency :
                    ChangeManagement_1.ChangeType.patch;
                const hasChanged = PublishUtilities._addChange({
                    packageName: parentPackageName,
                    changeType
                }, allChanges, allPackages, prereleaseToken, projectsToExclude);
                if (hasChanged || alwaysUpdate) {
                    // Only re-evaluate downstream dependencies if updating the parent package's dependency
                    // caused a version bump.
                    PublishUtilities._updateDownstreamDependencies(allChanges[parentPackageName], allChanges, allPackages, prereleaseToken, projectsToExclude);
                }
            }
        }
    }
    static _updateDependencyVersion(packageName, dependencies, dependencyName, dependencyChange, allChanges, allPackages) {
        const currentDependencyVersion = dependencies[dependencyName];
        dependencies[dependencyName] = PublishUtilities.getNewDependencyVersion(dependencies, dependencyName, dependencyChange.newVersion);
        // Add dependency version update comment.
        PublishUtilities._addChange({
            packageName: packageName,
            changeType: ChangeManagement_1.ChangeType.dependency,
            comment: `Updating dependency "${dependencyName}" from \`${currentDependencyVersion}\`` +
                ` to \`${dependencies[dependencyName]}\``
        }, allChanges, allPackages);
    }
}
exports.default = PublishUtilities;

//# sourceMappingURL=PublishUtilities.js.map
