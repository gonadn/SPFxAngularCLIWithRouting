import IPackageJson from '../../utilities/IPackageJson';
import { IChangeInfo } from '../../data/ChangeManagement';
import RushConfigurationProject from '../../data/RushConfigurationProject';
import PrereleaseToken from './PrereleaseToken';
import ChangeFiles from './ChangeFiles';
export interface IChangeInfoHash {
    [key: string]: IChangeInfo;
}
export default class PublishUtilities {
    /**
     * Finds change requests in the given folder.
     * @param changesPath Path to the changes folder.
     * @returns Dictionary of all change requests, keyed by package name.
     */
    static findChangeRequests(allPackages: Map<string, RushConfigurationProject>, changeFiles: ChangeFiles, includeCommitDetails?: boolean, prereleaseToken?: PrereleaseToken, projectsToExclude?: Set<string>): IChangeInfoHash;
    /**
     * Given the changes hash, flattens them into a sorted array based on their dependency order.
     * @params allChanges - hash of change requests.
     * @returns Sorted array of change requests.
     */
    static sortChangeRequests(allChanges: IChangeInfoHash): IChangeInfo[];
    /**
     * Given a single change request, updates the package json file with updated versions on disk.
     */
    static updatePackages(allChanges: IChangeInfoHash, allPackages: Map<string, RushConfigurationProject>, shouldCommit: boolean, prereleaseToken?: PrereleaseToken, projectsToExclude?: Set<string>): Map<string, IPackageJson>;
    /**
     * Returns the generated tagname to use for a published commit, given package name and version.
     */
    static createTagname(packageName: string, version: string): string;
    static isRangeDependency(version: string): boolean;
    static getEnvArgs(): {
        [key: string]: string;
    };
    static execCommand(shouldExecute: boolean, command: string, args?: string[], workingDirectory?: string, env?: {
        [key: string]: string;
    }): void;
    static getNewDependencyVersion(dependencies: {
        [key: string]: string;
    }, dependencyName: string, newProjectVersion: string): string;
    private static _getReleaseType(changeType);
    private static _getNewRangeDependency(newVersion);
    private static _shouldSkipVersionBump(project, prereleaseToken?, projectsToExclude?);
    private static _updateCommitDetails(filename, changes);
    private static _writePackageChanges(change, allChanges, allPackages, shouldCommit, prereleaseToken?, projectsToExclude?);
    private static _isCyclicDependency(allPackages, packageName, dependencyName);
    private static _updateDependencies(packageName, dependencies, allChanges, allPackages, prereleaseToken, projectsToExclude?);
    /**
     * Gets the new version from the ChangeInfo.
     * The value of newVersion in ChangeInfo remains unchanged when the change type is dependency,
     * However, for pre-release build, it won't pick up the updated pre-released dependencies. That is why
     * this function should return a pre-released patch for that case.
     */
    private static _getChangeInfoNewVersion(change, prereleaseToken);
    /**
     * Adds the given change to the allChanges map.
     *
     * @returns true if the change caused the dependency change type to increase.
     */
    private static _addChange(change, allChanges, allPackages, prereleaseToken?, projectsToExclude?);
    private static _updateDownstreamDependencies(change, allChanges, allPackages, prereleaseToken, projectsToExclude?);
    private static _updateDownstreamDependency(parentPackageName, dependencies, change, allChanges, allPackages, prereleaseToken, projectsToExclude?);
    private static _updateDependencyVersion(packageName, dependencies, dependencyName, dependencyChange, allChanges, allPackages);
}
