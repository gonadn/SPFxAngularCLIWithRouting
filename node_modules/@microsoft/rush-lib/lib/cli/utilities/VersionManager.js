"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const semver = require("semver");
const fsx = require("fs-extra");
const lodash_1 = require("lodash");
const VersionPolicy_1 = require("../../data/VersionPolicy");
const ChangeFile_1 = require("../../data/ChangeFile");
const ChangeManagement_1 = require("../../data/ChangeManagement");
const RushConfiguration_1 = require("../../data/RushConfiguration");
const PublishUtilities_1 = require("./PublishUtilities");
const ChangeManager_1 = require("./ChangeManager");
class VersionManager {
    constructor(_rushConfiguration, _userEmail, _versionPolicyConfiguration) {
        this._rushConfiguration = _rushConfiguration;
        this._userEmail = _userEmail;
        this._versionPolicyConfiguration = _versionPolicyConfiguration ?
            _versionPolicyConfiguration : this._rushConfiguration.versionPolicyConfiguration;
        this._updatedProjects = new Map();
        this._changeFiles = new Map();
    }
    /**
     * Ensures project versions follow the provided version policy. If version policy is not
     * provided, all projects will have their version checked according to the associated version policy.
     * package.json files will be updated if needed.
     * This method does not commit changes.
     * @param versionPolicyName -- version policy name
     * @param shouldCommit -- should update files to disk
     */
    ensure(versionPolicyName, shouldCommit) {
        this._ensure(versionPolicyName, shouldCommit);
    }
    /**
     * Bumps sversions following version policies.
     *
     * @param lockStepVersionPolicyName - a specified lock step version policy name. Without this value,
     * versions for all lock step policies and all individual policies will be bumped.
     * With this value, only the specified lock step policy will be bumped along with all individual policies.
     * @param bumpType - overrides the default bump type and only works for lock step policy
     * @param identifier - overrides the prerelease identifier and only works for lock step policy
     * @param shouldCommit - whether the changes will be written to disk
     */
    bump(lockStepVersionPolicyName, bumpType, identifier, shouldCommit) {
        // Bump all the lock step version policies.
        this._versionPolicyConfiguration.bump(lockStepVersionPolicyName, bumpType, identifier, shouldCommit);
        // Update packages and generate change files due to lock step bump.
        this._ensure(lockStepVersionPolicyName, shouldCommit);
        // Refresh rush configuration
        this._rushConfiguration = RushConfiguration_1.default.loadFromConfigurationFile(this._rushConfiguration.rushJsonFile);
        // Update projects based on individual policies
        const changeManager = new ChangeManager_1.default(this._rushConfiguration, this._getLockStepProjects());
        changeManager.load(this._rushConfiguration.changesFolder);
        if (changeManager.hasChanges()) {
            changeManager.validateChanges(this._versionPolicyConfiguration);
            changeManager.apply(!!shouldCommit).forEach(packageJson => {
                this._updatedProjects.set(packageJson.name, packageJson);
            });
            changeManager.updateChangelog(!!shouldCommit, this._updatedProjects);
        }
    }
    get updatedProjects() {
        return this._updatedProjects;
    }
    get changeFiles() {
        return this._changeFiles;
    }
    _ensure(versionPolicyName, shouldCommit) {
        this._updateVersionsByPolicy(versionPolicyName);
        // Update all dependencies if needed.
        this._updateDependencies();
        if (shouldCommit) {
            this._updatePackageJsonFiles();
            this._changeFiles.forEach((changeFile) => {
                changeFile.writeSync();
            });
        }
    }
    _getLockStepProjects() {
        const lockStepVersionPolicyNames = new Set();
        this._versionPolicyConfiguration.versionPolicies.forEach((versionPolicy) => {
            if (versionPolicy instanceof VersionPolicy_1.LockStepVersionPolicy) {
                lockStepVersionPolicyNames.add(versionPolicy.policyName);
            }
        });
        const lockStepProjectNames = new Set();
        this._rushConfiguration.projects.forEach((rushProject) => {
            if (lockStepVersionPolicyNames.has(rushProject.versionPolicyName)) {
                lockStepProjectNames.add(rushProject.packageName);
            }
        });
        return lockStepProjectNames;
    }
    _updateVersionsByPolicy(versionPolicyName) {
        // Update versions based on version policy
        this._rushConfiguration.projects.forEach(rushProject => {
            const projectVersionPolicyName = rushProject.versionPolicyName;
            if (projectVersionPolicyName &&
                (!versionPolicyName || projectVersionPolicyName === versionPolicyName)) {
                const versionPolicy = this._versionPolicyConfiguration.getVersionPolicy(projectVersionPolicyName);
                const updatedProject = versionPolicy.ensure(rushProject.packageJson);
                if (updatedProject) {
                    this._updatedProjects.set(updatedProject.name, updatedProject);
                    // No need to create an entry for prerelease version bump.
                    if (!this._isPrerelease(updatedProject.version)) {
                        this._addChangeInfo(updatedProject.name, [this._createChangeInfo(updatedProject, rushProject)]);
                    }
                }
            }
        });
    }
    _isPrerelease(version) {
        return !!semver.prerelease(version);
    }
    _addChangeInfo(packageName, changeInfos) {
        if (!changeInfos.length) {
            return;
        }
        let changeFile = this._changeFiles.get(packageName);
        if (!changeFile) {
            changeFile = new ChangeFile_1.ChangeFile({
                changes: [],
                packageName: packageName,
                email: this._userEmail
            }, this._rushConfiguration);
            this._changeFiles.set(packageName, changeFile);
        }
        changeInfos.forEach((changeInfo) => {
            changeFile.addChange(changeInfo);
        });
    }
    _updateDependencies() {
        this._rushConfiguration.projects.forEach(rushProject => {
            let clonedProject = this._updatedProjects.get(rushProject.packageName);
            let projectVersionChanged = true;
            if (!clonedProject) {
                clonedProject = lodash_1.cloneDeep(rushProject.packageJson);
                projectVersionChanged = false;
            }
            this._updateProjectAllDependencies(rushProject, clonedProject, projectVersionChanged);
        });
    }
    _updateProjectAllDependencies(rushProject, clonedProject, projectVersionChanged) {
        if (!clonedProject.dependencies && !clonedProject.devDependencies) {
            return;
        }
        const changes = [];
        let updated = false;
        if (this._updateProjectDependencies(clonedProject.dependencies, changes, clonedProject, rushProject, projectVersionChanged)) {
            updated = true;
        }
        if (this._updateProjectDependencies(clonedProject.devDependencies, changes, clonedProject, rushProject, projectVersionChanged)) {
            updated = true;
        }
        if (updated) {
            this._updatedProjects.set(clonedProject.name, clonedProject);
            this._addChangeInfo(clonedProject.name, changes);
        }
    }
    _updateProjectDependencies(dependencies, changes, clonedProject, rushProject, projectVersionChanged) {
        if (!dependencies) {
            return false;
        }
        let updated = false;
        this._updatedProjects.forEach((updatedDependentProject, updatedDependentProjectName) => {
            if (dependencies[updatedDependentProjectName]) {
                if (rushProject.cyclicDependencyProjects.has(updatedDependentProjectName)) {
                    // Skip if cyclic
                    console.log(`Found cyclic ${rushProject.packageName} ${updatedDependentProjectName}`);
                    return;
                }
                const oldDependencyVersion = dependencies[updatedDependentProjectName];
                const newDependencyVersion = PublishUtilities_1.default.getNewDependencyVersion(dependencies, updatedDependentProjectName, updatedDependentProject.version);
                if (newDependencyVersion !== oldDependencyVersion) {
                    updated = true;
                    if (rushProject.shouldPublish) {
                        this._trackDependencyChange(changes, clonedProject, projectVersionChanged, updatedDependentProject, updatedDependentProjectName, oldDependencyVersion, newDependencyVersion);
                    }
                    dependencies[updatedDependentProjectName] = newDependencyVersion;
                }
            }
        });
        return updated;
    }
    _trackDependencyChange(changes, clonedProject, projectVersionChanged, updatedDependentProject, updatedDependentProjectName, oldDependencyVersion, newDependencyVersion) {
        if (!semver.satisfies(updatedDependentProject.version, oldDependencyVersion) && !projectVersionChanged) {
            this._addChange(changes, {
                changeType: ChangeManagement_1.ChangeType.patch,
                packageName: clonedProject.name
            });
        }
        // If current version is not a prerelease version and new dependency is also not a prerelease version,
        // add change entry. Otherwise, too many changes will be created for frequent releases.
        if (!this._isPrerelease(updatedDependentProject.version) && !this._isPrerelease(clonedProject.version)) {
            this._addChange(changes, {
                changeType: ChangeManagement_1.ChangeType.dependency,
                comment: `Dependency ${updatedDependentProjectName} version bump from ${oldDependencyVersion}` +
                    ` to ${newDependencyVersion}.`,
                packageName: clonedProject.name
            });
        }
    }
    _addChange(changes, newChange) {
        const exists = changes.some((changeInfo) => {
            return (changeInfo.author === newChange.author &&
                changeInfo.changeType === newChange.changeType &&
                changeInfo.comment === newChange.comment &&
                changeInfo.commit === newChange.commit &&
                changeInfo.packageName === newChange.packageName &&
                changeInfo.type === newChange.type);
        });
        if (!exists) {
            changes.push(newChange);
        }
    }
    _updatePackageJsonFiles() {
        this._updatedProjects.forEach((newPackageJson, packageName) => {
            const rushProject = this._rushConfiguration.getProjectByName(packageName);
            // Update package.json
            if (rushProject) {
                const packagePath = path.join(rushProject.projectFolder, 'package.json');
                fsx.writeFileSync(packagePath, JSON.stringify(newPackageJson, undefined, 2), { encoding: 'utf8' });
            }
        });
    }
    _createChangeInfo(newPackageJson, rushProject) {
        return {
            changeType: ChangeManagement_1.ChangeType.none,
            newVersion: newPackageJson.version,
            packageName: newPackageJson.name,
            comment: `Package version bump from ${rushProject.packageJson.version} to ${newPackageJson.version}` +
                ` by version policy`
        };
    }
}
exports.VersionManager = VersionManager;

//# sourceMappingURL=VersionManager.js.map
