{"version":3,"sources":["cli/utilities/PackageChangeAnalyzer.ts"],"names":[],"mappings":"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","file":"cli/utilities/PackageChangeAnalyzer.js","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as path from 'path';\r\n\r\nimport {\r\n  getPackageDeps,\r\n  IPackageDeps\r\n} from '@microsoft/package-deps-hash';\r\n\r\nimport RushConfiguration from '../../data/RushConfiguration';\r\nimport { RushConstants } from '../../RushConstants';\r\n\r\nexport class PackageChangeAnalyzer {\r\n  public static _instance: PackageChangeAnalyzer | undefined;\r\n\r\n  // Allow this function to be overwritten during unit tests\r\n  public static getPackageDeps: (path: string, ignoredFiles: string[]) => IPackageDeps;\r\n  public static rushConfig: RushConfiguration;\r\n\r\n  private _data: Map<string, IPackageDeps>;\r\n\r\n  public static get instance(): PackageChangeAnalyzer {\r\n    if (!PackageChangeAnalyzer._instance) {\r\n      PackageChangeAnalyzer._instance = new PackageChangeAnalyzer();\r\n    }\r\n    return PackageChangeAnalyzer._instance;\r\n  }\r\n\r\n  public static reset(): void {\r\n    PackageChangeAnalyzer._instance = undefined;\r\n  }\r\n\r\n  public constructor() {\r\n    this._data = this.getData();\r\n  }\r\n\r\n  public getPackageDepsHash(projectName: string): IPackageDeps | undefined {\r\n    if (!this._data) {\r\n      this._data = this.getData();\r\n    }\r\n\r\n    return this._data.get(projectName);\r\n  }\r\n\r\n  private getData(): Map<string, IPackageDeps> {\r\n    // If we are not in a unit test, use the correct resources\r\n    if (!PackageChangeAnalyzer.getPackageDeps) {\r\n      PackageChangeAnalyzer.getPackageDeps = getPackageDeps;\r\n    }\r\n    if (!PackageChangeAnalyzer.rushConfig) {\r\n      PackageChangeAnalyzer.rushConfig = RushConfiguration.loadFromDefaultLocation();\r\n    }\r\n\r\n    const projectHashDeps: Map<string, IPackageDeps> = new Map<string, IPackageDeps>();\r\n\r\n    // pre-populate the map with the projects from the config\r\n    for (const project of PackageChangeAnalyzer.rushConfig.projects) {\r\n      projectHashDeps.set(project.packageName, {\r\n        files: {}\r\n      });\r\n    }\r\n\r\n    const noProjectHashes: { [key: string]: string } = {};\r\n\r\n    // Load the package deps hash for the whole repository\r\n    const repoDeps: IPackageDeps = PackageChangeAnalyzer.getPackageDeps(\r\n      PackageChangeAnalyzer.rushConfig.rushJsonFolder, [RushConstants.packageDepsFilename]);\r\n\r\n    // Sort each project folder into its own package deps hash\r\n    Object.keys(repoDeps.files).forEach((filepath: string) => {\r\n      const fileHash: string = repoDeps.files[filepath];\r\n\r\n      const projectName: string | undefined = this._getProjectForFile(filepath);\r\n\r\n      // If we found a project for the file, go ahead and store this file's hash\r\n      if (projectName) {\r\n        projectHashDeps.get(projectName)!.files[filepath] = fileHash;\r\n      } else {\r\n        noProjectHashes[filepath] = fileHash;\r\n      }\r\n    });\r\n\r\n    /* Incremental Build notes:\r\n     *\r\n     * Temporarily revert below code in favor of replacing this solution with something more\r\n     * flexible. Idea is essentially that we should have gulp-core-build (or other build tool)\r\n     * create the package-deps.json. The build tool would default to using the 'simple'\r\n     * algorithm (e.g. only files that are in a project folder are associated with the project), however it would\r\n     * also provide a hook which would allow certain tasks to modify the package-deps-hash before being written.\r\n     * At the end of the build, a we would create a package-deps.json file like so:\r\n     *\r\n     *  {\r\n     *    commandLine: [\"--production\"],\r\n     *    files: {\r\n     *      \"src/index.ts\": \"478789a7fs8a78989afd8\",\r\n     *      \"src/fileOne.ts\": \"a8sfa8979871fdjiojlk\",\r\n     *      \"common/api/review\": \"324598afasfdsd\",     // this entry was added by the API Extractor task (for example)\r\n     *      \"node_modules.json\": \"3428789dsafdsfaf\"    // this is a file which will be created by rush link describing\r\n     *                                                 //   the state of the node_modules folder\r\n     *    }\r\n     *  }\r\n     *\r\n     * Verifying this file should be fairly straightforward, we would simply need to check if:\r\n     *   A) no files were added or deleted from the current folder\r\n     *   B) all file hashes match\r\n     *   C) the node_modules hash/contents match\r\n     *   D) the command line parameters match or are compatible\r\n     *\r\n     *   Notes:\r\n     *   * We need to store the command line arguments, which is currently done by rush instead of GCB\r\n     *   * We need to store the hash/text of the a file which describes the state of the node_modules folder\r\n     *   * The package-deps.json should be a complete list of dependencies, and it should be extremely cheap\r\n     *       to validate/check the file (even if creating it is more computationally costly).\r\n     */\r\n\r\n    // Add the \"NO_PROJECT\" files to every project's dependencies\r\n    // for (const project of PackageChangeAnalyzer.rushConfig.projects) {\r\n    //  Object.keys(noProjectHashes).forEach((filepath: string) => {\r\n    //    const fileHash: string = noProjectHashes[filepath];\r\n    //    projectHashDeps.get(project.packageName).files[filepath] = fileHash;\r\n    //  });\r\n    // }\r\n\r\n    return projectHashDeps;\r\n  }\r\n\r\n  private _getProjectForFile(filepath: string): string | undefined {\r\n    for (const project of PackageChangeAnalyzer.rushConfig.projects) {\r\n      if (this._fileExistsInFolder(filepath, project.projectRelativeFolder)) {\r\n        return project.packageName;\r\n      }\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  private _fileExistsInFolder(filePath: string, folderPath: string): boolean {\r\n    const relativePath: string = path.relative(folderPath, filePath);\r\n\r\n    // if the file exists in the folder, relativePath will not start with \"..\"\r\n    return relativePath.split(path.sep)[0] !== '..';\r\n  }\r\n}"],"sourceRoot":"..\\..\\..\\src"}