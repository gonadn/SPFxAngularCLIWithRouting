"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const path = require("path");
const semver = require("semver");
const PublishUtilities_1 = require("./PublishUtilities");
const ChangeManagement_1 = require("../../data/ChangeManagement");
const CHANGELOG_JSON = 'CHANGELOG.json';
const CHANGELOG_MD = 'CHANGELOG.md';
const EOL = '\n';
class ChangelogGenerator {
    /**
     * Updates the appropriate changelogs with the given changes.
     */
    static updateChangelogs(allChanges, allProjects, shouldCommit) {
        const updatedChangeLogs = [];
        for (const packageName in allChanges) {
            if (allChanges.hasOwnProperty(packageName)) {
                const project = allProjects.get(packageName);
                // Changelogs should only be generated for publishable projects.
                // Do not update changelog or delete the change files for prerelease.
                // Save them for the official release.
                if (!!project && project.shouldPublish && !semver.prerelease(project.packageJson.version)) {
                    const changeLog = ChangelogGenerator.updateIndividualChangelog(allChanges[packageName], project.projectFolder, shouldCommit);
                    if (changeLog) {
                        updatedChangeLogs.push(changeLog);
                    }
                }
            }
        }
        return updatedChangeLogs;
    }
    /**
     * Fully regenerate the markdown files based on the current json files.
     */
    static regenerateChangelogs(allProjects) {
        allProjects.forEach(project => {
            const markdownPath = path.resolve(project.projectFolder, CHANGELOG_MD);
            const markdownJSONPath = path.resolve(project.projectFolder, CHANGELOG_JSON);
            if (fs.existsSync(markdownPath)) {
                console.log('Found: ' + markdownPath);
                if (!fs.existsSync(markdownJSONPath)) {
                    throw new Error('A CHANGELOG.md without json: ' + markdownPath);
                }
                const changelog = ChangelogGenerator._getChangelog(project.packageName, project.projectFolder);
                fs.writeFileSync(path.join(project.projectFolder, CHANGELOG_MD), ChangelogGenerator._translateToMarkdown(changelog), { encoding: 'utf8' });
            }
        });
    }
    /**
     * Updates an individual changelog for a single project.
     */
    static updateIndividualChangelog(change, projectFolder, shouldCommit, forceUpdate) {
        const changelog = ChangelogGenerator._getChangelog(change.packageName, projectFolder);
        if (!changelog.entries.some(entry => entry.version === change.newVersion)) {
            const changelogEntry = {
                version: change.newVersion,
                tag: PublishUtilities_1.default.createTagname(change.packageName, change.newVersion),
                date: new Date().toUTCString(),
                comments: {}
            };
            change.changes.forEach(individualChange => {
                if (individualChange.comment) {
                    // Initialize the comments array only as necessary.
                    const changeTypeString = ChangeManagement_1.ChangeType[individualChange.changeType];
                    const comments = changelogEntry.comments[changeTypeString] =
                        changelogEntry.comments[changeTypeString] || [];
                    comments.push({
                        author: individualChange.author,
                        commit: individualChange.commit,
                        comment: individualChange.comment
                    });
                }
            });
            // Add the changelog entry to the start of the list.
            changelog.entries.unshift(changelogEntry);
            const changelogFilename = path.join(projectFolder, CHANGELOG_JSON);
            console.log(`${EOL}* ${shouldCommit ? 'APPLYING' : 'DRYRUN'}: ` +
                `Changelog update for "${change.packageName}@${change.newVersion}".`);
            if (shouldCommit) {
                // Write markdown transform.
                fs.writeFileSync(changelogFilename, JSON.stringify(changelog, undefined, 2), { encoding: 'utf8' });
                fs.writeFileSync(path.join(projectFolder, CHANGELOG_MD), ChangelogGenerator._translateToMarkdown(changelog), { encoding: 'utf8' });
            }
            return changelog;
        }
        // change log not updated.
        return undefined;
    }
    /**
     * Loads the changelog json from disk, or creates a new one if there isn't one.
     */
    static _getChangelog(packageName, projectFolder) {
        const changelogFilename = path.join(projectFolder, CHANGELOG_JSON);
        let changelog = undefined;
        // Try to read the existing changelog.
        if (fs.existsSync(changelogFilename)) {
            changelog = JSON.parse(fs.readFileSync(changelogFilename, 'utf8'));
        }
        if (!changelog) {
            changelog = {
                name: packageName,
                entries: []
            };
        }
        else {
            // Force the changelog name to be same as package name.
            // In case the package has been renamed but change log name is not updated.
            changelog.name = packageName;
        }
        return changelog;
    }
    /**
     * Translates the given changelog json object into a markdown string.
     */
    static _translateToMarkdown(changelog) {
        let markdown = [
            `# Change Log - ${changelog.name}`,
            '',
            `This log was last generated on ${new Date().toUTCString()} and should not be manually modified.`,
            '',
            ''
        ].join(EOL);
        changelog.entries.forEach((entry, index) => {
            markdown += `## ${entry.version}${EOL}`;
            if (entry.date) {
                markdown += `${entry.date}${EOL}`;
            }
            markdown += EOL;
            let comments = '';
            comments += ChangelogGenerator._getChangeComments('Breaking changes', entry.comments[ChangeManagement_1.ChangeType[ChangeManagement_1.ChangeType.major]]);
            comments += ChangelogGenerator._getChangeComments('Minor changes', entry.comments[ChangeManagement_1.ChangeType[ChangeManagement_1.ChangeType.minor]]);
            comments += ChangelogGenerator._getChangeComments('Patches', entry.comments[ChangeManagement_1.ChangeType[ChangeManagement_1.ChangeType.patch]]);
            if (!comments) {
                markdown += ((changelog.entries.length === index + 1) ?
                    '*Initial release*' :
                    '*Version update only*') +
                    EOL + EOL;
            }
            else {
                markdown += comments;
            }
        });
        return markdown;
    }
    /**
     * Helper to return the comments string to be appends to the markdown content.
     */
    static _getChangeComments(title, commentsArray) {
        let comments = '';
        if (commentsArray) {
            comments = `### ${title}${EOL + EOL}`;
            commentsArray.forEach(comment => {
                comments += `- ${comment.comment}${EOL}`;
            });
            comments += EOL;
        }
        return comments;
    }
}
exports.default = ChangelogGenerator;

//# sourceMappingURL=ChangelogGenerator.js.map
