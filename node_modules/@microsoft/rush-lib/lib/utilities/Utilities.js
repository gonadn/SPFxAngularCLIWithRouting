"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const child_process = require("child_process");
const fsx = require("fs-extra");
const os = require("os");
const rimraf = require("rimraf");
const path = require("path");
const node_core_library_1 = require("@microsoft/node-core-library");
/**
 * @public
 */
class Utilities {
    /**
     * For a scoped NPM package name this separates the scope and name parts.  For example:
     * parseScopedPackageName('@my-scope/myproject') = { scope: '@my-scope', name: 'myproject' }
     * parseScopedPackageName('myproject') = { scope: '', name: 'myproject' }
     */
    static parseScopedPackageName(scopedName) {
        if (scopedName.substr(0, 1) !== '@') {
            return { scope: '', name: scopedName };
        }
        const slashIndex = scopedName.indexOf('/');
        if (slashIndex >= 0) {
            return { scope: scopedName.substr(0, slashIndex), name: scopedName.substr(slashIndex + 1) };
        }
        else {
            throw new Error('Invalid scoped name: ' + scopedName);
        }
    }
    /**
     * NodeJS equivalent of performance.now().
     */
    static getTimeInMs() {
        let seconds;
        let nanoseconds;
        [seconds, nanoseconds] = process.hrtime();
        return seconds * 1000 + nanoseconds / 1000000;
    }
    /**
     * Returns the values from a Set<T>
     */
    static getSetAsArray(set) {
        // When ES6 is supported, we can use Array.from() instead.
        const result = [];
        set.forEach((value) => {
            result.push(value);
        });
        return result;
    }
    /**
     * Retries a function until a timeout is reached. The function is expected to throw if it failed and
     *  should be retried.
     */
    static retryUntilTimeout(fn, maxWaitTimeMs, getTimeoutError, fnName) {
        const startTime = Utilities.getTimeInMs();
        let looped = false;
        let result;
        // tslint:disable-next-line:no-constant-condition
        while (true) {
            try {
                result = fn();
                break;
            }
            catch (e) {
                looped = true;
                const currentTime = Utilities.getTimeInMs();
                if (currentTime - startTime > maxWaitTimeMs) {
                    throw getTimeoutError(e);
                }
            }
        }
        if (looped) {
            const currentTime = Utilities.getTimeInMs();
            const totalSeconds = ((currentTime - startTime) / 1000.0).toFixed(2);
            console.log(`${fnName}() stalled for ${totalSeconds} seconds`);
        }
        return result;
    }
    /**
     * Creates the specified folder by calling fsx.mkdirsSync(), but using a
     * retry loop to recover from temporary locks that may be held by other processes.
     * If the folder already exists, no error occurs.
     */
    static createFolderWithRetry(folderName) {
        // Note: If a file exists with the same name, then we fall through and report
        // an error.
        if (Utilities.directoryExists(folderName)) {
            return;
        }
        // We need to do a simple "fs.mkdirSync(localModulesFolder)" here,
        // however if the folder we deleted above happened to contain any files,
        // then there seems to be some OS process (virus scanner?) that holds
        // a lock on the folder for a split second, which causes mkdirSync to
        // fail.  To workaround that, retry for up to 7 seconds before giving up.
        const maxWaitTimeMs = 7 * 1000;
        return Utilities.retryUntilTimeout(() => fsx.mkdirsSync(folderName), maxWaitTimeMs, (e) => new Error(`Error: ${e}${os.EOL}Often this is caused by a file lock ` +
            'from a process such as your text editor, command prompt, ' +
            'or "gulp serve"'), 'createFolderWithRetry');
    }
    /**
     * Determines if the path points to a file and that it exists.
     */
    static fileExists(filePath) {
        let exists = false;
        try {
            const lstat = fsx.lstatSync(filePath);
            exists = lstat.isFile();
        }
        catch (e) { }
        return exists;
    }
    /**
     * Determines if a path points to a directory and that it exists.
     */
    static directoryExists(directoryPath) {
        let exists = false;
        try {
            const lstat = fsx.lstatSync(directoryPath);
            exists = lstat.isDirectory();
        }
        catch (e) { }
        return exists;
    }
    /**
     * BE VERY CAREFUL CALLING THIS FUNCTION!
     * If you specify the wrong folderPath (e.g. "/"), it could potentially delete your entire
     * hard disk.
     */
    static dangerouslyDeletePath(folderPath) {
        try {
            rimraf.sync(folderPath, { disableGlob: true });
        }
        catch (e) {
            throw new Error(e.message + os.EOL + 'Often this is caused by a file lock'
                + ' from a process such as your text editor, command prompt, or "gulp serve"');
        }
    }
    /**
     * Attempts to delete a file. If it does not exist, or the path is not a file, it no-ops.
     */
    static deleteFile(filePath) {
        if (Utilities.fileExists(filePath)) {
            console.log(`Deleting: ${filePath}`);
            fsx.unlinkSync(filePath);
        }
    }
    /*
     * Returns true if outputFilename has a more recent last modified timestamp
     * than all of the inputFilenames, which would imply that we don't need to rebuild it.
     * Returns false if any of the files does not exist.
     * NOTE: The filenames can also be paths for directories, in which case the directory
     * timestamp is compared.
     */
    static isFileTimestampCurrent(outputFilename, inputFilenames) {
        if (!fsx.existsSync(outputFilename)) {
            return false;
        }
        const outputStats = fsx.statSync(outputFilename);
        for (const inputFilename of inputFilenames) {
            if (!fsx.existsSync(inputFilename)) {
                return false;
            }
            const inputStats = fsx.statSync(inputFilename);
            if (outputStats.mtime < inputStats.mtime) {
                return false;
            }
        }
        return true;
    }
    /**
     * Returns the width of the console, measured in columns
     */
    static getConsoleWidth() {
        const stdout = process.stdout;
        if (stdout && stdout.columns) {
            return stdout.columns;
        }
        return 80;
    }
    /**
     * Executes the command with the specified command-line parameters, and waits for it to complete.
     * The current directory will be set to the specified workingDirectory.
     */
    static executeCommand(command, args, workingDirectory, suppressOutput = false, environmentVariables) {
        Utilities._executeCommandInternal(command, args, workingDirectory, suppressOutput ? undefined : [0, 1, 2], environmentVariables);
    }
    /**
     * Executes the command with the specified command-line parameters, and waits for it to complete.
     * The current directory will be set to the specified workingDirectory.
     */
    static executeCommandAndCaptureOutput(command, args, workingDirectory, environmentVariables) {
        const result = Utilities._executeCommandInternal(command, args, workingDirectory, ['pipe', 'pipe', 'pipe'], environmentVariables);
        return result.stdout.toString();
    }
    /**
     * Attempts to run Utilities.executeCommand() up to maxAttempts times before giving up.
     */
    static executeCommandWithRetry(command, args, maxAttempts, workingDirectory, suppressOutput = false) {
        if (maxAttempts < 1) {
            throw new Error('The maxAttempts parameter cannot be less than 1');
        }
        let attemptNumber = 1;
        // tslint:disable-next-line:no-constant-condition
        while (true) {
            try {
                Utilities.executeCommand(command, args, workingDirectory, suppressOutput);
            }
            catch (error) {
                console.log(os.EOL + 'The command failed:');
                console.log(` ${command} ` + args.join(' '));
                console.log(`ERROR: ${error.toString()}`);
                if (attemptNumber < maxAttempts) {
                    ++attemptNumber;
                    console.log(`Trying again (attempt #${attemptNumber})...` + os.EOL);
                    continue;
                }
                else {
                    console.error(`Giving up after ${attemptNumber} attempts` + os.EOL);
                    throw error;
                }
            }
            break;
        }
    }
    /**
     * Executes the command with the specified command-line parameters, and waits for it to complete.
     * The current directory will be set to the specified workingDirectory.
     */
    static executeCommandAsync(command, args, workingDirectory, environmentVariables) {
        // This is a workaround for GitHub issue #25330.  It is not as complete as the workaround above,
        // but there doesn't seem to be an easy asynchronous solution.
        // https://github.com/nodejs/node-v0.x-archive/issues/25330
        if (fsx.existsSync(command + '.cmd')) {
            command += '.cmd';
        }
        // This is needed since we specify shell=true below:
        const escapedCommand = Utilities.escapeShellParameter(command);
        const escapedArgs = args.map((x) => Utilities.escapeShellParameter(x));
        return child_process.spawn(escapedCommand, escapedArgs, {
            cwd: workingDirectory,
            shell: true,
            env: environmentVariables
        });
    }
    /**
     * Executes the command using cmd if running on windows, or using sh if running on a non-windows OS.
     * @param command - the command to run on shell
     * @param workingDirectory - working directory for running this command
     * @param environmentVariables - environment variables for running this command
     * @beta
     */
    static executeShellCommand(command, workingDirectory, environmentVariables, captureOutput = false) {
        let shellCommand = process.env.comspec || 'cmd';
        let commandFlags = '/d /s /c';
        let useShell = true;
        if (process.platform !== 'win32') {
            shellCommand = 'sh';
            commandFlags = '-c';
            useShell = false;
        }
        const result = child_process.spawnSync(shellCommand, [commandFlags, command], {
            cwd: workingDirectory,
            shell: useShell,
            env: environmentVariables,
            stdio: captureOutput ? ['pipe', 'pipe', 'pipe'] : [0, 1, 2]
        });
        Utilities._processResult(result);
        return result;
    }
    /**
     * Executes the command using cmd if running on windows, or using sh if running on a non-windows OS.
     * @param command - the command to run on shell
     * @param workingDirectory - working directory for running this command
     * @param environmentVariables - environment variables for running this command
     * @beta
     */
    static executeShellCommandAsync(command, workingDirectory, environmentVariables, captureOutput = false) {
        let shellCommand = process.env.comspec || 'cmd';
        let commandFlags = '/d /s /c';
        let useShell = true;
        if (process.platform !== 'win32') {
            shellCommand = 'sh';
            commandFlags = '-c';
            useShell = false;
        }
        return child_process.spawn(shellCommand, [commandFlags, command], {
            cwd: workingDirectory,
            shell: useShell,
            env: environmentVariables,
            stdio: captureOutput ? ['pipe', 'pipe', 'pipe'] : [0, 1, 2]
        });
    }
    /**
     * Returns the same thing as targetString.replace(searchValue, replaceValue), except that
     * all matches are replaced, rather than just the first match.
     * @param targetString  - The string to be modified
     * @param searchValue   - The value to search for
     * @param replaceValue  - The replacement text
     */
    static getAllReplaced(targetString, searchValue, replaceValue) {
        return targetString.split(searchValue).join(replaceValue);
    }
    /**
     * For strings passed to a shell command, this adds appropriate escaping
     * to avoid misinterpretation of spaces or special characters.
     *
     * Example: 'hello there' --> '"hello there"'
     */
    static escapeShellParameter(parameter) {
        return '"' + parameter + '"';
    }
    /**
     * Installs a package by name and version in the specified directory.
     */
    static installPackageInDirectory(directory, packageName, version, tempPackageTitle, maxInstallAttempts, suppressOutput = false) {
        if (fsx.existsSync(directory)) {
            console.log('Deleting old files from ' + directory);
            Utilities.dangerouslyDeletePath(directory);
        }
        Utilities.createFolderWithRetry(directory);
        const npmPackageJson = {
            dependencies: {
                [packageName]: version
            },
            description: 'Temporary file generated by the Rush tool',
            name: tempPackageTitle,
            private: true,
            version: '0.0.0'
        };
        node_core_library_1.JsonFile.save(npmPackageJson, path.join(directory, 'package.json'));
        console.log(os.EOL + 'Running "npm install" in ' + directory);
        // NOTE: Here we use whatever version of NPM we happen to find in the PATH
        Utilities.executeCommandWithRetry('npm', ['install'], maxInstallAttempts, directory, suppressOutput);
    }
    /**
     * Executes the command with the specified command-line parameters, and waits for it to complete.
     * The current directory will be set to the specified workingDirectory.
     */
    static _executeCommandInternal(command, args, workingDirectory, stdio, environmentVariables) {
        const options = {
            cwd: workingDirectory,
            shell: true,
            stdio: stdio,
            env: environmentVariables
        };
        // This is needed since we specify shell=true below.
        // NOTE: On Windows if we escape "npm", the spawnSync() function runs something like this:
        //   [ 'C:\\Windows\\system32\\cmd.exe', '/s', '/c', '""npm" "install""' ]
        //
        // Due to a bug with Windows cmd.exe, the npm.cmd batch file's "%~dp0" variable will
        // return the current working directory instead of the batch file's directory.
        // The workaround is to not escape, npm, i.e. do this instead:
        //   [ 'C:\\Windows\\system32\\cmd.exe', '/s', '/c', '"npm "install""' ]
        //
        // We will come up with a better solution for this when we promote executeCommand()
        // into node-core-library, but for now this hack will unblock people:
        // Only escape the command if it actually contains spaces:
        const escapedCommand = command.indexOf(' ') < 0 ? command
            : Utilities.escapeShellParameter(command);
        const escapedArgs = args.map((x) => Utilities.escapeShellParameter(x));
        let result = child_process.spawnSync(escapedCommand, escapedArgs, options);
        /* tslint:disable:no-any */
        if (result.error && result.error.errno === 'ENOENT') {
            // This is a workaround for GitHub issue #25330
            // https://github.com/nodejs/node-v0.x-archive/issues/25330
            result = child_process.spawnSync(command + '.cmd', args, options);
        }
        /* tslint:enable:no-any */
        Utilities._processResult(result);
        return result;
    }
    static _processResult(result) {
        if (result.error) {
            result.error.message += os.EOL + (result.stderr ? result.stderr.toString() + os.EOL : '');
            throw result.error;
        }
        if (result.status) {
            throw new Error('The command failed with exit code ' + result.status + os.EOL +
                (result.stderr ? result.stderr.toString() : ''));
        }
    }
}
exports.default = Utilities;

//# sourceMappingURL=Utilities.js.map
