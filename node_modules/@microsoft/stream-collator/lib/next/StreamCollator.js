"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
/* istanbul ignore next */
const Stream = require("stream");
var StreamState;
(function (StreamState) {
    StreamState[StreamState["Open"] = 0] = "Open";
    StreamState[StreamState["ClosedUnwritten"] = 1] = "ClosedUnwritten";
    StreamState[StreamState["Written"] = 2] = "Written";
})(StreamState || (StreamState = {}));
class StreamInfo {
    constructor(stream) {
        this.stream = stream;
        this.buffer = [];
        this.state = StreamState.Open;
    }
    flush() {
        const data = this.buffer.join('');
        this.buffer = [];
        return data;
    }
}
/**
 * A class which manages the output of multiple threads.
 */
class StreamCollator extends Stream.Readable {
    constructor() {
        super(...arguments);
        this._streams = [];
        this._activeStream = undefined;
    }
    _read() {
        /* no-op */
    }
    /**
     * Registers a stream into the list of active buffers.
     */
    register(stream) {
        const streamState = new StreamInfo(stream);
        stream.on('end', this._streamEnd(streamState));
        stream.on('data', this._streamData(streamState));
        this._streams.push(streamState);
        this._ensureActiveTask();
    }
    /**
     * Locates a suitable stream which could be set as the new active stream
     */
    _findActiveTaskCandidate() {
        for (const stream of this._streams) {
            if (stream.state === StreamState.Open && stream !== this._activeStream) {
                return stream;
            }
        }
    }
    /**
     * Ensures that a stream is set as active, will set the passed in stream as the active stream if none exists
     */
    _ensureActiveTask() {
        if (!this._activeStream) {
            const stream = this._findActiveTaskCandidate();
            this._activeStream = stream;
            // In some cases there may be no streams which we can make active
            if (stream) {
                this._writeTaskBuffer(stream);
            }
        }
    }
    /**
     * Flushes a streams buffer and writes it to disk
     */
    _writeTaskBuffer(stream) {
        if (stream.buffer.length) {
            this.push(stream.flush());
        }
    }
    /**
     * The on('data') callback handler, which either writes or buffers the data
     */
    _streamData(stream) {
        return (data) => {
            if (this._activeStream === stream) {
                this.push(data.toString());
            }
            else {
                stream.buffer.push(data.toString());
            }
        };
    }
    /**
     * Marks a stream as completed. There are 3 cases:
     *  - If the stream was the active stream, also write out all completed, unwritten streams
     *  - If there is no active stream, write the output to the screen
     *  - If there is an active stream, mark the stream as completed and wait for active stream to complete
     */
    _streamEnd(stream) {
        return () => {
            if (stream === this._activeStream) {
                this._writeAllCompletedTasks();
                stream.state = StreamState.Written;
                this._activeStream = undefined;
                this._ensureActiveTask();
            }
            else {
                stream.state = StreamState.ClosedUnwritten;
            }
            // Close this if all substreams are closed
            if (this._areStreamsClosedAndWritten()) {
                this.push(null); // tslint:disable-line
            }
        };
    }
    /**
     * Helper function which returns true if all streams have been closed
     */
    _areStreamsClosedAndWritten() {
        for (const streamInfo of this._streams) {
            if (streamInfo.state !== StreamState.Written) {
                return false;
            }
        }
        return true;
    }
    /**
     * Helper function which writes all completed streams
     */
    _writeAllCompletedTasks() {
        for (const stream of this._streams) {
            if (stream && stream.state === StreamState.ClosedUnwritten) {
                this._writeTaskBuffer(stream);
                stream.state = StreamState.Written;
            }
        }
    }
}
exports.default = StreamCollator;

//# sourceMappingURL=StreamCollator.js.map
