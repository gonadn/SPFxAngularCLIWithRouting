"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
/// <reference types="mocha" />
const chai_1 = require("chai");
const colors = require("colors");
const os = require("os");
const Interleaver_1 = require("../Interleaver");
class StringStream {
    constructor() {
        this._buffer = [];
    }
    write(text) {
        this._buffer.push(text);
    }
    read() {
        return this._buffer.join('');
    }
    reset() {
        this._buffer = [];
    }
}
const stdout = new StringStream();
Interleaver_1.default.setStdOut(stdout);
describe('Interleaver tests', () => {
    // Reset task information before each test
    beforeEach(() => {
        Interleaver_1.default.reset();
        stdout.reset();
    });
    describe('Testing register and close', () => {
        it('cannot be directly instantiated', (done) => {
            chai_1.assert.throws(() => {
                /* tslint:disable:no-unused-variable */
                const a = new Interleaver_1.default();
                /* tslint:enable:no-unused-variable */
            });
            done();
        });
        it('can register a task', (done) => {
            const helloWorldWriter = Interleaver_1.default.registerTask('Hello World');
            chai_1.assert.isObject(helloWorldWriter);
            done();
        });
        it('should not let you register two tasks with the same name', (done) => {
            const taskName = 'Hello World';
            chai_1.assert.doesNotThrow(() => { Interleaver_1.default.registerTask(taskName); });
            chai_1.assert.throws(() => { Interleaver_1.default.registerTask(taskName); });
            done();
        });
        it('should not let you close a task twice', (done) => {
            const taskName = 'Hello World';
            const task = Interleaver_1.default.registerTask(taskName);
            task.close();
            chai_1.assert.throws(task.close);
            done();
        });
        it('should not let you write to a closed task', (done) => {
            const taskName = 'Hello World';
            const task = Interleaver_1.default.registerTask(taskName);
            task.close();
            chai_1.assert.throws(() => { task.write('1'); });
            done();
        });
    });
    describe('Testing write functions', () => {
        it('writeLine should add a newline', (done) => {
            const taskA = Interleaver_1.default.registerTask('A');
            const text = 'Hello World';
            taskA.writeLine(text);
            chai_1.assert.equal(taskA.getStdOutput(), text + os.EOL);
            done();
        });
        it('should redirect warnings to stdout in yellow', (done) => {
            const taskA = Interleaver_1.default.registerTask('A');
            const warning = 'Warning - This is a warning';
            taskA.writeError(warning);
            chai_1.assert.equal(stdout.read(), colors.yellow(warning));
            taskA.close();
            chai_1.assert.equal(taskA.getStdOutput(), warning);
            chai_1.assert.equal(taskA.getStdError(), '');
            done();
        });
        it('should write errors in red', (done) => {
            const taskA = Interleaver_1.default.registerTask('A');
            const error = 'Critical error';
            taskA.writeError(error);
            chai_1.assert.equal(stdout.read(), colors.red(error));
            taskA.close();
            chai_1.assert.equal(taskA.getStdOutput(), '');
            chai_1.assert.equal(taskA.getStdError(), error);
            done();
        });
    });
    describe('Testing that output is interleaved', () => {
        it('should not write non-active tasks to stdout', (done) => {
            const taskA = Interleaver_1.default.registerTask('A');
            const taskB = Interleaver_1.default.registerTask('B');
            taskA.write('1');
            chai_1.assert.equal(stdout.read(), '1');
            taskB.write('2');
            chai_1.assert.equal(stdout.read(), '1');
            taskA.write('3');
            chai_1.assert.equal(stdout.read(), '13');
            taskA.close();
            chai_1.assert.equal(stdout.read(), '13');
            taskB.close();
            chai_1.assert.equal(stdout.read(), '132');
            chai_1.assert.equal(taskA.getStdOutput(), '13');
            chai_1.assert.equal(taskB.getStdOutput(), '2');
            done();
        });
        it('should not write anything when in quiet mode', (done) => {
            const taskA = Interleaver_1.default.registerTask('A', true);
            const taskB = Interleaver_1.default.registerTask('B', true);
            taskA.write('1');
            chai_1.assert.equal(stdout.read(), '');
            taskB.write('2');
            chai_1.assert.equal(stdout.read(), '');
            taskA.write('3');
            chai_1.assert.equal(stdout.read(), '');
            taskA.close();
            chai_1.assert.equal(stdout.read(), '');
            taskB.close();
            chai_1.assert.equal(stdout.read(), '');
            chai_1.assert.equal(taskA.getStdOutput(), '13');
            chai_1.assert.equal(taskB.getStdOutput(), '2');
            done();
        });
        it('should update the active task once the active task is closed', (done) => {
            const taskA = Interleaver_1.default.registerTask('A');
            const taskB = Interleaver_1.default.registerTask('B');
            taskA.write('1');
            chai_1.assert.equal(stdout.read(), '1');
            taskA.close();
            chai_1.assert.equal(stdout.read(), '1');
            taskB.write('2');
            chai_1.assert.equal(stdout.read(), '12');
            taskB.close();
            chai_1.assert.equal(stdout.read(), '12');
            chai_1.assert.equal(taskA.getStdOutput(), '1');
            chai_1.assert.equal(taskB.getStdOutput(), '2');
            done();
        });
        it('should write completed tasks after the active task is completed', (done) => {
            const taskA = Interleaver_1.default.registerTask('A');
            const taskB = Interleaver_1.default.registerTask('B');
            taskA.write('1');
            chai_1.assert.equal(stdout.read(), '1');
            taskB.write('2');
            chai_1.assert.equal(stdout.read(), '1');
            taskB.close();
            chai_1.assert.equal(stdout.read(), '1');
            taskA.close();
            chai_1.assert.equal(stdout.read(), '12');
            chai_1.assert.equal(taskA.getStdOutput(), '1');
            chai_1.assert.equal(taskB.getStdOutput(), '2');
            done();
        });
    });
});

//# sourceMappingURL=Interleaver.test.js.map
