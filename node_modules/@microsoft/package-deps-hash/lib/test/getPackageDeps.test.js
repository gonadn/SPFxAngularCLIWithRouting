"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const getPackageDeps_1 = require("../getPackageDeps");
const chai_1 = require("chai");
const path = require("path");
const fs = require("fs");
const child_process_1 = require("child_process");
const SOURCE_PATH = path.join(__dirname).replace(path.join('lib', 'test'), path.join('src', 'test'));
const TEST_PROJECT_PATH = path.join(SOURCE_PATH, 'testProject');
const NESTED_TEST_PROJECT_PATH = path.join(SOURCE_PATH, 'nestedTestProject');
describe('parseGitLsTree', () => {
    it('can handle a blob', (done) => {
        const filename = 'src/typings/tsd.d.ts';
        const hash = '3451bccdc831cb43d7a70ed8e628dcf9c7f888c8';
        const output = `100644 blob ${hash}\t${filename}`;
        const changes = getPackageDeps_1.parseGitLsTree(output);
        chai_1.assert.equal(changes.size, 1, 'Expect there to be exactly 1 change');
        chai_1.assert.equal(changes.get(filename), hash, `Expect the hash to be ${hash}`);
        done();
    });
    it('can handle a submodule', (done) => {
        const filename = 'web-build-tools';
        const hash = 'c5880bf5b0c6c1f2e2c43c95beeb8f0a808e8bac';
        const output = `160000 commit ${hash}\t${filename}`;
        const changes = getPackageDeps_1.parseGitLsTree(output);
        chai_1.assert.equal(changes.size, 1, 'Expect there to be exactly 1 change');
        chai_1.assert.equal(changes.get(filename), hash, `Expect the hash to be ${hash}`);
        done();
    });
    it('can handle multiple lines', (done) => {
        const filename1 = 'src/typings/tsd.d.ts';
        const hash1 = '3451bccdc831cb43d7a70ed8e628dcf9c7f888c8';
        const filename2 = 'src/foo bar/tsd.d.ts';
        const hash2 = '0123456789abcdef1234567890abcdef01234567';
        const output = `100644 blob ${hash1}\t${filename1}\n100666 blob ${hash2}\t${filename2}`;
        const changes = getPackageDeps_1.parseGitLsTree(output);
        chai_1.assert.equal(changes.size, 2, 'Expect there to be exactly 2 changes');
        chai_1.assert.equal(changes.get(filename1), hash1, `Expect the hash to be ${hash1}`);
        chai_1.assert.equal(changes.get(filename2), hash2, `Expect the hash to be ${hash2}`);
        done();
    });
    it('throws with malformed input', (done) => {
        chai_1.assert.throws(getPackageDeps_1.parseGitLsTree.bind(undefined, 'some super malformed input'));
        done();
    });
});
describe('getPackageDeps', () => {
    it('can parse commited file', (done) => {
        const results = getPackageDeps_1.getPackageDeps(TEST_PROJECT_PATH);
        try {
            const expectedFiles = {
                'file1.txt': 'c7b2f707ac99ca522f965210a7b6b0b109863f34',
                'package.json': '33703d582243a41bdebff8ee7dd046a01fc054b9'
            };
            const filePaths = Object.keys(results.files).sort();
            filePaths.forEach(filePath => (chai_1.expect(results.files[filePath])
                .equals(expectedFiles[filePath], `path: ${filePath}`)));
        }
        catch (e) {
            return done(e);
        }
        done();
    });
    it('can handle files in subfolders', (done) => {
        const results = getPackageDeps_1.getPackageDeps(NESTED_TEST_PROJECT_PATH);
        try {
            const expectedFiles = {
                'src/file 1.txt': 'c7b2f707ac99ca522f965210a7b6b0b109863f34',
                'package.json': '33703d582243a41bdebff8ee7dd046a01fc054b9'
            };
            const filePaths = Object.keys(results.files).sort();
            filePaths.forEach(filePath => (chai_1.expect(results.files[filePath])
                .equals(expectedFiles[filePath], `path: ${filePath}`)));
        }
        catch (e) {
            return done(e);
        }
        done();
    });
    it('can can handle adding one file', (done) => {
        const tempFilePath = path.join(TEST_PROJECT_PATH, 'a.txt');
        fs.writeFileSync(tempFilePath, 'a');
        function _done(e) {
            fs.unlinkSync(tempFilePath);
            done(e);
        }
        const results = getPackageDeps_1.getPackageDeps(TEST_PROJECT_PATH);
        try {
            const expectedFiles = {
                'a.txt': '2e65efe2a145dda7ee51d1741299f848e5bf752e',
                'file1.txt': 'c7b2f707ac99ca522f965210a7b6b0b109863f34',
                'package.json': '33703d582243a41bdebff8ee7dd046a01fc054b9'
            };
            const filePaths = Object.keys(results.files).sort();
            filePaths.forEach(filePath => (chai_1.expect(results.files[filePath])
                .equals(expectedFiles[filePath], `path: ${filePath}`)));
        }
        catch (e) {
            return _done(e);
        }
        _done();
    });
    it('can can handle adding two files', (done) => {
        const tempFilePath1 = path.join(TEST_PROJECT_PATH, 'a.txt');
        const tempFilePath2 = path.join(TEST_PROJECT_PATH, 'b.txt');
        fs.writeFileSync(tempFilePath1, 'a');
        fs.writeFileSync(tempFilePath2, 'a');
        function _done(e) {
            fs.unlinkSync(tempFilePath1);
            fs.unlinkSync(tempFilePath2);
            done(e);
        }
        const results = getPackageDeps_1.getPackageDeps(TEST_PROJECT_PATH);
        try {
            const expectedFiles = {
                'a.txt': '2e65efe2a145dda7ee51d1741299f848e5bf752e',
                'b.txt': '2e65efe2a145dda7ee51d1741299f848e5bf752e',
                'file1.txt': 'c7b2f707ac99ca522f965210a7b6b0b109863f34',
                'package.json': '33703d582243a41bdebff8ee7dd046a01fc054b9'
            };
            const filePaths = Object.keys(results.files).sort();
            filePaths.forEach(filePath => (chai_1.expect(results.files[filePath])
                .equals(expectedFiles[filePath], `path: ${filePath}`)));
        }
        catch (e) {
            return _done(e);
        }
        _done();
    });
    it('can can handle removing one file', (done) => {
        const testFilePath = path.join(TEST_PROJECT_PATH, 'file1.txt');
        fs.unlinkSync(testFilePath);
        function _done(e) {
            child_process_1.execSync(`git checkout ${testFilePath}`);
            done(e);
        }
        const results = getPackageDeps_1.getPackageDeps(TEST_PROJECT_PATH);
        try {
            const expectedFiles = {
                'package.json': '33703d582243a41bdebff8ee7dd046a01fc054b9'
            };
            const filePaths = Object.keys(results.files).sort();
            filePaths.forEach(filePath => (chai_1.expect(results.files[filePath])
                .equals(expectedFiles[filePath], `path: ${filePath}`)));
        }
        catch (e) {
            return _done(e);
        }
        _done();
    });
    it('can can handle changing one file', (done) => {
        const testFilePath = path.join(TEST_PROJECT_PATH, 'file1.txt');
        fs.writeFileSync(testFilePath, 'abc');
        function _done(e) {
            child_process_1.execSync(`git checkout ${testFilePath}`);
            done(e);
        }
        const results = getPackageDeps_1.getPackageDeps(TEST_PROJECT_PATH);
        try {
            const expectedFiles = {
                'file1.txt': 'f2ba8f84ab5c1bce84a7b441cb1959cfc7093b7f',
                'package.json': '33703d582243a41bdebff8ee7dd046a01fc054b9'
            };
            const filePaths = Object.keys(results.files).sort();
            filePaths.forEach(filePath => (chai_1.expect(results.files[filePath])
                .equals(expectedFiles[filePath], `path: ${filePath}`)));
        }
        catch (e) {
            return _done(e);
        }
        _done();
    });
    it('can exclude a committed file', (done) => {
        const results = getPackageDeps_1.getPackageDeps(TEST_PROJECT_PATH, ['file1.txt']);
        try {
            const expectedFiles = {
                'package.json': '33703d582243a41bdebff8ee7dd046a01fc054b9'
            };
            const filePaths = Object.keys(results.files).sort();
            filePaths.forEach(filePath => (chai_1.expect(results.files[filePath])
                .equals(expectedFiles[filePath], `path: ${filePath}`)));
        }
        catch (e) {
            return done(e);
        }
        done();
    });
    it('can exclude an added file', (done) => {
        const tempFilePath = path.join(TEST_PROJECT_PATH, 'a.txt');
        fs.writeFileSync(tempFilePath, 'a');
        function _done(e) {
            fs.unlinkSync(tempFilePath);
            done(e);
        }
        const results = getPackageDeps_1.getPackageDeps(TEST_PROJECT_PATH, ['a.txt']);
        try {
            const expectedFiles = {
                'file1.txt': 'c7b2f707ac99ca522f965210a7b6b0b109863f34',
                'package.json': '33703d582243a41bdebff8ee7dd046a01fc054b9'
            };
            const filePaths = Object.keys(results.files).sort();
            chai_1.expect(filePaths.length).to.equal(Object.keys(expectedFiles).length, 'filePaths.length');
            filePaths.forEach(filePath => (chai_1.expect(results.files[filePath])
                .equals(expectedFiles[filePath], `path: ${filePath}`)));
        }
        catch (e) {
            return _done(e);
        }
        _done();
    });
});

//# sourceMappingURL=getPackageDeps.test.js.map
