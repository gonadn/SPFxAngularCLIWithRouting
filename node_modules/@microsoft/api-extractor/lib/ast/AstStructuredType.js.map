{"version":3,"sources":["ast/AstStructuredType.ts"],"names":[],"mappings":"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","file":"ast/AstStructuredType.js","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\n/* tslint:disable:no-bitwise */\r\n\r\nimport * as ts from 'typescript';\r\nimport { ReleaseTag } from '../aedoc/ReleaseTag';\r\nimport { Markup } from '../markup/Markup';\r\nimport AstMethod from './AstMethod';\r\nimport AstProperty from './AstProperty';\r\nimport AstItem, { AstItemKind, IAstItemOptions } from './AstItem';\r\nimport AstItemContainer from './AstItemContainer';\r\nimport TypeScriptHelpers from '../TypeScriptHelpers';\r\nimport PrettyPrinter from '../PrettyPrinter';\r\n\r\n/**\r\n  * This class is part of the AstItem abstract syntax tree.  It represents a class,\r\n  * interface, or type literal expression.\r\n  */\r\nexport default class AstStructuredType extends AstItemContainer {\r\n  public implements?: string;\r\n  public extends?: string;\r\n\r\n  /**\r\n   * An array of type parameters for generic classes\r\n   * Example: Foo<T, S> => ['T', 'S']\r\n   */\r\n  public typeParameters: string[];\r\n\r\n  /**\r\n   * The data type of the AstItem.declarationSymbol.  This is not the exported alias,\r\n   * but rather the original that has complete member and inheritance information.\r\n   */\r\n  protected type: ts.Type;\r\n\r\n  private _classLikeDeclaration: ts.ClassLikeDeclaration;\r\n  private _processedMemberNames: Set<string> = new Set<string>();\r\n  private _setterNames: Set<string> = new Set<string>();\r\n\r\n  constructor(options: IAstItemOptions) {\r\n    super(options);\r\n\r\n    this._classLikeDeclaration = options.declaration as ts.ClassLikeDeclaration;\r\n    this.type = this.typeChecker.getDeclaredTypeOfSymbol(this.declarationSymbol);\r\n\r\n    if (this.declarationSymbol.flags & ts.SymbolFlags.Interface) {\r\n      this.kind = AstItemKind.Interface;\r\n    } else if (this.declarationSymbol.flags & ts.SymbolFlags.TypeLiteral) {\r\n      this.kind = AstItemKind.TypeLiteral;\r\n    } else {\r\n      this.kind = AstItemKind.Class;\r\n    }\r\n\r\n    for (const memberDeclaration of this._classLikeDeclaration.members) {\r\n      const memberSymbol: ts.Symbol = TypeScriptHelpers.tryGetSymbolForDeclaration(memberDeclaration);\r\n      if (memberSymbol) {\r\n        this._processMember(memberSymbol, memberDeclaration);\r\n      } else {\r\n        // If someone put an extra semicolon after their function, we don't care about that\r\n        if (memberDeclaration.kind !== ts.SyntaxKind.SemicolonClassElement) {\r\n          // If there is some other non-semantic junk, add a warning so we can investigate it\r\n          this.reportWarning(PrettyPrinter.formatFileAndLineNumber(memberDeclaration)\r\n            + `: No semantic information for \"${memberDeclaration.getText()}\"`);\r\n        }\r\n      }\r\n    }\r\n\r\n    // If there is a getter and no setter, mark it as readonly.\r\n    for (const member of this.getSortedMemberItems()) {\r\n      const memberSymbol: ts.Symbol = TypeScriptHelpers.tryGetSymbolForDeclaration(member.getDeclaration());\r\n      if (memberSymbol && (memberSymbol.flags === ts.SymbolFlags.GetAccessor)) {\r\n        if (!this._setterNames.has(member.name)) {\r\n          (member as AstProperty).isReadOnly = true;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Check for heritage clauses (implements and extends)\r\n    if (this._classLikeDeclaration.heritageClauses) {\r\n      for (const heritage of this._classLikeDeclaration.heritageClauses) {\r\n        const typeText: string = heritage.types && heritage.types.length && heritage.types[0].expression ?\r\n          heritage.types[0].expression.getText() : undefined;\r\n        if (heritage.token === ts.SyntaxKind.ExtendsKeyword) {\r\n          this.extends = typeText;\r\n        } else if (heritage.token === ts.SyntaxKind.ImplementsKeyword) {\r\n          this.implements = typeText;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Check for type parameters\r\n    if (this._classLikeDeclaration.typeParameters && this._classLikeDeclaration.typeParameters.length) {\r\n      if (!this.typeParameters) {\r\n        this.typeParameters = [];\r\n      }\r\n      for (const param of this._classLikeDeclaration.typeParameters) {\r\n        this.typeParameters.push(param.getText());\r\n      }\r\n    }\r\n\r\n    // Throw errors for setters that don't have a corresponding getter\r\n    this._setterNames.forEach((setterName: string) => {\r\n      if (!this.getMemberItem(setterName)) {\r\n        // Normally we treat API design changes as warnings rather than errors.  However,\r\n        // a missing getter is bizarre enough that it's reasonable to assume it's a mistake,\r\n        // not a conscious design choice.\r\n        this.reportError(`The \"${setterName}\" property has a setter, but no a getter`);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @virtual\r\n   */\r\n  public visitTypeReferencesForAstItem(): void {\r\n    super.visitTypeReferencesForAstItem();\r\n\r\n    // Collect type references from the base classes\r\n    if (this._classLikeDeclaration && this._classLikeDeclaration.heritageClauses) {\r\n      for (const clause of this._classLikeDeclaration.heritageClauses) {\r\n        this.visitTypeReferencesForNode(clause);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n    * Returns a line of text such as \"class MyClass extends MyBaseClass\", excluding the\r\n    * curly braces and body.  The name \"MyClass\" will be the public name seen by external\r\n    * callers, not the declared name of the class; @see AstItem.name documentation for details.\r\n    */\r\n  public getDeclarationLine(): string {\r\n    let result: string = '';\r\n\r\n    if (this.kind !== AstItemKind.TypeLiteral) {\r\n      result += (this.declarationSymbol.flags & ts.SymbolFlags.Interface)\r\n        ? 'interface ' : 'class ';\r\n\r\n      result += this.name;\r\n\r\n      if (this._classLikeDeclaration.typeParameters) {\r\n        result += '<';\r\n\r\n        result += this._classLikeDeclaration.typeParameters\r\n          .map((param: ts.TypeParameterDeclaration) => param.getText())\r\n          .join(', ');\r\n\r\n        result += '>';\r\n      }\r\n\r\n      if (this._classLikeDeclaration.heritageClauses) {\r\n        result += ' ';\r\n        result += this._classLikeDeclaration.heritageClauses\r\n          .map((clause: ts.HeritageClause) => clause.getText())\r\n          .join(', ');\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n  protected onCompleteInitialization(): void {\r\n    super.onCompleteInitialization();\r\n\r\n    // Is the constructor internal?\r\n    for (const member of this.getSortedMemberItems()) {\r\n      if (member.kind === AstItemKind.Constructor) {\r\n        if (member.documentation.releaseTag === ReleaseTag.Internal) {\r\n          // Add a boilerplate notice for classes with internal constructors\r\n          this.documentation.remarks.unshift(\r\n            ...Markup.createTextElements(`The constructor for this class is marked as internal. Third-party code`\r\n              + ` should not call the constructor directly or create subclasses that extend the ${this.name} class.`),\r\n            Markup.PARAGRAPH\r\n          );\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  private _processMember(memberSymbol: ts.Symbol, memberDeclaration: ts.Declaration): void {\r\n    if (memberDeclaration.modifiers) {\r\n      for (let i: number = 0; i < memberDeclaration.modifiers.length; i++ ) {\r\n        const modifier: ts.Modifier = memberDeclaration.modifiers[i];\r\n        if (modifier.kind === ts.SyntaxKind.PrivateKeyword) {\r\n          return;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (this._processedMemberNames.has(memberSymbol.name)) {\r\n      if (memberSymbol.flags === ts.SymbolFlags.SetAccessor) {\r\n        // In case of setters, just add them to a list to check later if they have a getter\r\n        this._setterNames.add(memberSymbol.name);\r\n      }\r\n      // Throw an error for duplicate names, because we use names as identifiers\r\n      // @todo #261549 Define an AEDoc tag to allow defining an identifier for overloaded methods eg. @overload method2\r\n      return;\r\n    }\r\n\r\n    // Proceed to add the member\r\n    this._processedMemberNames.add(memberSymbol.name);\r\n\r\n    const memberOptions: IAstItemOptions = {\r\n      context: this.context,\r\n      declaration: memberDeclaration,\r\n      declarationSymbol: memberSymbol,\r\n      jsdocNode: memberDeclaration\r\n    };\r\n\r\n    if (memberSymbol.flags & (\r\n        ts.SymbolFlags.Method |\r\n        ts.SymbolFlags.Constructor |\r\n        ts.SymbolFlags.Signature |\r\n        ts.SymbolFlags.Function\r\n    )) {\r\n      this.addMemberItem(new AstMethod(memberOptions));\r\n    } else if (memberSymbol.flags & (\r\n      ts.SymbolFlags.Property |\r\n      ts.SymbolFlags.GetAccessor\r\n    )) {\r\n      this.addMemberItem(new AstProperty(memberOptions));\r\n    } else {\r\n      this.reportWarning(`Unsupported member: ${memberSymbol.name}`);\r\n    }\r\n  }\r\n}\r\n"],"sourceRoot":"..\\..\\src"}