"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const ts = require("typescript");
const AstItem_1 = require("./AstItem");
const AstMember_1 = require("./AstMember");
const AstParameter_1 = require("./AstParameter");
const TypeScriptHelpers_1 = require("../TypeScriptHelpers");
const Markup_1 = require("../markup/Markup");
const ApiDefinitionReference_1 = require("../ApiDefinitionReference");
/**
 * This class is part of the AstItem abstract syntax tree. It represents functions that are members of
 * classes, interfaces, or nested type literal expressions. Unlike AstFunctions, AstMethods can have
 * access modifiers (public, private, etc.) or be optional, because they are members of a structured type
 *
 * @see AstFunction for functions that are defined inside of a package
 */
class AstMethod extends AstMember_1.default {
    constructor(options) {
        super(options);
        // tslint:disable-next-line:no-bitwise
        if ((options.declarationSymbol.flags & ts.SymbolFlags.Constructor) !== 0) {
            this.kind = AstItem_1.AstItemKind.Constructor;
        }
        else {
            this.kind = AstItem_1.AstItemKind.Method;
        }
        const methodDeclaration = options.declaration;
        // Parameters
        if (methodDeclaration.parameters) {
            this.params = [];
            for (const param of methodDeclaration.parameters) {
                const declarationSymbol = TypeScriptHelpers_1.default.tryGetSymbolForDeclaration(param);
                const astParameter = new AstParameter_1.default({
                    context: this.context,
                    declaration: param,
                    declarationSymbol: declarationSymbol,
                    jsdocNode: param
                });
                this.innerItems.push(astParameter);
                this.params.push(astParameter);
            }
        }
        // Return type
        if (this.kind !== AstItem_1.AstItemKind.Constructor) {
            if (methodDeclaration.type) {
                this.returnType = methodDeclaration.type.getText();
            }
            else {
                this.returnType = 'any';
                this.hasIncompleteTypes = true;
            }
        }
    }
    onCompleteInitialization() {
        super.onCompleteInitialization();
        // If this is a class constructor, and if the documentation summary was omitted, then
        // we fill in a default summary versus flagging it as "undocumented".
        // Generally class constructors have uninteresting documentation.
        if (this.kind === AstItem_1.AstItemKind.Constructor) {
            if (this.documentation.summary.length === 0) {
                this.documentation.summary.push(...Markup_1.Markup.createTextElements('Constructs a new instance of the '));
                const scopedPackageName = ApiDefinitionReference_1.default
                    .parseScopedPackageName(this.context.package.name);
                this.documentation.summary.push(Markup_1.Markup.createApiLinkFromText(this.parentContainer.name, {
                    scopeName: scopedPackageName.scope,
                    packageName: scopedPackageName.package,
                    exportName: this.parentContainer.name,
                    memberName: ''
                }));
                this.documentation.summary.push(...Markup_1.Markup.createTextElements(' class'));
            }
            this.needsDocumentation = false;
        }
    }
}
exports.default = AstMethod;

//# sourceMappingURL=AstMethod.js.map
