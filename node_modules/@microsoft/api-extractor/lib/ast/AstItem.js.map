{"version":3,"sources":["ast/AstItem.ts"],"names":[],"mappings":"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","file":"ast/AstItem.js","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\n/* tslint:disable:no-bitwise */\r\n/* tslint:disable:no-constant-condition */\r\n\r\nimport * as ts from 'typescript';\r\nimport { ExtractorContext } from '../ExtractorContext';\r\nimport ApiDocumentation from '../aedoc/ApiDocumentation';\r\nimport { MarkupElement } from '../markup/MarkupElement';\r\nimport { ReleaseTag } from '../aedoc/ReleaseTag';\r\nimport TypeScriptHelpers from '../TypeScriptHelpers';\r\nimport { Markup } from '../markup/Markup';\r\nimport ResolvedApiItem from '../ResolvedApiItem';\r\nimport ApiDefinitionReference,\r\n  { IScopedPackageName, IApiDefinitionReferenceParts } from '../ApiDefinitionReference';\r\nimport AstItemContainer from './AstItemContainer';\r\n\r\n/**\r\n * Indicates the type of definition represented by a AstItem object.\r\n */\r\nexport enum AstItemKind {\r\n  /**\r\n    * A TypeScript class.\r\n    */\r\n  Class = 0,\r\n  /**\r\n    * A TypeScript enum.\r\n    */\r\n  Enum = 1,\r\n  /**\r\n    * A TypeScript value on an enum.\r\n    */\r\n  EnumValue = 2,\r\n  /**\r\n    * A TypeScript function.\r\n    */\r\n  Function = 3,\r\n  /**\r\n    * A TypeScript interface.\r\n    */\r\n  Interface = 4,\r\n  /**\r\n    * A TypeScript method.\r\n    */\r\n  Method = 5,\r\n  /**\r\n    * A TypeScript package.\r\n    */\r\n  Package = 6,\r\n  /**\r\n    * A TypeScript parameter.\r\n    */\r\n  Parameter = 7,\r\n  /**\r\n    * A TypeScript property.\r\n    */\r\n  Property = 8,\r\n  /**\r\n    * A TypeScript type literal expression, i.e. which defines an anonymous interface.\r\n    */\r\n  TypeLiteral = 9,\r\n  /**\r\n   * A Typescript class constructor function.\r\n   */\r\n  Constructor = 10,\r\n  /**\r\n   * A Typescript namespace.\r\n   */\r\n  Namespace = 11,\r\n  /**\r\n   * A Typescript BlockScopedVariable.\r\n   */\r\n  ModuleVariable = 12\r\n}\r\n\r\n/**\r\n * The state of completing the AstItem's doc comment references inside a recursive call to AstItem.resolveReferences().\r\n */\r\nenum InitializationState {\r\n  /**\r\n   * The references of this AstItem have not begun to be completed.\r\n   */\r\n  Incomplete = 0,\r\n  /**\r\n   * The references of this AstItem are in the process of being completed.\r\n   * If we encounter this state again during completing, a circular dependency\r\n   * has occurred.\r\n   */\r\n  Completing = 1,\r\n  /**\r\n   * The references of this AstItem have all been completed and the documentation can\r\n   * now safely be created.\r\n   */\r\n  Completed = 2\r\n}\r\n\r\n/**\r\n  * This interface is used to pass options between constructors for AstItem child classes.\r\n  */\r\nexport interface IAstItemOptions {\r\n  /**\r\n   * The associated ExtractorContext object for this AstItem\r\n   */\r\n  context: ExtractorContext;\r\n  /**\r\n   * The declaration node for the main syntax item that this AstItem is associated with.\r\n   */\r\n  declaration: ts.Declaration;\r\n  /**\r\n   * The semantic information for the declaration.\r\n   */\r\n  declarationSymbol: ts.Symbol;\r\n  /**\r\n   * The declaration node that contains the JSDoc comments for this AstItem.\r\n   * In most cases this is the same as `declaration`, but for AstPackage it will be\r\n   * a separate node under the root.\r\n   */\r\n  jsdocNode: ts.Node;\r\n  /**\r\n   * The symbol used to export this AstItem from the AstPackage.\r\n   */\r\n  exportSymbol?: ts.Symbol;\r\n}\r\n\r\n// Names of NPM scopes that contain packages that provide typings for the real package.\r\n// The TypeScript compiler's typings design doesn't seem to handle scoped NPM packages,\r\n// so the transformation will always be simple, like this:\r\n// \"@types/example\" --> \"example\"\r\n// NOT like this:\r\n// \"@types/@contoso/example\" --> \"@contoso/example\"\r\n// \"@contosotypes/example\" --> \"@contoso/example\"\r\n// Eventually this constant should be provided by the gulp task that invokes the compiler.\r\nconst typingsScopeNames: string[] = [ '@types' ];\r\n\r\n/**\r\n * AstItem is an abstract base that represents TypeScript API definitions such as classes,\r\n * interfaces, enums, properties, functions, and variables.  Rather than directly using the\r\n * abstract syntax tree from the TypeScript Compiler API, we use AstItem to extract a\r\n * simplified tree which correponds to the major topics for our API documentation.\r\n */\r\nabstract class AstItem {\r\n\r\n  /**\r\n   * Names of API items should only contain letters, numbers and underscores.\r\n   */\r\n  private static _allowedNameRegex: RegExp = /^[a-zA-Z_]+[a-zA-Z_0-9]*$/;\r\n\r\n  /**\r\n   * The name of the definition, as seen by external consumers of the Public API.\r\n   * For example, suppose a class is defined as \"export default class MyClass { }\"\r\n   * but exported from the package's index.ts like this:\r\n   *\r\n   *    export { default as _MyClass } from './MyClass';\r\n   *\r\n   * In this example, the AstItem.name would be \"_MyClass\", i.e. the alias as exported\r\n   * from the top-level AstPackage, not \"MyClass\" from the original definition.\r\n   */\r\n  public name: string;\r\n\r\n  /**\r\n   * The name of an API item should be readable and not contain any special characters.\r\n   */\r\n  public supportedName: boolean;\r\n\r\n  /**\r\n   * Indicates the type of definition represented by this AstItem instance.\r\n   */\r\n  public kind: AstItemKind;\r\n\r\n  /**\r\n   * A superset of memberItems. Includes memberItems and also other AstItems that\r\n   * comprise this AstItem.\r\n   *\r\n   * Ex: if this AstItem is an AstFunction, then in it's innerItems would\r\n   * consist of AstParameters.\r\n   * Ex: if this AstItem is an AstMember that is a type literal, then it's\r\n   * innerItems would contain ApiProperties.\r\n   */\r\n  public innerItems: AstItem[] = [];\r\n\r\n  /**\r\n   * True if this AstItem either itself has missing type information or one\r\n   * of it's innerItems is missing type information.\r\n   *\r\n   * Ex: if this AstItem is an AstMethod and has no type on the return value, then\r\n   * we consider the AstItem as 'itself' missing type informations and this property\r\n   * is set to true.\r\n   * Ex: If this AstItem is an AstMethod and one of its innerItems is an AstParameter\r\n   * that has no type specified, then we say an innerItem of this AstMethod is missing\r\n   * type information and this property is set to true.\r\n   */\r\n  public hasIncompleteTypes: boolean = false;\r\n\r\n  /**\r\n   * A list of extractor warnings that were reported using AstItem.reportWarning().\r\n   * Whereas an \"error\" will break the build, a \"warning\" will merely be tracked in\r\n   * the API file produced by ApiFileGenerator.\r\n   */\r\n  public warnings: string[];\r\n\r\n  /**\r\n   * The declaration node that contains the JSDoc comments for this AstItem.\r\n   * In most cases this is the same as `declaration`, but for AstPackage it will be\r\n   * a separate node under the root.\r\n   */\r\n  public jsdocNode: ts.Node;\r\n\r\n  /**\r\n   * The parsed AEDoc comment for this item.\r\n   */\r\n  public documentation: ApiDocumentation;\r\n\r\n  /**\r\n   * Indicates that this AstItem does not have adequate AEDoc comments. If shouldHaveDocumentation()=true,\r\n   * and there is less than 10 characters of summary text in the AEDoc, then this will be set to true and\r\n   * noted in the API file produced by ApiFileGenerator.\r\n   * (The AEDoc text itself is not included in that report, because documentation\r\n   * changes do not require an API review, and thus should not cause a diff for that report.)\r\n   */\r\n  public needsDocumentation: boolean;\r\n\r\n  /**\r\n   * The release tag for this item, which may be inherited from a parent.\r\n   * By contrast, ApiDocumentation.releaseTag merely tracks the release tag that was\r\n   * explicitly applied to this item, and does not consider inheritance.\r\n   * @remarks\r\n   * This is calculated during completeInitialization() and should not be used beforehand.\r\n   */\r\n  public inheritedReleaseTag: ReleaseTag = ReleaseTag.None;\r\n\r\n  /**\r\n   * The deprecated message for this item, which may be inherited from a parent.\r\n   * By contrast, ApiDocumentation.deprecatedMessage merely tracks the message that was\r\n   * explicitly applied to this item, and does not consider inheritance.\r\n   * @remarks\r\n   * This is calculated during completeInitialization() and should not be used beforehand.\r\n   */\r\n  public inheritedDeprecatedMessage: MarkupElement[] = [];\r\n\r\n  /**\r\n   * The ExtractorContext object provides common contextual information for all of\r\n   * items in the AstItem tree.\r\n   */\r\n  protected context: ExtractorContext;\r\n\r\n  /**\r\n   * Syntax information from the TypeScript Compiler API, corresponding to the place\r\n   * where this object is originally defined.\r\n   */\r\n  protected declaration: ts.Declaration;\r\n\r\n  /**\r\n   * Semantic information from the TypeScript Compiler API, corresponding to the place\r\n   * where this object is originally defined.\r\n   */\r\n  protected declarationSymbol: ts.Symbol;\r\n\r\n  /**\r\n   * Semantic information from the TypeScript Compiler API, corresponding to the symbol\r\n   * that is seen by external consumers of the Public API.  For an aliased symbol, this\r\n   * would be the alias that is exported from the top-level package (i.e. AstPackage).\r\n   */\r\n  protected exportSymbol: ts.Symbol;\r\n\r\n  protected typeChecker: ts.TypeChecker;\r\n\r\n  /**\r\n   * Syntax information from the TypeScript Compiler API, used to locate the file name\r\n   * and line number when reporting an error for this AstItem.\r\n   */\r\n  private _errorNode: ts.Node;\r\n\r\n  /**\r\n   * The state of this AstItems references. These references could include \\@inheritdoc references\r\n   * or type references.\r\n   */\r\n  private _state: InitializationState;\r\n\r\n  private _parentContainer: AstItemContainer | undefined;\r\n\r\n  constructor(options: IAstItemOptions) {\r\n    this.reportError = this.reportError.bind(this);\r\n\r\n    this.jsdocNode = options.jsdocNode;\r\n    this.declaration = options.declaration;\r\n    this._errorNode = options.declaration;\r\n    this._state = InitializationState.Incomplete;\r\n    this.warnings = [];\r\n\r\n    this.context = options.context;\r\n    this.typeChecker = this.context.typeChecker;\r\n    this.declarationSymbol = options.declarationSymbol;\r\n    this.exportSymbol = options.exportSymbol || this.declarationSymbol;\r\n\r\n    this.name = this.exportSymbol.name || '???';\r\n\r\n    let originalJsdoc: string = '';\r\n    if (this.jsdocNode) {\r\n      originalJsdoc = TypeScriptHelpers.getJsdocComments(this.jsdocNode, this.reportError);\r\n    }\r\n\r\n    this.documentation = new ApiDocumentation(\r\n      originalJsdoc,\r\n      this.context.docItemLoader,\r\n      this.context,\r\n      this.reportError,\r\n      this.warnings\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Called by AstItemContainer.addMemberItem().  Other code should NOT call this method.\r\n   */\r\n  public notifyAddedToContainer(parentContainer: AstItemContainer): void {\r\n    if (this._parentContainer) {\r\n      // This would indicate a program bug\r\n      throw new Error('The API item has already been added to another container: ' + this._parentContainer.name);\r\n    }\r\n    this._parentContainer = parentContainer;\r\n  }\r\n\r\n  /**\r\n   * Called after the constructor to finish the analysis.\r\n   */\r\n  public visitTypeReferencesForAstItem(): void {\r\n    // (virtual)\r\n  }\r\n\r\n  /**\r\n   * Return the compiler's underlying Declaration object\r\n   * @todo Generally AstItem classes don't expose ts API objects; we should add\r\n   *       an appropriate member to avoid the need for this.\r\n   */\r\n  public getDeclaration(): ts.Declaration {\r\n    return this.declaration;\r\n  }\r\n\r\n  /**\r\n   * Return the compiler's underlying Symbol object that contains semantic information about the item\r\n   * @todo Generally AstItem classes don't expose ts API objects; we should add\r\n   *       an appropriate member to avoid the need for this.\r\n   */\r\n  public getDeclarationSymbol(): ts.Symbol {\r\n    return this.declarationSymbol;\r\n  }\r\n\r\n  /**\r\n   * Whether this APiItem should have documentation or not.  If false, then\r\n   * AstItem.missingDocumentation will never be set.\r\n   */\r\n  public shouldHaveDocumentation(): boolean {\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * The AstItemContainer that this member belongs to, or undefined if there is none.\r\n   */\r\n  public get parentContainer(): AstItemContainer|undefined {\r\n    return this._parentContainer;\r\n  }\r\n\r\n  /**\r\n   * This function is a second stage that happens after ExtractorContext.analyze() calls AstItem constructor to build up\r\n   * the abstract syntax tree. In this second stage, we are creating the documentation for each AstItem.\r\n   *\r\n   * This function makes sure we create the documentation for each AstItem in the correct order.\r\n   * In the event that a circular dependency occurs, an error is reported. For example, if AstItemOne has\r\n   * an \\@inheritdoc referencing AstItemTwo, and AstItemTwo has an \\@inheritdoc referencing AstItemOne then\r\n   * we have a circular dependency and an error will be reported.\r\n   */\r\n  public completeInitialization(): void {\r\n    switch (this._state) {\r\n      case InitializationState.Completed:\r\n        return;\r\n      case InitializationState.Incomplete:\r\n        this._state = InitializationState.Completing;\r\n        this.onCompleteInitialization();\r\n        this._state = InitializationState.Completed;\r\n\r\n        for (const innerItem of this.innerItems) {\r\n          innerItem.completeInitialization();\r\n        }\r\n        return;\r\n      case InitializationState.Completing:\r\n        this.reportError('circular reference');\r\n        return;\r\n      default:\r\n        throw new Error('AstItem state is invalid');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * A procedure for determining if this AstItem is missing type\r\n   * information. We first check if the AstItem itself is missing\r\n   * any type information and if not then we check each of it's\r\n   * innerItems for missing types.\r\n   *\r\n   * Ex: On the AstItem itself, there may be missing type information\r\n   * on the return value or missing type declaration of itself\r\n   * (const name;).\r\n   * Ex: For each innerItem, there may be an AstParameter that is missing\r\n   * a type. Or for an AstMember that is a type literal, there may be an\r\n   * AstProperty that is missing type information.\r\n   */\r\n  public hasAnyIncompleteTypes(): boolean {\r\n    if (this.hasIncompleteTypes) {\r\n      return true;\r\n    }\r\n\r\n    for (const innerItem of this.innerItems) {\r\n      if (innerItem.hasIncompleteTypes) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * This traverses any type aliases to find the original place where an item was defined.\r\n   * For example, suppose a class is defined as \"export default class MyClass { }\"\r\n   * but exported from the package's index.ts like this:\r\n   *\r\n   *    export { default as _MyClass } from './MyClass';\r\n   *\r\n   * In this example, calling followAliases() on the _MyClass symbol will return the\r\n   * original definition of MyClass, traversing any intermediary places where the\r\n   * symbol was imported and re-exported.\r\n   */\r\n  protected followAliases(symbol: ts.Symbol): ts.Symbol {\r\n    let current: ts.Symbol = symbol;\r\n    while (true) {\r\n      if (!(current.flags & ts.SymbolFlags.Alias)) {\r\n        break;\r\n      }\r\n      const currentAlias: ts.Symbol = this.typeChecker.getAliasedSymbol(current);\r\n      if (!currentAlias || currentAlias === current) {\r\n        break;\r\n      }\r\n      current = currentAlias;\r\n    }\r\n\r\n    return current;\r\n  }\r\n\r\n  /**\r\n   * Reports an error through the ApiErrorHandler interface that was registered with the Extractor,\r\n   * adding the filename and line number information for the declaration of this AstItem.\r\n   */\r\n  protected reportError(message: string): void {\r\n    this.context.reportError(message, this._errorNode.getSourceFile(), this._errorNode.getStart());\r\n  }\r\n\r\n  /**\r\n   * Adds a warning to the AstItem.warnings list.  These warnings will be emitted in the API file\r\n   * produced by ApiFileGenerator.\r\n   */\r\n  protected reportWarning(message: string): void {\r\n    this.warnings.push(message);\r\n  }\r\n\r\n  /**\r\n   * This function assumes all references from this AstItem have been resolved and we can now safely create\r\n   * the documentation.\r\n   */\r\n  protected onCompleteInitialization(): void {\r\n    this.documentation.completeInitialization(this.warnings);\r\n\r\n    // Calculate the inherited release tag\r\n    if (this.documentation.releaseTag !== ReleaseTag.None) {\r\n      this.inheritedReleaseTag = this.documentation.releaseTag;\r\n    } else if (this.parentContainer) {\r\n      this.inheritedReleaseTag = this.parentContainer.inheritedReleaseTag;\r\n    }\r\n\r\n    // Calculate the inherited deprecation message\r\n    if (this.documentation.deprecatedMessage.length) {\r\n      this.inheritedDeprecatedMessage = this.documentation.deprecatedMessage;\r\n    } else if (this.parentContainer) {\r\n      this.inheritedDeprecatedMessage = this.parentContainer.inheritedDeprecatedMessage;\r\n    }\r\n\r\n    // TODO: this.visitTypeReferencesForNode(this);\r\n\r\n    const summaryTextCondensed: string = Markup.extractTextContent(\r\n      this.documentation.summary).replace(/\\s\\s/g, ' ');\r\n    this.needsDocumentation = this.shouldHaveDocumentation() && summaryTextCondensed.length <= 10;\r\n\r\n    this.supportedName =  (this.kind === AstItemKind.Package) || AstItem._allowedNameRegex.test(this.name);\r\n    if (!this.supportedName) {\r\n      this.warnings.push(`The name \"${this.name}\" contains unsupported characters; ` +\r\n        'API names should use only letters, numbers, and underscores');\r\n    }\r\n\r\n    if (this.kind === AstItemKind.Package) {\r\n      if (this.documentation.releaseTag !== ReleaseTag.None) {\r\n        const tag: string = '@' + ReleaseTag[this.documentation.releaseTag].toLowerCase();\r\n        this.reportError(`The ${tag} tag is not allowed on the package, which is always considered to be @public`);\r\n      }\r\n    }\r\n\r\n    if (this.documentation.preapproved) {\r\n      if (!(this.getDeclaration().kind & (ts.SyntaxKind.InterfaceDeclaration | ts.SyntaxKind.ClassDeclaration))) {\r\n        this.reportError('The @preapproved tag may only be applied to classes and interfaces');\r\n        this.documentation.preapproved = false;\r\n      }\r\n    }\r\n\r\n    if (this.documentation.isDocInheritedDeprecated && this.documentation.deprecatedMessage.length === 0) {\r\n      this.reportError('The @inheritdoc target has been marked as @deprecated.  ' +\r\n        'Add a @deprecated message here, or else remove the @inheritdoc relationship.');\r\n    }\r\n\r\n    if (this.name.substr(0, 1) === '_') {\r\n      if (this.documentation.releaseTag !== ReleaseTag.Internal\r\n        && this.documentation.releaseTag !== ReleaseTag.None) {\r\n        this.reportWarning('The underscore prefix (\"_\") should only be used with definitions'\r\n          + ' that are explicitly marked as @internal');\r\n      }\r\n    } else {\r\n      if (this.documentation.releaseTag === ReleaseTag.Internal) {\r\n        this.reportWarning('Because this definition is explicitly marked as @internal, an underscore prefix (\"_\")'\r\n          + ' should be added to its name');\r\n      }\r\n    }\r\n\r\n    // Is it missing a release tag?\r\n    if (this.documentation.releaseTag === ReleaseTag.None) {\r\n      // Only warn about top-level exports\r\n      if (this.parentContainer && this.parentContainer.kind === AstItemKind.Package) {\r\n        // Don't warn about items that failed to parse.\r\n        if (!this.documentation.failedToParse) {\r\n          // If there is no release tag, and this is a top-level export of the package, then\r\n          // report an error\r\n          this.reportError(`A release tag (@alpha, @beta, @public, @internal) must be specified`\r\n            + ` for ${this.name}`);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * This is called by AstItems to visit the types that appear in an expression.  For example,\r\n   * if a Public API function returns a class that is defined in this package, but not exported,\r\n   * this is a problem. visitTypeReferencesForNode() finds all TypeReference child nodes under the\r\n   * specified node and analyzes each one.\r\n   */\r\n  protected visitTypeReferencesForNode(node: ts.Node): void {\r\n    if (node.kind === ts.SyntaxKind.Block ||\r\n      (node.kind >= ts.SyntaxKind.JSDocTypeExpression && node.kind <= ts.SyntaxKind.NeverKeyword)) {\r\n      // Don't traverse into code blocks or JSDoc items; we only care about the function signature\r\n      return;\r\n    }\r\n\r\n    if (node.kind === ts.SyntaxKind.TypeReference) {\r\n      const typeReference: ts.TypeReferenceNode = node as ts.TypeReferenceNode;\r\n      this._analyzeTypeReference(typeReference);\r\n    }\r\n\r\n    // Recurse the tree\r\n    for (const childNode of node.getChildren()) {\r\n      this.visitTypeReferencesForNode(childNode);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * This is a helper for visitTypeReferencesForNode().  It analyzes a single TypeReferenceNode.\r\n   */\r\n  private _analyzeTypeReference(typeReferenceNode: ts.TypeReferenceNode): void {\r\n    const symbol: ts.Symbol = this.context.typeChecker.getSymbolAtLocation(typeReferenceNode.typeName);\r\n    if (!symbol) {\r\n      // Is this bad?\r\n      return;\r\n    }\r\n\r\n    if (symbol.flags & ts.SymbolFlags.TypeParameter) {\r\n      // Don't analyze e.g. \"T\" in \"Set<T>\"\r\n      return;\r\n    }\r\n\r\n    // Follow the aliases all the way to the ending SourceFile\r\n    const currentSymbol: ts.Symbol = this.followAliases(symbol);\r\n\r\n    if (!currentSymbol.declarations || !currentSymbol.declarations.length) {\r\n      // This is a degenerate case that happens sometimes\r\n      return;\r\n    }\r\n    const sourceFile: ts.SourceFile = currentSymbol.declarations[0].getSourceFile();\r\n\r\n    // Walk upwards from that directory until you find a directory containing package.json,\r\n    // this is where the referenced type is located.\r\n    // Example: \"c:\\users\\<username>\\sp-client\\spfx-core\\sp-core-library\"\r\n    const typeReferencePackagePath: string = this.context.packageJsonLookup\r\n      .tryGetPackageFolder(sourceFile.fileName);\r\n    // Example: \"@microsoft/sp-core-library\"\r\n    let typeReferencePackageName: string = '';\r\n\r\n    // If we can not find a package path, we consider the type to be part of the current project's package.\r\n    // One case where this happens is when looking for a type that is a symlink\r\n    if (!typeReferencePackagePath) {\r\n      typeReferencePackageName = this.context.package.name;\r\n    } else {\r\n      typeReferencePackageName = this.context.packageJsonLookup\r\n        .getPackageName(typeReferencePackagePath);\r\n\r\n      typingsScopeNames.every(typingScopeName => {\r\n        if (typeReferencePackageName.indexOf(typingScopeName) > -1) {\r\n          typeReferencePackageName = typeReferencePackageName.replace(typingScopeName + '/', '');\r\n          // returning true breaks the every loop\r\n          return true;\r\n        }\r\n      });\r\n    }\r\n\r\n    // Read the name/version from package.json -- that tells you what package the symbol\r\n    // belongs to. If it is your own AstPackage.name/version, then you know it's a local symbol.\r\n    const currentPackageName: string = this.context.package.name;\r\n\r\n    const typeName: string = typeReferenceNode.typeName.getText();\r\n    if (!typeReferencePackagePath || typeReferencePackageName === currentPackageName) {\r\n      // The type is defined in this project.  Did the person remember to export it?\r\n      const exportedLocalName: string = this.context.package.tryGetExportedSymbolName(currentSymbol);\r\n      if (exportedLocalName) {\r\n        // [CASE 1] Local/Exported\r\n        // Yes; the type is properly exported.\r\n        // TODO: In the future, here we can check for issues such as a @public type\r\n        // referencing an @internal type.\r\n        return;\r\n      } else {\r\n        // [CASE 2] Local/Unexported\r\n        // No; issue a warning\r\n        this.reportWarning(`The type \"${typeName}\" needs to be exported by the package`\r\n          + ` (e.g. added to index.ts)`);\r\n          return;\r\n      }\r\n    }\r\n\r\n    // External\r\n    // Attempt to load from docItemLoader\r\n    const scopedPackageName: IScopedPackageName = ApiDefinitionReference.parseScopedPackageName(\r\n      typeReferencePackageName\r\n    );\r\n    const apiDefinitionRefParts: IApiDefinitionReferenceParts = {\r\n      scopeName: scopedPackageName.scope,\r\n      packageName: scopedPackageName.package,\r\n      exportName: '',\r\n      memberName: ''\r\n    };\r\n\r\n    // the currentSymbol.name is the name of an export, if it contains a '.' then the substring\r\n    // after the period is the member name\r\n    if (currentSymbol.name.indexOf('.') > -1) {\r\n      const exportMemberName: string[] = currentSymbol.name.split('.');\r\n      apiDefinitionRefParts.exportName = exportMemberName.pop();\r\n      apiDefinitionRefParts.memberName = exportMemberName.pop();\r\n    } else {\r\n      apiDefinitionRefParts.exportName = currentSymbol.name;\r\n    }\r\n\r\n    const apiDefinitionRef: ApiDefinitionReference = ApiDefinitionReference.createFromParts(\r\n      apiDefinitionRefParts\r\n    );\r\n\r\n    // Attempt to resolve the type by checking the node modules\r\n    const referenceResolutionWarnings: string[] = [];\r\n    const resolvedAstItem: ResolvedApiItem = this.context.docItemLoader.resolveJsonReferences(\r\n      apiDefinitionRef,\r\n      referenceResolutionWarnings\r\n    );\r\n\r\n    if (resolvedAstItem) {\r\n      // [CASE 3] External/Resolved\r\n      // This is a reference to a type from an external package, and it was resolved.\r\n      return;\r\n    } else {\r\n      // [CASE 4] External/Unresolved\r\n      // For cases when we can't find the external package, we are going to write a report\r\n      // at the bottom of the *api.ts file. We do this because we do not yet support references\r\n      // to items like react:Component.\r\n      // For now we are going to silently ignore these errors.\r\n      return;\r\n    }\r\n  }\r\n}\r\n\r\nexport default AstItem;\r\n"],"sourceRoot":"..\\..\\src"}