{"version":3,"sources":["DocElementParser.ts"],"names":[],"mappings":"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","file":"DocElementParser.js","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport {\r\n  MarkupLinkTextElement,\r\n  MarkupBasicElement,\r\n  MarkupElement\r\n} from './markup/MarkupElement';\r\nimport { Markup } from './markup/Markup';\r\nimport ApiDefinitionReference, { IScopedPackageName } from './ApiDefinitionReference';\r\nimport ApiDocumentation from './aedoc/ApiDocumentation';\r\nimport { AstItemKind } from './ast/AstItem';\r\nimport Token, { TokenType } from './aedoc/Token';\r\nimport Tokenizer from './aedoc/Tokenizer';\r\nimport ResolvedApiItem from './ResolvedApiItem';\r\nimport { IApiItemReference} from './api/ApiItem';\r\n\r\nexport default class DocElementParser {\r\n  /**\r\n   * Used to validate the display text for an \\@link tag.  The display text can contain any\r\n   * characters except for certain AEDoc delimiters: \"@\", \"|\", \"{\", \"}\".\r\n   * This RegExp matches the first bad character.\r\n   * Example: \"Microsoft's {spec}\" --> \"{\"\r\n   */\r\n  private static _displayTextBadCharacterRegEx: RegExp = /[@|{}]/;\r\n\r\n  /**\r\n   * Matches a href reference. This is used to get an idea whether a given reference is for an href\r\n   * or an API definition reference.\r\n   *\r\n   * For example, the following would be matched:\r\n   * 'http://'\r\n   * 'https://'\r\n   *\r\n   * The following would not be matched:\r\n   * '@microsoft/sp-core-library:Guid.newGuid'\r\n   * 'Guid.newGuid'\r\n   * 'Guid'\r\n   */\r\n  private static _hrefRegEx: RegExp = /^[a-z]+:\\/\\//;\r\n\r\n  public static parse(documentation: ApiDocumentation, tokenizer: Tokenizer): MarkupBasicElement[] {\r\n\r\n    const markupElements: MarkupBasicElement[] = [];\r\n    let parsing: boolean = true;\r\n    let token: Token;\r\n\r\n    while (parsing) {\r\n      token = tokenizer.peekToken();\r\n      if (!token) {\r\n        parsing = false; // end of stream\r\n        break;\r\n      }\r\n\r\n      if (token.type === TokenType.BlockTag) {\r\n        parsing = false; // end of summary tokens\r\n      } else if (token.type === TokenType.InlineTag) {\r\n        switch (token.tag) {\r\n          case '@inheritdoc':\r\n            tokenizer.getToken();\r\n            if (markupElements.length > 0 ||  documentation.summary.length > 0) {\r\n              documentation.reportError('A summary block is not allowed here,'\r\n                + ' because the @inheritdoc target provides the summary');\r\n            }\r\n            documentation.incompleteInheritdocs.push(token);\r\n            documentation.isDocInherited = true;\r\n            break;\r\n          case '@link' :\r\n            const linkMarkupElement: MarkupElement = this.parseLinkTag(documentation, token);\r\n            if (linkMarkupElement) {\r\n              // Push to linkMarkupElement to retain position in the documentation\r\n              markupElements.push(linkMarkupElement);\r\n              if (linkMarkupElement.kind === 'api-link') {\r\n                documentation.incompleteLinks.push(linkMarkupElement);\r\n              }\r\n            }\r\n            tokenizer.getToken(); // get the link token\r\n            break;\r\n          default:\r\n            parsing = false;\r\n            break;\r\n        }\r\n      } else if (token.type === TokenType.Text) {\r\n        tokenizer.getToken();\r\n\r\n        markupElements.push(...Markup.createTextParagraphs(token.text));\r\n      } else {\r\n        documentation.reportError(`Unidentifiable Token ${token.type} ${token.tag} \"${token.text}\"`);\r\n      }\r\n    }\r\n\r\n    return markupElements;\r\n  }\r\n\r\n  public static parseAndNormalize(documentation: ApiDocumentation, tokenizer: Tokenizer): MarkupBasicElement[] {\r\n    const markupElements: MarkupBasicElement[] = DocElementParser.parse(documentation, tokenizer);\r\n    Markup.normalize(markupElements);\r\n    return markupElements;\r\n  }\r\n\r\n  /**\r\n   * This method parses the semantic information in an \\@link JSDoc tag, creates and returns a\r\n   * MarkupElement with the corresponding information. If the corresponding inline tag \\@link is\r\n   * not formatted correctly an error will be reported.\r\n   *\r\n   * The format for the \\@link tag is {\\@link URL or API defintion reference | display text}, where\r\n   * the '|' is only needed if the optional display text is given.\r\n   *\r\n   * Examples:\r\n   * \\{@link http://microsoft.com | microsoft home \\}\r\n   * \\{@link http://microsoft.com \\}\r\n   * \\{@link @microsoft/sp-core-library:Guid.newGuid | new Guid Object \\}\r\n   * \\{@link @microsoft/sp-core-library:Guid.newGuid \\}\r\n   */\r\n  public static parseLinkTag(documentation: ApiDocumentation, tokenItem: Token): MarkupBasicElement {\r\n    if (!tokenItem.text) {\r\n      documentation.reportError('The {@link} tag must include a URL or API item reference');\r\n       return;\r\n    }\r\n\r\n    // Make sure there are no extra pipes\r\n    const pipeSplitContent: string[] = tokenItem.text.split('|').map(value => {\r\n      if (value) {\r\n        return value.trim();\r\n      }\r\n    });\r\n    if (pipeSplitContent.length > 2) {\r\n      documentation.reportError('The {@link} tag contains more than one pipe character (\"|\")');\r\n      return undefined;\r\n    }\r\n\r\n    const addressPart: string = pipeSplitContent[0];\r\n    const displayTextPart: string = pipeSplitContent.length > 1 ? pipeSplitContent[1] : '';\r\n\r\n    let displayTextElements: MarkupLinkTextElement[];\r\n\r\n    // If a display name is given, ensure it only contains characters for words.\r\n    if (displayTextPart) {\r\n      const match: RegExpExecArray | undefined = this._displayTextBadCharacterRegEx.exec(displayTextPart);\r\n      if (match) {\r\n        documentation.reportError(`The {@link} tag\\'s display text contains an unsupported`\r\n          + ` character: \"${match[0]}\"`);\r\n        return undefined;\r\n      }\r\n      // Full match is valid text\r\n      displayTextElements = Markup.createTextElements(displayTextPart);\r\n    } else {\r\n      // If the display text is not explicitly provided, then use the address as the display text\r\n      displayTextElements = Markup.createTextElements(addressPart);\r\n    }\r\n\r\n    // Try to guess if the tokenContent is a link or API definition reference\r\n    let linkMarkupElement: MarkupBasicElement;\r\n    if (this._hrefRegEx.test(addressPart)) {\r\n      // Make sure only a single URL is given\r\n      if (addressPart.indexOf(' ') >= 0) {\r\n        documentation.reportError('The {@link} tag contains additional spaces after the URL;'\r\n          + ' if the URL contains spaces, encode them using %20; for display text, use a pipe delimiter (\"|\")');\r\n        return undefined;\r\n      }\r\n\r\n      linkMarkupElement = Markup.createWebLink(displayTextElements, addressPart);\r\n    } else {\r\n      // we are processing an API definition reference\r\n      const apiDefitionRef: ApiDefinitionReference = ApiDefinitionReference.createFromString(\r\n        addressPart,\r\n        documentation.reportError\r\n      );\r\n\r\n      // Once we can locate local API definitions, an error should be reported here if not found.\r\n      if (!apiDefitionRef) {\r\n        return undefined;\r\n      }\r\n\r\n      const normalizedApiLink: IApiItemReference = apiDefitionRef.toApiItemReference();\r\n      if (!normalizedApiLink.packageName) {\r\n        if (!documentation.context.packageName) {\r\n          throw new Error('Unable to resolve API reference without a package name');\r\n        }\r\n\r\n        // If the package name is unspecified, assume it is the current package\r\n        const scopePackageName: IScopedPackageName = ApiDefinitionReference.parseScopedPackageName(\r\n          documentation.context.packageName);\r\n\r\n        normalizedApiLink.scopeName = scopePackageName.scope;\r\n        normalizedApiLink.packageName = scopePackageName.package;\r\n      }\r\n\r\n      linkMarkupElement = Markup.createApiLink(displayTextElements, normalizedApiLink);\r\n    }\r\n\r\n    return linkMarkupElement;\r\n  }\r\n\r\n  /**\r\n   * This method parses the semantic information in an \\@inheritdoc JSDoc tag and sets\r\n   * all the relevant documenation properties from the inherited doc onto the documenation\r\n   * of the current api item.\r\n   *\r\n   * The format for the \\@inheritdoc tag is {\\@inheritdoc scopeName/packageName:exportName.memberName}.\r\n   * For more information on the format see IInheritdocRef.\r\n   */\r\n  public static parseInheritDoc(documentation: ApiDocumentation, token: Token, warnings: string[]): void {\r\n\r\n    // Check to make sure the API definition reference is at most one string\r\n    const tokenChunks: string[] = token.text.split(' ');\r\n    if (tokenChunks.length > 1) {\r\n      documentation.reportError('The {@inheritdoc} tag does not match the expected pattern' +\r\n        ' \"{@inheritdoc @scopeName/packageName:exportName}\"');\r\n      return;\r\n    }\r\n\r\n    // Create the IApiDefinitionReference object\r\n    // Deconstruct the API reference expression 'scopeName/packageName:exportName.memberName'\r\n    const apiDefinitionRef: ApiDefinitionReference = ApiDefinitionReference.createFromString(\r\n      token.text,\r\n      documentation.reportError\r\n    );\r\n    // if API reference expression is formatted incorrectly then apiDefinitionRef will be undefined\r\n    if (!apiDefinitionRef) {\r\n      documentation.reportError(`Incorrectly formatted API item reference: \"${token.text}\"`);\r\n      return;\r\n    }\r\n\r\n    // Atempt to locate the apiDefinitionRef\r\n    const resolvedAstItem: ResolvedApiItem = documentation.referenceResolver.resolve(\r\n      apiDefinitionRef,\r\n      documentation.context.package,\r\n      warnings\r\n    );\r\n\r\n    // If no resolvedAstItem found then nothing to inherit\r\n    // But for the time being set the summary to a text object\r\n    if (!resolvedAstItem) {\r\n      documentation.summary = Markup.createTextElements(`See documentation for ${tokenChunks[0]}`);\r\n      return;\r\n    }\r\n\r\n    // We are going to copy the resolvedAstItem's documentation\r\n    // We must make sure it's documentation can be completed,\r\n    // if we cannot, an error will be reported viathe documentation error handler.\r\n    // This will only be the case our resolvedAstItem was created from a local\r\n    // AstItem. Resolutions from JSON will have an undefined 'astItem' property.\r\n    // Example: a circular reference will report an error.\r\n    if (resolvedAstItem.astItem) {\r\n      resolvedAstItem.astItem.completeInitialization();\r\n    }\r\n\r\n    // inheritdoc found, copy over IApiBaseDefinition properties\r\n    documentation.summary =  resolvedAstItem.summary;\r\n    documentation.remarks = resolvedAstItem.remarks;\r\n\r\n    // Copy over detailed properties if neccessary\r\n    // Add additional cases if needed\r\n    switch (resolvedAstItem.kind) {\r\n      case AstItemKind.Function:\r\n        documentation.parameters = resolvedAstItem.params;\r\n        documentation.returnsMessage = resolvedAstItem.returnsMessage;\r\n        break;\r\n      case AstItemKind.Method:\r\n      case AstItemKind.Constructor:\r\n        documentation.parameters = resolvedAstItem.params;\r\n        documentation.returnsMessage = resolvedAstItem.returnsMessage;\r\n        break;\r\n    }\r\n\r\n    // Check if inheritdoc is depreacted\r\n    // We need to check if this documentation has a deprecated message\r\n    // but it may not appear until after this token.\r\n    if (resolvedAstItem.deprecatedMessage.length > 0) {\r\n      documentation.isDocInheritedDeprecated = true;\r\n    }\r\n  }\r\n}"],"sourceRoot":"..\\src"}