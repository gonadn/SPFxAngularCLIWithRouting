{"version":3,"sources":["markup/Markup.ts"],"names":[],"mappings":"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","file":"markup/Markup.js","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport {\r\n  MarkupElement,\r\n  MarkupBasicElement,\r\n  IMarkupWebLink,\r\n  IMarkupApiLink,\r\n  IMarkupText,\r\n  IMarkupParagraph,\r\n  IMarkupLineBreak,\r\n  IMarkupTable,\r\n  IMarkupTableRow,\r\n  IMarkupTableCell,\r\n  IMarkupHeading1,\r\n  IMarkupHeading2,\r\n  IMarkupPage,\r\n  IMarkupHighlightedText,\r\n  MarkupLinkTextElement,\r\n  IMarkupNoteBox,\r\n  IMarkupCodeBox,\r\n  MarkupHighlighter\r\n} from './MarkupElement';\r\n\r\nimport { IApiItemReference } from '../api/ApiItem';\r\n\r\n/**\r\n * Options for {@link Markup.createTextElements}\r\n *\r\n * @public\r\n */\r\nexport interface IMarkupCreateTextOptions {\r\n  /**\r\n   * Whether the text should be boldfaced.\r\n   */\r\n  bold?: boolean;\r\n\r\n  /**\r\n   * Whether the text should be italicized.\r\n   */\r\n  italics?: boolean;\r\n}\r\n\r\n/**\r\n * Provides various operations for working with MarkupElement objects.\r\n *\r\n * @public\r\n */\r\nexport class Markup {\r\n  /**\r\n   * A predefined constant for the IMarkupLineBreak element.\r\n   */\r\n  public static BREAK: IMarkupLineBreak = {\r\n    kind: 'break'\r\n  };\r\n\r\n  /**\r\n   * A predefined constant for the IMarkupParagraph element.\r\n   */\r\n  public static PARAGRAPH: IMarkupParagraph = {\r\n    kind: 'paragraph'\r\n  };\r\n\r\n  /**\r\n   * Constructs an IMarkupText element representing the specified text string, with\r\n   * optional formatting.\r\n   *\r\n   * @remarks\r\n   * NOTE: All whitespace (including newlines) will be collapsed to single spaces.\r\n   * This behavior is similar to how HTML handles whitespace.  To preserve\r\n   * newlines, use {@link Markup.createTextParagraphs} instead.\r\n   */\r\n  public static createTextElements(text: string, options?: IMarkupCreateTextOptions): IMarkupText[] {\r\n    if (!text) {\r\n      return [];\r\n    } else {\r\n      const result: IMarkupText = {\r\n        kind: 'text',\r\n        text: Markup._trimRawText(text)\r\n      } as IMarkupText;\r\n\r\n      if (options) {\r\n        if (options.bold) {\r\n          result.bold = true;\r\n        }\r\n        if (options.italics) {\r\n          result.italics = true;\r\n        }\r\n      }\r\n\r\n      // The return value is represented as an array containing at most one element.\r\n      // Another possible design would be to return a single IMarkupText object that\r\n      // is possibly undefined; however, in practice appending arrays turns out to be\r\n      // more concise than checking for undefined.\r\n      return [ result ];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * This function is similar to {@link Markup.createTextElements}, except that multiple newlines\r\n   * will be converted to a Markup.PARAGRAPH object.\r\n   */\r\n  public static createTextParagraphs(text: string, options?: IMarkupCreateTextOptions): MarkupBasicElement[] {\r\n    const result: MarkupBasicElement[] = [];\r\n\r\n    if (text) {\r\n      // Split up the paragraphs\r\n      for (const paragraph of text.split(/\\n\\s*\\n/g)) {\r\n        if (result.length > 0) {\r\n          result.push(Markup.PARAGRAPH);\r\n        }\r\n        result.push(...Markup.createTextElements(paragraph, options));\r\n      }\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Constructs an IMarkupApiLink element that represents a hyperlink to the specified\r\n   * API object.  The hyperlink is applied to an existing stream of markup elements.\r\n   * @param textElements - the markup sequence that will serve as the link text\r\n   * @param target - the API object that the hyperlink will point to\r\n   */\r\n  public static createApiLink(textElements: MarkupLinkTextElement[], target: IApiItemReference): IMarkupApiLink {\r\n    if (!textElements.length) {\r\n      throw new Error('Missing text for link');\r\n    }\r\n\r\n    if (!target.packageName || target.packageName.length < 1) {\r\n      throw new Error('The IApiItemReference.packageName cannot be empty');\r\n    }\r\n\r\n    return {\r\n      kind: 'api-link',\r\n      elements: textElements,\r\n      target: target\r\n    } as IMarkupApiLink;\r\n  }\r\n\r\n  /**\r\n   * Constructs an IMarkupApiLink element that represents a hyperlink to the specified\r\n   * API object.  The hyperlink is applied to a plain text string.\r\n   * @param text - the text string that will serve as the link text\r\n   * @param target - the API object that the hyperlink will point to\r\n   */\r\n  public static createApiLinkFromText(text: string, target: IApiItemReference): IMarkupApiLink {\r\n    return Markup.createApiLink(Markup.createTextElements(text), target);\r\n  }\r\n\r\n  /**\r\n   * Constructs an IMarkupWebLink element that represents a hyperlink an internet URL.\r\n   * @param textElements - the markup sequence that will serve as the link text\r\n   * @param targetUrl - the URL that the hyperlink will point to\r\n   */\r\n  public static createWebLink(textElements: MarkupLinkTextElement[], targetUrl: string): IMarkupWebLink {\r\n    if (!textElements.length) {\r\n      throw new Error('Missing text for link');\r\n    }\r\n    if (!targetUrl || !targetUrl.trim()) {\r\n      throw new Error('Missing link target');\r\n    }\r\n\r\n    return {\r\n      kind: 'web-link',\r\n      elements: textElements,\r\n      targetUrl: targetUrl\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Constructs an IMarkupWebLink element that represents a hyperlink an internet URL.\r\n   * @param text - the plain text string that will serve as the link text\r\n   * @param targetUrl - the URL that the hyperlink will point to\r\n   */\r\n  public static createWebLinkFromText(text: string, targetUrl: string): IMarkupWebLink {\r\n    return Markup.createWebLink(Markup.createTextElements(text), targetUrl);\r\n  }\r\n\r\n  /**\r\n   * Constructs an IMarkupHighlightedText element representing a program code text\r\n   * with optional syntax highlighting\r\n   */\r\n  public static createCode(code: string, highlighter?: MarkupHighlighter): IMarkupHighlightedText {\r\n    if (!code) {\r\n      throw new Error('The code parameter is missing');\r\n    }\r\n    return {\r\n      kind: 'code',\r\n      text: code,\r\n      highlighter: highlighter || 'plain'\r\n    } as IMarkupHighlightedText;\r\n  }\r\n\r\n  /**\r\n   * Constructs an IMarkupHeading1 element with the specified title text\r\n   */\r\n  public static createHeading1(text: string): IMarkupHeading1 {\r\n    return {\r\n      kind: 'heading1',\r\n      text: Markup._trimRawText(text)\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Constructs an IMarkupHeading2 element with the specified title text\r\n   */\r\n  public static createHeading2(text: string): IMarkupHeading2 {\r\n    return {\r\n      kind: 'heading2',\r\n      text: Markup._trimRawText(text)\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Constructs an IMarkupCodeBox element representing a program code text\r\n   * with the specified syntax highlighting\r\n   */\r\n  public static createCodeBox(code: string, highlighter: MarkupHighlighter): IMarkupCodeBox {\r\n    if (!code) {\r\n      throw new Error('The code parameter is missing');\r\n    }\r\n    return {\r\n      kind: 'code-box',\r\n      text: code,\r\n      highlighter: highlighter\r\n    } as IMarkupCodeBox;\r\n  }\r\n\r\n  /**\r\n   * Constructs an IMarkupNoteBox element that will display the specified markup content\r\n   */\r\n  public static createNoteBox(textElements: MarkupBasicElement[]): IMarkupNoteBox {\r\n    return {\r\n      kind: 'note-box',\r\n      elements: textElements\r\n    } as IMarkupNoteBox;\r\n  }\r\n\r\n  /**\r\n   * Constructs an IMarkupNoteBox element that will display the specified plain text string\r\n   */\r\n  public static createNoteBoxFromText(text: string): IMarkupNoteBox {\r\n    return Markup.createNoteBox(Markup.createTextElements(text));\r\n  }\r\n\r\n  /**\r\n   * Constructs an IMarkupTableRow element containing the specified cells, which each contain a\r\n   * sequence of MarkupBasicElement content\r\n   */\r\n  public static createTableRow(cellValues: MarkupBasicElement[][] | undefined = undefined): IMarkupTableRow {\r\n    const row: IMarkupTableRow = {\r\n      kind: 'table-row',\r\n      cells: []\r\n    };\r\n\r\n    if (cellValues) {\r\n      for (const cellValue of cellValues) {\r\n        const cell: IMarkupTableCell = {\r\n          kind: 'table-cell',\r\n          elements: cellValue\r\n        };\r\n        row.cells.push(cell);\r\n      }\r\n    }\r\n\r\n    return row;\r\n  }\r\n\r\n  /**\r\n   * Constructs an IMarkupTable element containing the specified header cells, which each contain a\r\n   * sequence of MarkupBasicElement content.\r\n   * @remarks\r\n   * The table initially has zero rows.\r\n   */\r\n  public static createTable(headerCellValues: MarkupBasicElement[][] | undefined = undefined): IMarkupTable {\r\n    let header: IMarkupTableRow | undefined = undefined;\r\n    if (headerCellValues) {\r\n      header = Markup.createTableRow(headerCellValues);\r\n    }\r\n    return {\r\n      kind: 'table',\r\n      header: header,\r\n      rows: []\r\n    } as IMarkupTable;\r\n  }\r\n\r\n  /**\r\n   * Constructs an IMarkupTable element with the specified title.\r\n   */\r\n  public static createPage(title: string): IMarkupPage {\r\n    return {\r\n      kind: 'page',\r\n      breadcrumb: [],\r\n      title: Markup._trimRawText(title),\r\n      elements: []\r\n    } as IMarkupPage;\r\n  }\r\n\r\n  /**\r\n   * Extracts plain text from the provided markup elements, discarding any formatting.\r\n   *\r\n   * @remarks\r\n   * The returned string is suitable for counting words or extracting search keywords.\r\n   * Its formatting is not guaranteed, and may change in future updates of this API.\r\n   *\r\n   * API Extractor determines whether an API is \"undocumented\" by using extractTextContent()\r\n   * to extract the text from its summary, and then counting the number of words.\r\n   */\r\n  public static extractTextContent(elements: MarkupElement[]): string {\r\n    // Pass a buffer, since \"+=\" uses less memory than \"+\"\r\n    const buffer: { text: string } = { text: '' };\r\n    Markup._extractTextContent(elements, buffer);\r\n    return buffer.text;\r\n  }\r\n\r\n  /**\r\n   * Use this to clean up a MarkupElement sequence, assuming the sequence is now in\r\n   * its final form.\r\n   *\r\n   * @remarks\r\n   * The following operations are performed:\r\n   *\r\n   * 1. Remove leading/trailing white space around paragraphs\r\n   *\r\n   * 2. Remove redundant paragraph elements\r\n   */\r\n  public static normalize<T extends MarkupElement>(elements: T[]): void {\r\n    let i: number = 0;\r\n\r\n    while (i < elements.length) {\r\n      const element: T = elements[i];\r\n      const previousElement: T | undefined = i - 1 >= 0 ? elements[i - 1] : undefined;\r\n      const nextElement: T | undefined = i + 1 < elements.length ? elements[i + 1] : undefined;\r\n\r\n      const paragraphBefore: boolean = previousElement && previousElement.kind === 'paragraph';\r\n      const paragraphAfter: boolean = nextElement && nextElement.kind === 'paragraph';\r\n\r\n      if (element.kind === 'paragraph') {\r\n        if (i === 0 || i === elements.length - 1 || paragraphBefore) {\r\n          // Delete this element.  We do not update i because the \"previous\" item\r\n          // is unchanged on the next loop.\r\n          elements.splice(i, 1);\r\n          continue;\r\n        }\r\n      } else if (element.kind === 'text') {\r\n        const textElement: IMarkupText = element as IMarkupText;\r\n        if (paragraphBefore || i === 0) {\r\n          textElement.text = textElement.text.replace(/^\\s+/, ''); // trim left\r\n        }\r\n\r\n        if (paragraphAfter || i === elements.length - 1) {\r\n          textElement.text = textElement.text.replace(/\\s+$/, ''); // trim right\r\n        }\r\n      }\r\n\r\n      ++i;\r\n    }\r\n  }\r\n\r\n  private static _extractTextContent(elements: MarkupElement[], buffer: { text: string }): void {\r\n    for (const element of elements) {\r\n      switch (element.kind) {\r\n        case 'api-link':\r\n          buffer.text += Markup.extractTextContent(element.elements);\r\n          break;\r\n        case 'break':\r\n          buffer.text += '\\n';\r\n          break;\r\n        case 'code':\r\n        case 'code-box':\r\n          break;\r\n        case 'heading1':\r\n        case 'heading2':\r\n          buffer.text += element.text;\r\n          break;\r\n        case 'note-box':\r\n          buffer.text += Markup.extractTextContent(element.elements);\r\n          break;\r\n        case 'page':\r\n          buffer.text += element.title + '\\n';\r\n          buffer.text += Markup.extractTextContent(element.elements);\r\n          break;\r\n        case 'paragraph':\r\n          buffer.text += '\\n\\n';\r\n          break;\r\n        case 'table':\r\n          buffer.text += Markup.extractTextContent([element.header])\r\n            + Markup.extractTextContent(element.rows);\r\n          break;\r\n        case 'table-cell':\r\n          buffer.text += Markup.extractTextContent(element.elements);\r\n          buffer.text += '\\n';\r\n          break;\r\n        case 'table-row':\r\n          buffer.text += Markup.extractTextContent(element.cells);\r\n          buffer.text += '\\n';\r\n          break;\r\n        case 'text':\r\n          buffer.text += element.text;\r\n          break;\r\n        case 'web-link':\r\n          buffer.text += Markup.extractTextContent(element.elements);\r\n          break;\r\n        default:\r\n          throw new Error('Unsupported element kind');\r\n      }\r\n    }\r\n  }\r\n\r\n  private static _trimRawText(text: string): string {\r\n    // Replace multiple whitespaces with a single space\r\n    return text.replace(/\\s+/g, ' ');\r\n  }\r\n}\r\n"],"sourceRoot":"..\\..\\src"}