"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const node_core_library_1 = require("@microsoft/node-core-library");
const ServeTask_1 = require("@microsoft/gulp-core-build-serve/lib/ServeTask");
// NodeJS currently lacks an implementation of the URL class, so we should use our polyfill until NodeJS gets one
const URL_complete_1 = require("@microsoft/sp-polyfills/lib/url/experimental/URL-complete");
const CONFIG_CLI_PARAMETER = 'config';
exports.DEBUG_MANIFESTS_QUERY_PARAMETER = 'debugManifestsFile';
const LOAD_SPFX_QUERY_PARAMETER = 'loadSPFX';
const CUSTOM_ACTIONS_QUERY_PARAMETER = 'customActions';
const FIELD_CUSTOMIZERS_QUERY_PARAMETER = 'fieldCustomizers';
class SpfxServeTask extends ServeTask_1.ServeTask {
    constructor() {
        super('spfx-serve', {});
        this._defaultInitialPage = this.taskConfig.initialPage;
    }
    executeTask(gulp, completeCallback) {
        this._loadGulpConnect();
        const selectedServeConfiguration = this.buildConfig.args[CONFIG_CLI_PARAMETER];
        let serveConfiguration;
        if (selectedServeConfiguration) {
            this.logVerbose(`Attempting to use serve configuration: "${selectedServeConfiguration}"`);
            serveConfiguration = this.taskConfig.serveConfigurations[selectedServeConfiguration];
            if (!serveConfiguration) {
                this.logWarning(`Selected serve configuration "${selectedServeConfiguration}" is not present in the ` +
                    'task configuration. Falling back to default configuration.');
            }
        }
        if (!serveConfiguration && this.taskConfig.serveConfigurations) {
            serveConfiguration = this.taskConfig.serveConfigurations.default;
            if (serveConfiguration && this.taskConfig.initialPage !== this._defaultInitialPage) {
                this.logWarning('Both a default serve configuration and an initialPage are specified. In this task, ' +
                    'the default configuration takes precedence. Consider removing the initialPage property.');
            }
        }
        if (serveConfiguration) {
            this.taskConfig.initialPage = this._convertServeConfigurationToPageUrl(serveConfiguration);
        }
        return super.executeTask(gulp, completeCallback);
    }
    loadSchema() {
        const baseSchema = super.loadSchema();
        const spfxServeSchema = node_core_library_1.JsonFile.load(path.join(__dirname, 'spfx-serve.schema.json'));
        // Include all of the properties from the base schema
        for (const propertyName in baseSchema.properties) {
            if (baseSchema.properties.hasOwnProperty(propertyName)) {
                spfxServeSchema.properties[propertyName] = baseSchema.properties[propertyName];
            }
        }
        if (baseSchema.definitions) {
            // Include all of the definitions from the base schema
            for (const definitionName in baseSchema.definitions) {
                if (baseSchema.definitions.hasOwnProperty(definitionName)) {
                    spfxServeSchema.definitions[definitionName] = baseSchema.definitions[definitionName];
                }
            }
        }
        return spfxServeSchema;
    }
    _getConfigFilePath() {
        // Make sure this task uses the "serve.json" config file, not "spfx-serve.json"
        return path.join(path.dirname(super._getConfigFilePath()), 'serve.json');
    }
    _convertServeConfigurationToPageUrl(serveConfiguration) {
        if (!serveConfiguration.pageUrl) {
            this.logError('The pageUrl property of the selected serve configuration must be set.');
            return undefined;
        }
        const url = new URL_complete_1.default(serveConfiguration.pageUrl);
        if (!url.searchParams.has(exports.DEBUG_MANIFESTS_QUERY_PARAMETER)) {
            const manifestsJsUrl = this._getBaseServeUrl();
            manifestsJsUrl.pathname = 'temp/manifests.js';
            url.searchParams.set(exports.DEBUG_MANIFESTS_QUERY_PARAMETER, manifestsJsUrl.href);
        }
        if (serveConfiguration.customActions || serveConfiguration.fieldCustomizers) {
            if (!url.searchParams.has(LOAD_SPFX_QUERY_PARAMETER)) {
                url.searchParams.set(LOAD_SPFX_QUERY_PARAMETER, 'true');
            }
        }
        if (serveConfiguration.customActions) {
            url.searchParams.set(CUSTOM_ACTIONS_QUERY_PARAMETER, JSON.stringify(serveConfiguration.customActions));
        }
        if (serveConfiguration.fieldCustomizers) {
            url.searchParams.set(FIELD_CUSTOMIZERS_QUERY_PARAMETER, JSON.stringify(serveConfiguration.fieldCustomizers));
        }
        return url.href;
    }
    _getBaseServeUrl() {
        const taskConfig = this.taskConfig;
        return new URL_complete_1.default(`${taskConfig.https ? 'https' : 'http'}://${taskConfig.hostname}:${taskConfig.port}/`);
    }
    ///
    /// THE CODE BELOW IS A TEMPORARY PORT FROM THIS PR FOR GULP-CORE-BUILD-SERVE:
    /// https://github.com/Microsoft/web-build-tools/pull/502
    ///
    /**
     * Workaround for loading gulp-connect, which automatically uses http2 if it
     * can require() a module called 'http2'
     *
     * https://github.com/AveVlad/gulp-connect/issues/246
     *
     * In versions of NodeJS < 8:
     *   'http2' would have to be a module in the node_modules folder.
     *   We did not provide this normally, so most of the time nobody used http2 with gulp serve.
     *
     * However, in versions of NodeJS >= 8:
     *   They provide a built-in module called 'http2', which is experimental and unstable
     *   The built-in module is preferred unless an environment variable is set: NODE_NO_HTTP2=1
     *
     * We don't want to enforce environmental requirements, nor
     * do we want to support a toolchain that relies on an experimental API.
     *
     * Until gulp-connect provides a way to disable HTTP2, we're using this workaround:
     * Inject a falsey value into the require() cache, require gulp-connect,
     * then restore the old cache state.
     *
     * As a consequence, this approach will prevent "gulp-connect" from using http2 in
     * environments with Node < 8. This is intentional, because we don't see a reason to
     * support http2 for serving localhost scripts.
     */
    // tslint:disable-next-line:no-any
    _loadGulpConnect() {
        // this will raise an exception if it can't find http2,
        // which happens if we are on Node6 and 'http2' has not been required yet
        let http2CacheKey = 'http2';
        try {
            http2CacheKey = require.resolve('http2');
        }
        catch (exception) {
            // no-op
        }
        /* tslint:disable:typedef */
        let gulpConnect;
        // node 6 and http2 is in cache
        if (Object.keys(require.cache).indexOf(http2CacheKey) !== -1) {
            // store the old cache value
            const http2CacheObject = require.cache[http2CacheKey];
            require.cache[http2CacheKey] = { exports: undefined };
            gulpConnect = require('gulp-connect');
            // restore the old cache value
            require.cache[http2CacheKey] = http2CacheObject;
        }
        else {
            // node 8 or http2 is not in cache, insert a module with no exports into cache
            require.cache[http2CacheKey] = { exports: undefined };
            gulpConnect = require('gulp-connect');
            // remove module with no exports from cache
            delete require.cache[http2CacheKey];
        }
        /* tslint:enable:typedef */
        return gulpConnect;
    }
}
exports.SpfxServeTask = SpfxServeTask;

//# sourceMappingURL=SpfxServeTask.js.map
