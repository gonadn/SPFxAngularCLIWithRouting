"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = require("lodash");
const fsx = require("fs-extra");
const merge = require("merge2");
const path = require("path");
const os_1 = require("os");
const manifestSchemaValidator_1 = require("@microsoft/sp-module-interfaces/lib/manifestSchemaValidator");
const FileUtils_1 = require("./../utilities/FileUtils");
const OdspGulpTask_1 = require("./../OdspGulpTask");
const cumulativeManifestProcessor_1 = require("./../cumulativeManifestProcessor");
const url_1 = require("./../utilities/url");
const normalizeLocaleName_1 = require("./../utilities/normalizeLocaleName");
const constants_1 = require("./../constants");
const schemaPropertyName = '$schema';
/**
 * The type of icon URL defined in a user-created manifest.
 */
var IconPathType;
(function (IconPathType) {
    /**
     * Something that doesn't fit into another category. A warning will be printed.
     */
    IconPathType[IconPathType["Malformed"] = 0] = "Malformed";
    /**
     * An absolute URL. Something that begins with a protocol (i.e. - http://...).
     */
    IconPathType[IconPathType["AbsoluteUrl"] = 1] = "AbsoluteUrl";
    /**
     * A relative URL. Something that begins with an alphanumeric character, but doesn't look like a protocol.
     */
    IconPathType[IconPathType["RelativeUrl"] = 2] = "RelativeUrl";
    /**
     * A relative filesystem path. Something that begins with "./" or "../"
     */
    IconPathType[IconPathType["RelativePath"] = 3] = "RelativePath";
})(IconPathType = exports.IconPathType || (exports.IconPathType = {}));
function getIconPathType(iconPath) {
    if (!iconPath) {
        return undefined;
    }
    else if (iconPath.match(/^\.{1,2}\/.+/)) {
        return IconPathType.RelativePath;
    }
    else if (iconPath.match(/^\w+:\/\/.+/)) {
        return IconPathType.AbsoluteUrl;
    }
    else if (iconPath.match(/^\w+/)) {
        return IconPathType.RelativeUrl;
    }
    else {
        return IconPathType.Malformed;
    }
}
exports.getIconPathType = getIconPathType;
/**
 * Writes a manifest for each entry in the project.
 *
 * Example:
 *  IN:
 *   the result of the prepareDeploy step enumerating each entry, each entry's dependencies, and a developer-generated
 *    base manifest for each entry.
 *
 *  OUT:
 *   a debug and, optionally, a production manifest for each entry.
 */
class WriteManifestsTask extends OdspGulpTask_1.default {
    constructor() {
        super('write-manifests', {
            deployCdnPath: undefined,
            debugLocale: constants_1.default.defaultLocale,
            cdnUrlPrefix: undefined,
            cdnBasePath: undefined,
            cumulativeManifestOptions: {
                ignoreOutputManifestIds: undefined
            }
        });
        // tslint:disable-next-line:no-any
        this._localizedResourcesCache = {};
    }
    loadSchema() {
        return require('./write-manifests.schema.json');
    }
    executeTask(gulp, completeCallback) {
        if (!this.properties.deployEntries || this.properties.deployEntries.length === 0) {
            // Suppressed warning for now to unblock CI. VSO#219493
            this.log /*Warning*/('No deploy entries specified. No manifests to write.');
            completeCallback();
            return;
        }
        const shouldProduceDebugManifests = !!this.taskConfig.debugBasePath;
        if (!this.taskConfig.debugBasePath) {
            this.log('Debug base path not specified. Unable to produce debug manifests.');
        }
        let shouldProduceProductionManifests = this.buildConfig.production && !!this.taskConfig.cdnBasePath;
        if (this.buildConfig.production && !this.taskConfig.cdnBasePath) {
            this.logWarning('CDN base path not specified. Unable to produce production manifests.');
        }
        if (this.buildConfig.production && !this.taskConfig.deployCdnPath) {
            shouldProduceProductionManifests = false;
            // Suppressed warning for now to unblock CI. VSO#219493
            this.log /*Warning*/('CDN deploy path not specified. Unable to produce production manifests.');
        }
        this.taskConfig.debugLocale = normalizeLocaleName_1.default(this.taskConfig.debugLocale);
        this.logVerbose(`Using debug locale: ${this.taskConfig.debugLocale}`);
        const debugManifests = [];
        const manifestIds = {};
        const tasks = [];
        this.properties.deployEntries.forEach((deployEntry) => {
            const componentKeys = Object.keys(deployEntry.bundleEntry.components);
            componentKeys.forEach((id) => {
                const bundleComponent = deployEntry.bundleEntry.components[id];
                if (componentKeys.length === 1) {
                    // Only one component - we don't care about the ID
                    id = undefined;
                }
                if (!bundleComponent.manifestData) {
                    this.logWarning(`Manifest not defined for entry "${deployEntry.entryName}".`);
                    return;
                }
                const validationResult = manifestSchemaValidator_1.default.validateManifest(JSON.stringify(bundleComponent.manifestData));
                if (!validationResult.result) {
                    const errorText = manifestSchemaValidator_1.default.getFormattedErrorMessage(validationResult.errors);
                    const manifestPath = bundleComponent.manifest;
                    this.logError(`Manifest validation error (${manifestPath}): ${os_1.EOL}${errorText}`);
                    return;
                }
                // Ensure we don't have a duplicate ID
                const lowercaseId = bundleComponent.manifestData.id.toLowerCase();
                if (lowercaseId in manifestIds) {
                    this.logError(`Duplicate manifest ID "${lowercaseId}". Exists in "${manifestIds[lowercaseId].manifest}" ` +
                        `and "${bundleComponent.manifest}".`);
                }
                else {
                    manifestIds[lowercaseId] = bundleComponent;
                }
                if (shouldProduceDebugManifests) {
                    let debugManifest = this._doComponentTypeSpecificFixup(true, bundleComponent.manifestData, bundleComponent.manifestPath, this.taskConfig.debugLocale);
                    const loaderConfig = this._generateLoaderConfig(id, deployEntry.debugModules, [this.taskConfig.debugBasePath], this._resolveDebugPath.bind(this), 
                    // Keep the default path the same between CDN and debug manifests during a
                    //  production build
                    this.buildConfig.production ? undefined : this.taskConfig.debugLocale, !this.buildConfig.production);
                    debugManifest = this._generateManifest(debugManifest, loaderConfig);
                    this._doFinalManifestFixup(debugManifest);
                    let updatedManifest;
                    if (this.taskConfig.postProcessDebugManifestsFunction) {
                        updatedManifest = this.taskConfig.postProcessDebugManifestsFunction(debugManifest);
                    }
                    else {
                        updatedManifest = debugManifest;
                    }
                    debugManifests.push(updatedManifest);
                    tasks.push(FileUtils_1.writeStringToFile(JSON.stringify(updatedManifest, undefined, 2), `${debugManifest.id}.manifest.json`)
                        .pipe(gulp.dest(this.buildConfig.distFolder)));
                }
                if (shouldProduceProductionManifests) {
                    let productionManifest = this._doComponentTypeSpecificFixup(false, bundleComponent.manifestData, bundleComponent.manifestPath, constants_1.default.defaultLocale);
                    const loaderConfig = this._generateLoaderConfig(id, deployEntry.productionModules, [this.taskConfig.cdnBasePath], this._resolveProductionPath.bind(this));
                    productionManifest = this._generateManifest(productionManifest, loaderConfig);
                    this._doFinalManifestFixup(productionManifest);
                    let cdnManifest;
                    if (this.taskConfig.postProcessProductionManifestFunction) {
                        cdnManifest = this.taskConfig.postProcessProductionManifestFunction(productionManifest);
                    }
                    else {
                        cdnManifest = productionManifest;
                    }
                    tasks.push(FileUtils_1.writeStringToFile(JSON.stringify(cdnManifest), `${productionManifest.id}.json`)
                        .pipe(gulp.dest(this.taskConfig.deployCdnPath)));
                }
            });
        });
        merge(tasks).on('finish', () => {
            // Once this project's manifests are written, crawl the dependency tree discovering manifest files
            if (shouldProduceDebugManifests) {
                const cumulativeManifestOptions = this.taskConfig.cumulativeManifestOptions;
                cumulativeManifestOptions.baseUrl = this.taskConfig.debugBasePath;
                const cumulativeManifestProcessor = new cumulativeManifestProcessor_1.default(this, cumulativeManifestOptions);
                merge(cumulativeManifestProcessor.generateCumulativeManifest(gulp, debugManifests))
                    .on('finish', () => completeCallback());
            }
            else {
                completeCallback();
            }
        });
    }
    /**
     * Does some component-type-specific manifest processing.
     */
    _doComponentTypeSpecificFixup(isDebug, manifest, manifestPath, defaultLocale, onlyUseDefaultLocale) {
        const manifestClone = lodash_1.cloneDeep(manifest);
        switch (manifestClone.componentType) {
            case 'WebPart':
                this._processWebpartManifest(isDebug, manifestClone, // tslint:disable-line:no-any
                manifestPath, defaultLocale, onlyUseDefaultLocale);
                break;
            case 'Application':
                this._localizeApplicationManifest(manifestClone, defaultLocale, onlyUseDefaultLocale);
                break;
            case 'Extension':
                this._processExtensionsManifest(isDebug, manifestClone, manifestPath, defaultLocale, onlyUseDefaultLocale);
                break;
        }
        return manifestClone;
    }
    /**
     * Perform some final fixup on manifests.
     */
    _doFinalManifestFixup(manifest) {
        if (manifest.componentType === 'Application') {
            const applicationManifest = manifest;
            if (!applicationManifest.preloadComponents) {
                applicationManifest.preloadComponents = [];
            }
        }
    }
    /**
     * Does webpart-specific manifest processing.
     */
    _processWebpartManifest(isDebug, manifest, // tslint:disable-line:no-any
        manifestPath, defaultLocale, onlyUseDefaultLocale) {
        // tslint:disable-next-line:no-any
        manifest.preconfiguredEntries.forEach((entry) => {
            entry.title = this._localizeString(entry.title, defaultLocale, onlyUseDefaultLocale);
            entry.description = this._localizeString(entry.description, defaultLocale, onlyUseDefaultLocale);
            if (entry.group) {
                entry.group = this._localizeString(entry.group, defaultLocale, onlyUseDefaultLocale);
            }
            if (entry.tags) {
                entry.tags =
                    entry.tags.slice(0, 10).map(tag => this._localizeString(tag, defaultLocale, onlyUseDefaultLocale));
            }
            const resolvedIcon = this._processIconPath(isDebug, manifestPath, entry.iconImageUrl);
            if (resolvedIcon) {
                entry.iconImageUrl = resolvedIcon;
            }
        });
    }
    /**
     * Localizes an Application manifest. This includes title and description of the Application
     */
    _localizeApplicationManifest(manifest, defaultLocale, onlyUseDefaultLocale) {
        manifest.title = this._localizeString(manifest.title, defaultLocale, onlyUseDefaultLocale);
        manifest.description = this._localizeString(manifest.description, defaultLocale, onlyUseDefaultLocale);
    }
    /**
     * Does extension-specific manifest processing.
     */
    _processExtensionsManifest(isDebug, manifest, manifestPath, defaultLocale, onlyUseDefaultLocale) {
        switch (manifest.extensionType) {
            case 'ListViewCommandSet':
                const commandSetManifest = manifest;
                for (const itemId in commandSetManifest.items) {
                    if (commandSetManifest.items.hasOwnProperty(itemId)) {
                        const item = commandSetManifest.items[itemId];
                        item.title = this._localizeString(item.title, defaultLocale, onlyUseDefaultLocale);
                        if (item.ariaLabel) {
                            item.ariaLabel = this._localizeString(item.ariaLabel, defaultLocale, onlyUseDefaultLocale);
                        }
                        const resolvedIcon = this._processIconPath(isDebug, manifestPath, item.iconImageUrl);
                        if (resolvedIcon) {
                            item.iconImageUrl = resolvedIcon;
                        }
                    }
                }
                break;
            case 'Unknown':
            case 'ApplicationCustomizer':
            case 'FieldCustomizer':
                // No fields that require modificaiton
                break;
        }
    }
    /**
     * Localizes a string with an id in the web $moduleName:expression;
     * If the string to localize is not based on an id, it returns the input param untouched.
     */
    _localizeString(stringToLocalize, defaultLocale, onlyUseDefaultLocale) {
        // If there is no id, assume the property is either not localized, or the localized values are
        //  hardcoded.
        if (!stringToLocalize.id) {
            return stringToLocalize;
        }
        const regex = /^(?:\$)([^:]+)(?:\:)(.+)(?:\;)$/; // Test $<name>:<expr>;
        const matches = stringToLocalize.id.match(regex);
        if (matches && matches.length === 3) {
            this.logVerbose(`Localizing string '${matches[0]}'`);
            const localizedStrings = this._localizeStringInternal(
            /* resourceName */ matches[1], 
            /* expression */ matches[2], 
            /* stringId */ matches[0]);
            const normalizedDefaultLocale = normalizeLocaleName_1.default(defaultLocale);
            if (normalizedDefaultLocale) {
                // tslint:disable-next-line:no-string-literal
                localizedStrings['default'] = localizedStrings[normalizedDefaultLocale];
                if (!localizedStrings['default']) {
                    this.logError(`Unable to set default locale to "${normalizedDefaultLocale}". `
                        + `Ensure that resources exist for this locale.`);
                }
                if (onlyUseDefaultLocale) {
                    for (const locale of Object.keys(localizedStrings)) {
                        if (locale !== 'default') {
                            delete localizedStrings[locale];
                        }
                    }
                }
            }
            return localizedStrings;
        }
        else {
            this.logError(`String id '${stringToLocalize.id}' has wrong format. It is not $<moduleName>:<expression>;`);
            // Return an empty ILocalizedString
            return {
                default: ''
            };
        }
    }
    /**
     * Localizes a string where it's been verified that the id follows the schema.
     * @param resourceName Name of the resource to load
     * @param expression Expression to be evaluated on the resource
     * @stringId Original id for the string. Used for logging purposes only
     * @returns Localized string with all found locales
     */
    _localizeStringInternal(resourceName, expression, stringId) {
        const localizedString = {
            default: ''
        };
        const resources = this.properties.discoveredLocalizedResources[resourceName];
        if (resources) {
            for (const locale in resources) {
                if (resources.hasOwnProperty(locale)) {
                    const resource = this._getResource(resources[locale]); // tslint:disable-line:no-any
                    const normalizedLocaleName = normalizeLocaleName_1.default(locale);
                    if (resource) {
                        const evalString = expression.replace(resourceName, 'r');
                        let stringFromExpression = undefined;
                        try {
                            /* tslint:disable:no-any */
                            // tslint:disable-next-line:no-unused-variable
                            const shallowDiscoverProperty = (resourceData, propertyName) => {
                                /* tslint:enable:no-any */
                                const foundBuckets = [];
                                let firstFoundValue;
                                for (const bucketName in resourceData) {
                                    if (resourceData[bucketName] && resourceData[bucketName][propertyName]) {
                                        firstFoundValue = resourceData[bucketName][propertyName];
                                        foundBuckets.push(bucketName);
                                    }
                                }
                                if (!firstFoundValue) {
                                    throw new Error(`A value for a property "${propertyName}" was not found inside any ` +
                                        `property of the resource object.`);
                                }
                                if (foundBuckets.length !== 1) {
                                    throw new Error(`A value for a property "${propertyName}" was found inside multiple ` +
                                        `properties of the resource object and must be disambiguated to be selected.`);
                                }
                                return firstFoundValue;
                            };
                            // We support any format for the localized resource,
                            // so we rely on the developer telling the code how to access it.
                            // Eval generates risk. In order to minimize it, only one expression is allowed.
                            // tslint:disable-next-line:no-eval
                            stringFromExpression = eval('function getLocalizedString(r) {' +
                                'return ' + evalString +
                                '}' +
                                'getLocalizedString(resource)');
                        }
                        catch (error) {
                            this.logWarning(`Problem extracting id '${stringId}' in locale '${normalizedLocaleName}'. ` +
                                `Error: ${error}`);
                        }
                        if (stringFromExpression) {
                            localizedString[normalizedLocaleName] = stringFromExpression;
                        }
                        else {
                            this.logWarning(`Couldn't find id '${stringId}' in locale '${normalizedLocaleName}'`);
                        }
                    }
                }
            }
        }
        else {
            this.logError(`Localized module '${resourceName}' not found`);
        }
        return localizedString;
    }
    /**
     * Computes where an icon is on disk, copies it to the appropriate deployment directory
     *  depending on build flavor, and returns the correct path for the manifest.
     */
    _processIconPath(isDebug, manifestPath, iconPath) {
        const iconPathType = getIconPathType(iconPath);
        if (iconPathType) {
            switch (iconPathType) {
                case IconPathType.RelativePath:
                    const iconAbsolutePath = path.join(path.dirname(manifestPath), iconPath);
                    this.logVerbose(`Found relative icon path "${iconPath}", resolved to "${iconAbsolutePath}"`);
                    let iconResult;
                    if (!fsx.existsSync(iconAbsolutePath)) {
                        this.logError(`Icon file missing from resolved path "${iconAbsolutePath}." The icon will be missing.`);
                    }
                    else {
                        const ext = path.extname(iconAbsolutePath);
                        const iconBaseName = path.basename(iconAbsolutePath, ext);
                        const iconFilename = `${iconBaseName}_${FileUtils_1.getFullHash(fsx.readFileSync(iconAbsolutePath))}${ext}`;
                        if (isDebug) {
                            // Debug icon should be relative to the serve root
                            iconResult = path.join(this.buildConfig.distFolder, iconFilename).replace(/\\/g, '/');
                            fsx.copySync(iconAbsolutePath, path.join(this.buildConfig.rootPath, this.buildConfig.distFolder, iconFilename));
                        }
                        else {
                            // Production icon must be copied to the deployment directory
                            iconResult = this._resolveProductionPath(iconFilename);
                            fsx.copySync(iconAbsolutePath, path.join(this.taskConfig.deployCdnPath, iconFilename));
                        }
                    }
                    return iconResult;
                case IconPathType.AbsoluteUrl:
                    this.logVerbose(`Found absolute icon URL "${iconPath}"`);
                    break;
                case IconPathType.RelativeUrl:
                    this.logWarning(`The icon path "${iconPath}" appears to be a relative web URL. This means that when the ` +
                        'is rendered, this URL will be relative to the CDN url for the rest of the package assets. If a relative ' +
                        'filesystem path was intended, prepend the path with "./".');
                    break;
                default:
                    this.logWarning(`The icon path "${iconPath}" appears to be malformed. The icon may not render as expected.`);
                    break;
            }
            return iconPath;
        }
        else {
            return undefined;
        }
    }
    /**
     * Gets a resource file from a path.
     */
    // tslint:disable-next-line:no-any
    _getResource(resourcePath) {
        if (!this._localizedResourcesCache[resourcePath]) {
            this._cacheResource(resourcePath);
        }
        return this._localizedResourcesCache[resourcePath];
    }
    /**
     * Caches a resource file from a path.
     * Because this execute in the build tools, function define is not defined,
     * so a fake function is created that will return the default element of the module.
     */
    _cacheResource(resourcePath) {
        // Fake a define method to get the localizedResource module
        // tslint:disable-next-line:no-unused-variable no-any
        function define(name, deps, callback) {
            if (typeof name !== 'string') {
                callback = deps;
                deps = name;
                name = undefined;
            }
            if (!Array.isArray(deps)) {
                callback = deps;
                deps = undefined;
            }
            const exports = {}; // tslint:disable-line:no-any
            const result = callback([undefined, exports]); // tslint:disable-line:no-any
            return result.default || result || exports.default;
        }
        try {
            // We can't get the localized module dynamically at this point.
            // Reading and executing the module file in order to get the module
            const resourcesFile = fsx.readFileSync(resourcePath, 'utf8');
            // tslint:disable-next-line:no-eval
            const resource = eval(resourcesFile); // tslint:disable-line:no-any
            this._localizedResourcesCache[resourcePath] = resource;
        }
        catch (error) {
            this.logError(`Can't get resource '${resourcePath}'. ` +
                "Check that the module is correct and has doesn't require any external module.");
        }
    }
    _generateManifest(manifest, loaderConfig) {
        delete manifest[schemaPropertyName];
        manifest.loaderConfig = loaderConfig;
        return manifest;
    }
    _generateLoaderConfig(entrypointExportName, deployModules, internalModuleBaseUrls, resolvePath, defaultLocaleOverride, onlyUseDefaultLocale) {
        const scriptResources = {};
        if (deployModules.pathModules) {
            deployModules.pathModules.forEach((module, id) => {
                // Clone the module so we can make changes to it
                module = lodash_1.cloneDeep(module);
                module.type = 'path';
                scriptResources[id] = module;
                module.path = resolvePath(module.path);
            });
        }
        if (deployModules.localizedPathModules) {
            deployModules.localizedPathModules.forEach((module, id) => {
                // Clone the module so we can make changes to it
                module = lodash_1.cloneDeep(module);
                module.type = 'localizedPath';
                scriptResources[id] = module;
                const oldPaths = module.paths;
                module.paths = {};
                const lowercaseLocales = {};
                for (const locale in oldPaths) {
                    if (oldPaths.hasOwnProperty(locale)) {
                        const resourcePath = oldPaths[locale];
                        const lowercaseLocale = locale.toLowerCase();
                        const normalizedLocale = normalizeLocaleName_1.default(lowercaseLocale);
                        lowercaseLocales[lowercaseLocale] = normalizedLocale;
                        module.paths[normalizedLocale] = resolvePath(resourcePath);
                    }
                }
                const lowercaseDefaultLocaleOverride = (defaultLocaleOverride && defaultLocaleOverride.toLowerCase)
                    ? defaultLocaleOverride.toLowerCase()
                    : undefined;
                if (lowercaseDefaultLocaleOverride && lowercaseDefaultLocaleOverride in lowercaseLocales) {
                    module.defaultPath = module.paths[lowercaseLocales[lowercaseDefaultLocaleOverride]];
                    if (Object.keys(module.paths).length <= 1) {
                        // Delete the paths object if the only built path is the default
                        delete module.paths;
                    }
                }
                else {
                    module.defaultPath = resolvePath(module.defaultPath);
                }
                if (onlyUseDefaultLocale && module.defaultPath) {
                    delete module.paths;
                }
            });
        }
        if (deployModules.componentModules) {
            deployModules.componentModules.forEach((module, id) => {
                // Clone the module so we can make changes to it
                module = lodash_1.cloneDeep(module);
                module.type = 'component';
                scriptResources[id] = module;
                if (module.failoverPath) {
                    module.failoverPath = resolvePath(module.failoverPath);
                }
            });
        }
        if (!(deployModules.entryModuleId in scriptResources)) {
            this.logError(`Entry module "${deployModules.entryModuleId}" is missing a definition. The manifest will not ` +
                'load');
        }
        const result = {
            entryModuleId: deployModules.entryModuleId,
            internalModuleBaseUrls: internalModuleBaseUrls.map((url) => url_1.ensureTrailingSlash(url)),
            scriptResources: scriptResources
        };
        if (entrypointExportName) {
            result.exportName = entrypointExportName;
        }
        return result;
    }
    _resolveDebugPath(assetPath) {
        if (!assetPath) {
            return undefined;
        }
        if (typeof assetPath === 'string') {
            // If this is a full URL, don't change it
            if (url_1.isUrl(assetPath)) {
                return assetPath;
            }
            else {
                return path.relative(this.buildConfig.rootPath, assetPath).replace(/\\/g, '/');
            }
        }
        else {
            return {
                default: this._resolveDebugPath(assetPath.default),
                debug: this._resolveDebugPath(assetPath.debug)
            };
        }
    }
    _resolveProductionPath(assetPath) {
        if (!assetPath) {
            return undefined;
        }
        if (typeof assetPath === 'string') {
            const assetPathStr = assetPath;
            // If this is a full URL, don't change it
            if (url_1.isUrl(assetPathStr)) {
                return assetPathStr;
            }
            else if (this.taskConfig.cdnUrlPrefix) {
                return url_1.joinUrlSegments(this.taskConfig.cdnUrlPrefix, assetPathStr);
            }
            else {
                return url_1.trimLeadingSlashes(assetPathStr);
            }
        }
        else {
            return {
                default: this._resolveProductionPath(assetPath.default),
                debug: this._resolveProductionPath(assetPath.debug)
            };
        }
    }
}
exports.WriteManifestsTask = WriteManifestsTask;

//# sourceMappingURL=WriteManifestsTask.js.map
