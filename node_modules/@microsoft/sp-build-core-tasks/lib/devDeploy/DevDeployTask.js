"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Url = require("url");
const path = require("path");
const glob = require("glob");
const Webpack = require("webpack");
const fsx = require("fs-extra");
const lodash = require("lodash");
const rush_lib_1 = require("@microsoft/rush-lib");
const OdspGulpTask_1 = require("./../OdspGulpTask");
const cumulativeManifestProcessor_1 = require("./../cumulativeManifestProcessor");
const deployToAzure_1 = require("./../deployAzureStorage/uploadCDN/deployToAzure");
const ensureBlobService_1 = require("./../utilities/azureStorage/ensureBlobService");
const ensureContainer_1 = require("./../utilities//azureStorage/ensureContainer");
const uploadFilesToAzure_1 = require("./../utilities//azureStorage/uploadFilesToAzure");
const url_1 = require("./../utilities/url");
const RetryablePromise_1 = require("./../utilities/RetryablePromise");
const WriteManifestsTask_1 = require("../writeManifests/WriteManifestsTask");
const DevDeployLinkPrinter_1 = require("./DevDeployLinkPrinter");
const MANIFESTS_AZURE_FILENAME = 'manifests.js';
const SP_LOADER_ASSEMBLY_ID = '44bae1a2-d2eb-4e10-8c21-a1dbdce1036f';
const MAX_UPLOAD_RETRIES = 3;
const RETRY_DELAY_MS = 250;
const SOURCE_BRANCH_ENV_VAR_NAME = 'BUILD_SOURCEBRANCH';
class DevDeployTask extends OdspGulpTask_1.default {
    constructor() {
        super('dev-deploy', {
            useRush: false,
            isolateProjects: true
        });
    }
    executeTask(gulp, completeCallback) {
        if (!this.taskConfig.account) {
            completeCallback('Azure storage account not set.');
            return;
        }
        if (!this.taskConfig.accessKey) {
            completeCallback('Azure storage account access key not set.');
            return;
        }
        if (!this.taskConfig.container) {
            completeCallback('Azure container name not set.');
            return;
        }
        if (!this.taskConfig.containerDirectoryName) {
            this.logWarning('It is strongly recommended a directory inside the container be used to avoid clobbering other ' +
                'users\' dev deployments.');
        }
        this.taskConfig.useRush = this.taskConfig.useRush || (process.argv.indexOf('--rush') !== -1);
        if (process.argv.indexOf('--ciMode') !== -1) {
            const branchName = process.env[SOURCE_BRANCH_ENV_VAR_NAME];
            const containerDirectoryName = branchName
                ? branchName.replace(/[^A-Za-z0-9\-]+/g, '_')
                : `${this.taskConfig.containerDirectoryName}_tab`;
            this.setConfig({
                containerDirectoryName,
                useRush: true,
                isolateProjects: false
            });
        }
        const cumulativeManifestProcessor = new cumulativeManifestProcessor_1.default(this, { explicitInclude: [SP_LOADER_ASSEMBLY_ID] });
        let manifests;
        try {
            manifests = this._getManifests(cumulativeManifestProcessor);
        }
        catch (e) {
            completeCallback(e);
            return;
        }
        const manifestsArray = [];
        this.logVerbose(`Discovered ${Object.keys(manifests).length} projects.`);
        const storageDirName = this._getStorageDirName();
        const containerUrl = this._getContainerUrl();
        const filesToUpload = [];
        const dirsToUpload = new Map();
        const projectContainerNames = new Map(); // Ensure we don't reuse a name
        let spLoaderPath;
        let debugSPLoader;
        // Loop through the manifests and collect files and directories to be uploaded, and fix up manifest fields
        for (const id in manifests) {
            if (manifests.hasOwnProperty(id)) {
                const manifestProject = manifests[id];
                const manifest = manifestProject.manifestData;
                const loaderConfig = manifest.loaderConfig;
                manifestsArray.push(manifest);
                const projectContainerName = this.taskConfig.isolateProjects
                    ? this._getAzureDirName(projectContainerNames, manifestProject.packagePath)
                    : '';
                const projectBasePath = url_1.joinUrlSegments(storageDirName, projectContainerName);
                const projectBaseFullUrl = url_1.joinUrlSegments(containerUrl, projectBasePath);
                // A relative base URL applies when the paths are based on the tenant URL.
                // This applies, for example, in the JSOM library, that takes the JS files from a known place
                //  available on every tenant.
                const isBaseUrlRelative = loaderConfig.internalModuleBaseUrls.length > 0
                    && !Url.parse(loaderConfig.internalModuleBaseUrls[0]).protocol;
                // If the Base URL is a relative path, keep the relative path
                if (!isBaseUrlRelative) {
                    loaderConfig.internalModuleBaseUrls = [url_1.ensureTrailingSlash(projectBaseFullUrl)];
                }
                // Ensure we don't reuse a name
                const resourceContainerNames = new Map();
                const processPath = (rawResourcePath) => {
                    const resourcePath = this._disambiguatePath(rawResourcePath);
                    // If the base URL was relative, a relative path for a resource doesn't need to be fixed up
                    if (url_1.isUrl(resourcePath) || isBaseUrlRelative) {
                        return resourcePath; // Do not deal with fully-qualified URL.
                    }
                    else {
                        const filesystemPath = path.join(manifestProject.packagePath, resourcePath);
                        const filename = path.basename(resourcePath);
                        // Path resources are in the 'dist' directory by default and usually have some secondary
                        //  references, so let's just upload the whole directory.
                        const filesystemDirectory = path.dirname(filesystemPath);
                        const azureResourceDirName = this.taskConfig.isolateProjects
                            ? this._getAzureDirName(resourceContainerNames, filesystemDirectory) :
                            '';
                        const azureDirectory = url_1.joinUrlSegments(projectBasePath, azureResourceDirName);
                        dirsToUpload.set(filesystemDirectory, azureDirectory);
                        if (!spLoaderPath && id === SP_LOADER_ASSEMBLY_ID) {
                            spLoaderPath = azureDirectory;
                            debugSPLoader = filename;
                        }
                        return url_1.joinUrlSegments(azureResourceDirName, filename);
                    }
                };
                this._doComponentTypeSpecificFixup(manifest, processPath);
                for (const scriptResourceId in loaderConfig.scriptResources) {
                    if (loaderConfig.scriptResources.hasOwnProperty(scriptResourceId)) {
                        const scriptResource = loaderConfig.scriptResources[scriptResourceId];
                        switch (scriptResource.type) {
                            case 'path':
                                // Path script resource, we need to fix up its path and upload it
                                const pathResource = scriptResource;
                                pathResource.path = processPath(pathResource.path);
                                break;
                            case 'component':
                                // We probably don't need to upload the fallback file, and it's nigh-impossible to tell if we'll
                                //  miss secondary dependencies by only uploading the file at the failoverPath, so we'll just clear it
                                //  out and hope this dependency is either satisfied by another dev-deploy manifest or by the OOB
                                //  framework
                                const componentResource = scriptResource;
                                componentResource.failoverPath = undefined;
                                break;
                            case 'localizedPath':
                                // Localized path script resource, we need to fix up the paths for each locale and upload each file
                                const localizedPathResource = scriptResource;
                                localizedPathResource.defaultPath = processPath(localizedPathResource.defaultPath);
                                if (localizedPathResource.paths) {
                                    for (const locale in localizedPathResource.paths) {
                                        if (localizedPathResource.paths.hasOwnProperty(locale)) {
                                            localizedPathResource.paths[locale] = processPath(localizedPathResource.paths[locale]);
                                        }
                                    }
                                }
                                break;
                        }
                    }
                }
            }
        }
        // Expand directories to individual files
        const directoryExpandPromises = [];
        const collisionDetectionMap = new Map();
        dirsToUpload.forEach((azureDirName, localDirName) => {
            directoryExpandPromises.push(this._getFilesInDirectory(localDirName).then((files) => {
                files.forEach((file) => {
                    const azureUrl = url_1.joinUrlSegments(azureDirName, file.replace(/\\/g, '/'));
                    const localPath = path.join(localDirName, file);
                    if (fsx.statSync(localPath).isDirectory()) {
                        return; // Continue on directories
                    }
                    if (!this.taskConfig.isolateProjects) {
                        if (collisionDetectionMap.has(azureUrl)) {
                            collisionDetectionMap.get(azureUrl).push(localPath);
                        }
                        else {
                            collisionDetectionMap.set(azureUrl, [localPath]);
                        }
                    }
                    filesToUpload.push({
                        localPath,
                        azurePath: azureUrl
                    });
                });
            }));
        });
        const blobServicePromise = ensureBlobService_1.default(this.taskConfig.account, this.taskConfig.accessKey)
            .then((blobService) => ensureContainer_1.default(blobService, this.taskConfig.container, 
        /* createContainerOptions */ undefined, this.log.bind(this)));
        const uploadPromise = blobServicePromise.then((blobService) => {
            const rawUploadPromise = Promise.all(directoryExpandPromises).then(() => {
                return uploadFilesToAzure_1.default(blobService, this.taskConfig.container, filesToUpload, this.log.bind(this));
            });
            return RetryablePromise_1.default.allWithRetries([new RetryablePromise_1.default(rawUploadPromise)], MAX_UPLOAD_RETRIES, RETRY_DELAY_MS).then((services) => {
                return services[0];
            });
        });
        const manifestsFilePromise = uploadPromise.then((blobService) => {
            const webpackConfig = cumulativeManifestProcessor.getManifestsFileWebpackConfig(manifestsArray);
            const manifestsFilename = 'devDeployManifests.js';
            const manifestsFileFullPath = path.join(webpackConfig.output.path, manifestsFilename);
            webpackConfig.output.filename = manifestsFilename;
            return new Promise((resolve, reject) => {
                Webpack(webpackConfig, (err) => {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve();
                    }
                });
            }).then(() => {
                return RetryablePromise_1.default.allWithRetries([new RetryablePromise_1.default(uploadFilesToAzure_1.default(blobService, this.taskConfig.container, [{
                            localPath: manifestsFileFullPath,
                            azurePath: url_1.joinUrlSegments(storageDirName, MANIFESTS_AZURE_FILENAME)
                        }], this.log.bind(this)))], MAX_UPLOAD_RETRIES, RETRY_DELAY_MS).then((services) => {
                    return services[0];
                });
            });
        });
        return manifestsFilePromise.then(() => {
            const devDeployUrl = this.getDeployUrl();
            const loaderUrl = url_1.joinUrlSegments(containerUrl, spLoaderPath, debugSPLoader);
            this.log('UPLOAD COMPLETE.');
            // Warn about collisions
            collisionDetectionMap.forEach((localPaths, url) => {
                if (localPaths.length > 1) {
                    this.logWarning(`COLLISION DETECTED: [${localPaths.join(',')}] all deployed to the same URL (${url}). ` +
                        `It is very probable that the dev-deploy will not work as expected. This may indicate a ` +
                        `serious issue for production environments as well.`);
                }
            });
            DevDeployLinkPrinter_1.printDevDeployLink(this.log.bind(this), loaderUrl, devDeployUrl);
            this.properties.devDeployManifestFileUrl = devDeployUrl;
            this.properties.devDeployModuleLoaderUrl = loaderUrl;
            completeCallback();
            return {};
        }).catch((error) => {
            completeCallback(error.message);
            return {};
        });
    }
    getDeployUrl() {
        return url_1.joinUrlSegments(this._getContainerUrl(), this._getStorageDirName(), MANIFESTS_AZURE_FILENAME);
    }
    _getContainerUrl() {
        return deployToAzure_1.getAzureStorageUrl(this.taskConfig.account, this.taskConfig.container);
    }
    _getStorageDirName() {
        return this.taskConfig.containerDirectoryName || '';
    }
    _disambiguatePath(pathToDisambiguate) {
        return typeof pathToDisambiguate === 'string'
            ? pathToDisambiguate
            : pathToDisambiguate.default;
    }
    _getFilesInDirectory(dirName) {
        return new Promise((resolve, reject) => {
            glob(path.join('**', '*.*'), { cwd: dirName }, (error, files) => {
                if (error) {
                    reject(error);
                }
                else {
                    resolve(files || []);
                }
            });
        });
    }
    /**
     * This function returns a directory name to be used in a directory on Azure storage, ensuring that the name does
     *  not collide with another directory's name. It also ensures that if the specified filesystem path has already
     *  been mapped to an Azure directory, the same name is used on Azure.
     */
    _getAzureDirName(directoryMap, filesystemPath) {
        let azureDirName = path.basename(filesystemPath).toLowerCase();
        if (directoryMap.has(azureDirName)) {
            const existingPaths = directoryMap.get(azureDirName);
            const currentPathId = existingPaths.indexOf(filesystemPath);
            if (currentPathId === -1) {
                azureDirName = `${azureDirName}_${existingPaths.length}`;
                existingPaths.push(filesystemPath);
            }
            else if (currentPathId > 0) {
                azureDirName = `${azureDirName}_${currentPathId}`;
            }
        }
        else {
            directoryMap.set(azureDirName, [filesystemPath]);
        }
        return azureDirName;
    }
    _getManifests(cumulativeManifestProcessor) {
        if (this.taskConfig.useRush) {
            const rushConfig = rush_lib_1.RushConfiguration.loadFromDefaultLocation();
            if (!rushConfig) {
                throw 'Unable to find the rush configuration file.';
            }
            let manifests;
            const directories = rushConfig.projects.map((proj) => proj.projectFolder);
            manifests = cumulativeManifestProcessor.discoverManifests(directories[0], cumulativeManifestProcessor_1.ForceSearch.deepSparse);
            for (let i = 1; i < directories.length; i++) {
                const projectManifests = cumulativeManifestProcessor.discoverManifests(directories[i], cumulativeManifestProcessor_1.ForceSearch.deepSparse);
                manifests = this._mergeReferencedProjectLists(manifests, projectManifests);
            }
            return manifests;
        }
        else {
            return cumulativeManifestProcessor.discoverManifests(this.buildConfig.rootPath, cumulativeManifestProcessor_1.ForceSearch.deepSparse);
        }
    }
    _mergeReferencedProjectLists(list1, list2) {
        const ids = new Set();
        Object.keys(list1).concat(Object.keys(list2)).forEach((id) => ids.add(id));
        const result = {};
        ids.forEach((id) => {
            const list1Element = list1[id];
            const list2Element = list2[id];
            if (!list1Element || !list2Element) {
                // Element is only present in one list
                result[id] = list1Element || list2Element;
            }
            else if (list1Element.manifestCreationTime > list2Element.manifestCreationTime) {
                // List 1's element is newer
                result[id] = list1Element;
            }
            else {
                // List 2's element is newer, or they have the same age
                result[id] = list2Element;
            }
        });
        return result;
    }
    _doComponentTypeSpecificFixup(manifest, processPath) {
        switch (manifest.componentType) {
            case 'WebPart':
                // tslint:disable-next-line:no-any
                const webpartManifest = manifest;
                for (const preconfiguredEntry of webpartManifest.preconfiguredEntries) {
                    if (preconfiguredEntry.iconImageUrl) {
                        preconfiguredEntry.iconImageUrl = this._fixupIconPath(preconfiguredEntry.iconImageUrl, processPath);
                    }
                }
                break;
            case 'Extension':
                const extensionManifest = manifest;
                switch (extensionManifest.extensionType) {
                    case 'ListViewCommandSet':
                        const commandSetManifest = extensionManifest;
                        for (const itemId in commandSetManifest.items) {
                            if (commandSetManifest.items.hasOwnProperty(itemId)) {
                                const item = commandSetManifest.items[itemId];
                                if (item.iconImageUrl) {
                                    item.iconImageUrl = this._fixupIconPath(item.iconImageUrl, processPath);
                                }
                            }
                        }
                        break;
                    default:
                        // Nothing to do for the other extension types
                        break;
                }
                break;
            default:
                // Nothing to do for the other component types
                break;
        }
    }
    _fixupIconPath(iconPath, processPath) {
        if (WriteManifestsTask_1.getIconPathType(iconPath) === WriteManifestsTask_1.IconPathType.RelativeUrl) {
            const relativeIconPath = lodash.trimStart(iconPath, '/');
            return processPath(relativeIconPath);
        }
        else {
            return iconPath;
        }
    }
}
exports.DevDeployTask = DevDeployTask;

//# sourceMappingURL=DevDeployTask.js.map
