"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const gulp_core_build_1 = require("@microsoft/gulp-core-build");
/* tslint:disable:typedef */
const md5 = require('md5');
const merge = require('lodash').merge;
/* tslint:enable:typedef */
const through2 = require("through2");
const gutil = require("gulp-util");
const fs = require("fs");
const TSLint = require("tslint");
const path = require("path");
const TypeScriptConfiguration_1 = require("./TypeScriptConfiguration");
class TSLintTask extends gulp_core_build_1.GulpTask {
    constructor() {
        super('tslint', {
            // lintConfig: require('../lib/defaultTslint.json'),
            lintConfig: {},
            reporter: (result, file, options) => {
                for (const failure of result.failures) {
                    const pathFromRoot = path.relative(this.buildConfig.rootPath, file.path);
                    const start = failure.getStartPosition().getLineAndCharacter();
                    if (this.taskConfig.displayAsWarning) {
                        this.fileWarning(pathFromRoot, start.line + 1, start.character + 1, failure.getRuleName(), failure.getFailure());
                    }
                    else {
                        this.fileError(pathFromRoot, start.line + 1, start.character + 1, failure.getRuleName(), failure.getFailure());
                    }
                }
            },
            rulesDirectory: (() => {
                const msCustomRulesMain = require.resolve('tslint-microsoft-contrib');
                const msCustomRulesDirectory = path.dirname(msCustomRulesMain);
                return TSLint.Configuration.getRulesDirectories([msCustomRulesDirectory], __dirname);
            })(),
            sourceMatch: [
                'src/**/*.ts',
                'src/**/*.tsx'
            ],
            removeExistingRules: false,
            useDefaultConfigAsBase: true
        });
        this._defaultLintRules = undefined; // tslint:disable-line:no-any
    }
    mergeConfig(config) {
        this._prepareUpdateConfig(config);
        super.mergeConfig(config);
    }
    setConfig(config) {
        this._prepareUpdateConfig(config);
        super.setConfig(config);
    }
    loadSchema() {
        return require('./schemas/tslint.schema.json');
    }
    executeTask(gulp, completeCallback) {
        const self = this;
        if (!this.taskConfig.sourceMatch) {
            completeCallback('taskConfig.sourceMatch must be defined');
            return;
        }
        if (!this.taskConfig.reporter) {
            completeCallback('taskConfig.reporter must be defined');
            return;
        }
        const lintRulesFile = self._loadLintConfiguration();
        // Write out the active lint rules for easier debugging
        if (!fs.existsSync(path.dirname(this._getTsLintFilepath()))) {
            fs.mkdirSync(path.dirname(this._getTsLintFilepath()));
        }
        fs.writeFileSync(this._getTsLintFilepath(), JSON.stringify(lintRulesFile, undefined, 2));
        const cached = require('gulp-cache'); // tslint:disable-line
        let program = undefined;
        try {
            const tsconfigFileData = TypeScriptConfiguration_1.TypeScriptConfiguration.getTsConfigFile(this.buildConfig);
            const tsconfigFilePath = path.join(this.buildConfig.rootPath, this.buildConfig.tempFolder, 'tslint-tsconfig.json');
            fs.writeFileSync(tsconfigFilePath, JSON.stringify(tsconfigFileData, undefined, 2));
            program = TSLint.Linter.createProgram(tsconfigFilePath, path.join(this.buildConfig.rootPath, this.buildConfig.srcFolder));
        }
        catch (e) {
            this.logWarning(`Unable to create a TS program for TSLint. Some lint rules might not work correctly. Error ${e}`);
        }
        return gulp.src(this.taskConfig.sourceMatch)
            .pipe(cached(through2.obj(function (file, encoding, callback) {
            self.logVerbose(file.path);
            // Lint the file
            if (file.isNull()) {
                return callback(undefined, file);
            }
            // Stream is not supported
            if (file.isStream()) {
                this.emit('error', new gutil.PluginError(this.name, 'Streaming not supported'));
                return callback();
            }
            const options = {
                fix: false,
                formatter: 'json',
                formattersDirectory: undefined,
                rulesDirectory: self.taskConfig.rulesDirectory || []
            };
            const linter = new TSLint.Linter(options, program);
            const configuration = TSLint.Configuration.parseConfigFile(lintRulesFile);
            linter.lint(file.path, file.contents.toString(), configuration);
            const result = linter.getResult();
            /* tslint:disable:no-string-literal */
            file['tslint'] = result;
            /* tslint:enable:no-string-literal */
            // We can't get here if reporter is undefined
            if (result.errorCount > 0 && self.taskConfig.reporter) {
                self.taskConfig.reporter(result, file, self.taskConfig);
            }
            this.push(file);
            callback();
        }), {
            // Scope the cache to a combination of the lint rules and the build path
            name: md5(TSLint.Linter.VERSION + JSON.stringify(lintRulesFile) +
                self.name + self.buildConfig.rootPath),
            // What on the result indicates it was successful
            success: (jshintedFile) => {
                /* tslint:disable:no-string-literal */
                return jshintedFile['tslint'].failureCount === 0;
                /* tslint:enable:no-string-literal */
            },
            // By default, the cache attempts to store the value of the objects in the stream
            // For this task, this is over-engineering since we never need to store anything extra.
            value: (file) => {
                return {
                    path: file.path
                };
            }
        }));
    }
    getCleanMatch(buildConfig, taskConfig = this.taskConfig) {
        return [path.join(buildConfig.rootPath, buildConfig.tempFolder)];
    }
    _prepareUpdateConfig(newConfig) {
        // If the removeExistingRules flag is set, clear out any existing rules
        if (newConfig.removeExistingRules &&
            this.taskConfig &&
            this.taskConfig.lintConfig) {
            delete this.taskConfig.lintConfig.rules;
            delete newConfig.removeExistingRules;
        }
    }
    _getTsLintFilepath() {
        return path.join(this.buildConfig.rootPath, this.buildConfig.tempFolder, 'tslint.json');
    }
    _loadLintConfiguration() {
        if (!this._defaultLintRules) {
            this._defaultLintRules = require('./defaultTslint.json');
        }
        return merge((this.taskConfig.useDefaultConfigAsBase ? this._defaultLintRules : {}), this.taskConfig.lintConfig || {});
    }
}
exports.TSLintTask = TSLintTask;

//# sourceMappingURL=TSLintTask.js.map
