"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const fsx = require("fs-extra");
const path = require("path");
const ts = require("typescript");
const gulp_core_build_1 = require("@microsoft/gulp-core-build");
const api_extractor_1 = require("@microsoft/api-extractor");
const TypeScriptConfiguration_1 = require("./TypeScriptConfiguration");
const gulpTypeScript = require("gulp-typescript");
/**
 * The ApiExtractorTask uses the api-extractor tool to analyze a project for public APIs. api-extractor will detect
 * common problems and generate a report of the exported public API. The task uses the entry point of a project to
 * find the aliased exports of the project. An api-extractor.ts file is generated for the project in the temp folder.
 * @public
 */
class ApiExtractorTask extends gulp_core_build_1.GulpTask {
    constructor() {
        super('api-extractor', {
            enabled: false,
            entry: undefined,
            apiReviewFolder: undefined,
            apiJsonFolder: undefined
        });
    }
    loadSchema() {
        return require('./schemas/api-extractor.schema.json');
    }
    executeTask(gulp, completeCallback) {
        if (!this.taskConfig.enabled || !this._validateConfiguration()) {
            completeCallback();
            return;
        }
        if (!this.taskConfig.entry) {
            completeCallback('taskConfig.entry must be defined');
            return;
        }
        if (!this.taskConfig.apiJsonFolder) {
            completeCallback('taskConfig.apiJsonFolder must be defined');
            return;
        }
        if (!this.taskConfig.apiReviewFolder) {
            completeCallback('taskConfig.apiReviewFolder must be defined');
            return;
        }
        try {
            const entryPointFile = path.join(this.buildConfig.rootPath, this.taskConfig.entry);
            const typingsFilePath = path.join(this.buildConfig.rootPath, 'typings/tsd.d.ts');
            const otherFiles = fsx.existsSync(typingsFilePath) ? [typingsFilePath] : [];
            // tslint:disable-next-line:no-any
            const gulpTypeScriptSettings = TypeScriptConfiguration_1.TypeScriptConfiguration.getGulpTypescriptOptions(this.buildConfig).compilerOptions;
            TypeScriptConfiguration_1.TypeScriptConfiguration.fixupSettings(gulpTypeScriptSettings, this.logWarning, { mustBeCommonJsOrEsnext: true });
            const compilerOptions = gulpTypeScript.createProject(gulpTypeScriptSettings).options;
            const rootFiles = [entryPointFile].concat(otherFiles);
            const compilerProgram = ts.createProgram(rootFiles, compilerOptions);
            const extractorConfig = {
                compiler: { configType: 'runtime' },
                project: {
                    entryPointSourceFile: entryPointFile,
                    externalJsonFileFolders: [path.join(__dirname, 'external-api-json')]
                },
                apiReviewFile: {
                    enabled: true,
                    apiReviewFolder: this.taskConfig.apiReviewFolder,
                    tempFolder: this.buildConfig.tempFolder
                },
                apiJsonFile: {
                    enabled: true,
                    outputFolder: this.taskConfig.apiJsonFolder
                }
            };
            const extractorOptions = {
                compilerProgram: compilerProgram,
                localBuild: !this.buildConfig.production,
                customLogger: {
                    logVerbose: (message) => this.logVerbose(message),
                    logInfo: (message) => this.log(message),
                    logWarning: (message) => this.logWarning(message),
                    logError: (message) => this.logError(message)
                }
            };
            const extractor = new api_extractor_1.Extractor(extractorConfig, extractorOptions);
            extractor.analyzeProject();
        }
        catch (e) {
            completeCallback(e.message);
            return;
        }
        completeCallback();
    }
    _validateConfiguration() {
        if (!this.taskConfig.entry) {
            this.logError('Missing or empty "entry" field in api-extractor.json');
            return false;
        }
        if (!this.taskConfig.apiReviewFolder) {
            this.logError('Missing or empty "apiReviewFolder" field in api-extractor.json');
            return false;
        }
        if (!fsx.existsSync(this.taskConfig.entry)) {
            this.logError(`Entry file ${this.taskConfig.entry} does not exist.`);
            return false;
        }
        return true;
    }
}
exports.ApiExtractorTask = ApiExtractorTask;

//# sourceMappingURL=ApiExtractorTask.js.map
