"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const gutil = require("gulp-util");
const stream_1 = require("stream");
const path = require("path");
const index_1 = require("../index");
const mockBuildConfig_1 = require("./mockBuildConfig");
let testArray = [];
class PromiseTask extends index_1.GulpTask {
    constructor() {
        super('promise', {});
    }
    executeTask(gulp) {
        return new Promise((resolve) => {
            testArray.push(this.name);
            resolve();
        });
    }
}
class StreamTask extends index_1.GulpTask {
    constructor() {
        super('stream', {});
    }
    executeTask(gulp) {
        const stream = new stream_1.Readable({ objectMode: true });
        // Add no opt function to make it compat with through
        stream['_read'] = () => {
            // Do Nothing
        };
        setTimeout(() => {
            const file = new gutil.File({
                path: 'test.js',
                contents: new Buffer('test')
            });
            stream.push(file);
            testArray.push(this.name);
            stream.emit('end');
        }, 100);
        return stream;
    }
}
class SyncTask extends index_1.GulpTask {
    constructor() {
        super('sync', {});
    }
    executeTask(gulp) {
        testArray.push(this.name);
    }
}
class SyncWithReturnTask extends index_1.GulpTask {
    constructor() {
        super('sync-with-return', {});
    }
    executeTask(gulp) {
        testArray.push(this.name);
    }
}
class CallbackTask extends index_1.GulpTask {
    constructor() {
        super('schema-task', {});
    }
    executeTask(gulp, callback) {
        testArray.push(this.name);
        callback();
    }
}
class SchemaTask extends index_1.GulpTask {
    constructor() {
        super('schema-task', {
            shouldDoThings: false
        });
        this.name = '';
    }
    executeTask(gulp, callback) {
        callback();
    }
    _getConfigFilePath() {
        return path.join(__dirname, 'schema-task.config.json');
    }
}
const tasks = [];
tasks.push(new PromiseTask());
tasks.push(new StreamTask());
tasks.push(new SyncTask());
tasks.push(new SyncWithReturnTask());
tasks.push(new CallbackTask());
describe('GulpTask', () => {
    for (const task of tasks) {
        it(`${task.name} serial`, (done) => {
            testArray = [];
            task.setConfig({ addToMe: testArray });
            index_1.serial(task).execute(mockBuildConfig_1.mockBuildConfig).then(() => {
                chai_1.expect(testArray).to.deep.equal([task.name]);
                done();
            }).catch(done);
        });
        it(`${task.name} parallel`, (done) => {
            testArray = [];
            task.setConfig({ addToMe: testArray });
            index_1.parallel(task).execute(mockBuildConfig_1.mockBuildConfig).then(() => {
                chai_1.expect(testArray).to.deep.equal([task.name]);
                done();
            }).catch(done);
        });
    }
    it(`all tasks serial`, (done) => {
        testArray = [];
        for (const task of tasks) {
            task.setConfig({ addToMe: testArray });
        }
        index_1.serial(tasks).execute(mockBuildConfig_1.mockBuildConfig).then(() => {
            for (const task of tasks) {
                chai_1.expect(testArray.indexOf(task.name)).to.be.greaterThan(-1);
            }
            done();
        }).catch(done);
    });
    it(`all tasks parallel`, (done) => {
        testArray = [];
        for (const task of tasks) {
            task.setConfig({ addToMe: testArray });
        }
        index_1.parallel(tasks).execute(mockBuildConfig_1.mockBuildConfig).then(() => {
            for (const task of tasks) {
                chai_1.expect(testArray.indexOf(task.name)).to.be.greaterThan(-1);
            }
            done();
        }).catch(done);
    });
    it(`reads schema file if loadSchema is implemented`, (done) => {
        const schemaTask = new SchemaTask();
        chai_1.assert.isFalse(schemaTask.taskConfig.shouldDoThings);
        schemaTask.onRegister();
        chai_1.assert.isTrue(schemaTask.taskConfig.shouldDoThings);
        done();
    });
    it(`throws validation error is config does not conform to schema file`, (done) => {
        const schemaTask = new SchemaTask();
        // tslint:disable-next-line:no-any
        schemaTask._getConfigFilePath = () => {
            return path.join(__dirname, 'other-schema-task.config.json');
        };
        chai_1.assert.isFalse(schemaTask.taskConfig.shouldDoThings);
        chai_1.assert.throws(schemaTask.onRegister);
        done();
    });
});

//# sourceMappingURL=GulpTask.test.js.map
