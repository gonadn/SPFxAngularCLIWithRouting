"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const GulpTask_1 = require("./GulpTask");
const fs = require("fs");
const path = require("path");
const child_process = require("child_process");
const PROCESS_OUTPUT_DELIMITER = '///~X~X~X~X~X~X~///';
let _lastLocalHashes = {};
/**
 * This task is responsible for generating a build receipt, which is a hash of filePath to sha1 git hash,
 * based on the current folder's content. If a {buildConfig.packagePath}/build.json file exists, it will
 * parse it and object compare the computed build receipt with the contents. If everything is the same, it
 * will set buildConfig.isRedundantBuild flag to true, which can be used in task isEnabled methods to skip
 * unnecessary work.
 *
 * The utility function "_getLocalHashes" will use the git.exe process to get the hashes from the git
 * cache. It also asks for git status, which will tell us what has been changed since. It uses this info
 * to build the hash.
 *
 * The utility function "_readPackageHashes" will read the local build.json file from the packagePath
 * folder.
 */
class CheckBuildReceiptTask extends GulpTask_1.GulpTask {
    constructor() {
        super(...arguments);
        this.name = 'check-for-changes';
    }
    executeTask(gulp, completeCallback) {
        _getLocalHashes().then(localHashes => {
            _lastLocalHashes = localHashes;
            _readPackageHashes(path.join(process.cwd(), this.buildConfig.packageFolder, 'build.json')).then(packageHashes => {
                if (packageHashes) {
                    if (_areObjectsEqual(localHashes, packageHashes)) {
                        this.buildConfig.isRedundantBuild = true;
                        this.log('Build is redundant. Skipping steps.');
                    }
                    else {
                        _areObjectsEqual(localHashes, packageHashes);
                        this.log('Build has new content, continuing execution.');
                    }
                }
                completeCallback();
            });
        });
    }
}
exports.CheckBuildReceiptTask = CheckBuildReceiptTask;
/**
 * This task writes _lastFilesHash, generated from the CheckBuildReceipt task, to the package path in the
 * build.json file. It should only be executed in a task which runs the CheckBuildReceipt subtask first, and
 * should only be run at the end of the task when everything has successfully completed.
 */
class UpdateBuildReceiptTask extends GulpTask_1.GulpTask {
    constructor() {
        super(...arguments);
        this.name = 'mark-changes';
    }
    executeTask(gulp, completeCallback) {
        const packageHashPath = path.join(process.cwd(), this.buildConfig.packageFolder, 'build.json');
        fs.writeFile(packageHashPath, JSON.stringify(_lastLocalHashes, undefined, 2), completeCallback);
    }
}
exports.UpdateBuildReceiptTask = UpdateBuildReceiptTask;
function _getLocalHashes() {
    return new Promise((complete) => {
        child_process.exec(`git ls-tree HEAD -r && echo ${PROCESS_OUTPUT_DELIMITER} && git status --s -u .`, { cwd: process.cwd() }, (error, stdout) => {
            const fileHashes = {};
            const processOutputBlocks = stdout.split(PROCESS_OUTPUT_DELIMITER + '\n');
            processOutputBlocks[0].split('\n').forEach(line => {
                if (line) {
                    const parts = line.substr(line.indexOf('blob ') + 5).split('\t');
                    fileHashes[parts[1]] = parts[0];
                }
            });
            if (processOutputBlocks[1]) {
                const changedFiles = processOutputBlocks[1]
                    .split('\n')
                    .map(line => line.trim().split(' ')[1]).filter(name => !!name);
                if (changedFiles.length) {
                    child_process.exec('git hash-object ' + changedFiles.join(' '), { cwd: process.cwd() }, (hashError, hashStdout) => {
                        const hashes = hashStdout.split('\n');
                        changedFiles.forEach((filename, i) => fileHashes[filename] = hashes[i]);
                        complete(fileHashes);
                    });
                }
            }
            else {
                complete(fileHashes);
            }
        });
    });
}
function _readPackageHashes(receiptPath) {
    return new Promise((complete) => {
        fs.readFile(receiptPath, 'utf8', (err, data) => {
            complete(err ? undefined : JSON.parse(data));
        });
    });
}
function _areObjectsEqual(obj1, obj2) {
    const obj1Keys = Object.keys(obj1);
    const obj2Keys = Object.keys(obj2);
    if (obj1Keys.length === obj2Keys.length) {
        for (const key of obj1Keys) {
            if (obj1[key] !== obj2[key]) {
                return false;
            }
        }
        return true;
    }
    return false;
}

//# sourceMappingURL=BuildReceiptTask.js.map
