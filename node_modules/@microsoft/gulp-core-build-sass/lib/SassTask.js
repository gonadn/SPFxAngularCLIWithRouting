"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const gulp_core_build_1 = require("@microsoft/gulp-core-build");
const os_1 = require("os");
const load_themed_styles_1 = require("@microsoft/load-themed-styles");
const through2 = require("through2");
const path = require("path");
/* tslint:disable:typedef */
const merge = require('merge2');
/* tslint:enable:typedef */
const scssTsExtName = '.scss.ts';
const _classMaps = {};
class SassTask extends gulp_core_build_1.GulpTask {
    constructor() {
        super('sass', {
            preamble: '/* tslint:disable */',
            postamble: '/* tslint:enable */',
            sassMatch: [
                'src/**/*.scss'
            ],
            useCSSModules: false,
            warnOnCssInvalidPropertyName: true,
            dropCssFiles: false,
            warnOnNonCSSModules: false
        });
        this.cleanMatch = [
            'src/**/*.scss.ts'
        ];
    }
    loadSchema() {
        return require('./sass.schema.json');
    }
    executeTask(gulp, completeCallback) {
        if (!this.taskConfig.sassMatch) {
            completeCallback('taskConfig.sassMatch must be defined');
            return;
        }
        /* tslint:disable:typedef */
        const autoprefixer = require('autoprefixer');
        const cssModules = require('postcss-modules');
        /* tslint:enable:typedef */
        /* tslint:disable:no-any */
        const postCSSPlugins = [
            autoprefixer({ browsers: ['> 1%', 'last 2 versions', 'ie >= 10'] })
        ];
        const modulePostCssPlugins = postCSSPlugins.slice(0);
        /* tslint:enable:no-any */
        modulePostCssPlugins.push(cssModules({
            getJSON: this._generateModuleStub.bind(this),
            generateScopedName: this.generateScopedName.bind(this)
        }));
        const srcPattern = this.taskConfig.sassMatch.slice(0);
        const checkFilenameForCSSModule = (file) => {
            if (!path.basename(file.path).match(/module\.scss$/)) {
                const filepath = path.relative(this.buildConfig.rootPath, file.path);
                this.logWarning(`${filepath}: filename should end with module.scss`);
            }
        };
        if (this.taskConfig.useCSSModules) {
            this.logVerbose('Generating css modules.');
            return this._processFiles(gulp, srcPattern, completeCallback, modulePostCssPlugins);
        }
        else {
            const moduleSrcPattern = srcPattern.map((value) => value.replace('.scss', '.module.scss'));
            moduleSrcPattern.forEach((value) => srcPattern.push(`!${value}`));
            return merge(this._processFiles(gulp, srcPattern, completeCallback, postCSSPlugins, this.taskConfig.warnOnNonCSSModules ? checkFilenameForCSSModule : undefined), this._processFiles(gulp, moduleSrcPattern, completeCallback, modulePostCssPlugins));
        }
    }
    _processFiles(gulp, srcPattern, 
        /* tslint:disable:no-any */
        completeCallback, postCSSPlugins, 
        /* tslint:enable:no-any */
        checkFile) {
        /* tslint:disable:typedef */
        const cleancss = require('gulp-clean-css');
        const clipEmptyFiles = require('gulp-clip-empty-files');
        const clone = require('gulp-clone');
        const postcss = require('gulp-postcss');
        const sass = require('gulp-sass');
        const texttojs = require('gulp-texttojs');
        /* tslint:enable:typedef */
        const tasks = [];
        const srcStream = gulp.src(srcPattern);
        const checkedStream = (checkFile ?
            srcStream.pipe(through2.obj(
            // tslint:disable-next-line:no-function-expression
            function (file, encoding, callback) {
                // tslint:disable-next-line:no-unused-expression
                checkFile(file);
                this.push(file);
                callback();
            }))
            : srcStream);
        const baseTask = checkedStream
            .pipe(sass.sync({
            importer: (url, prev, done) => ({ file: _patchSassUrl(url) })
        }).on('error', function (error) {
            sass.logError.call(this, error);
            completeCallback('Errors found in sass file(s).');
        }))
            .pipe(postcss(postCSSPlugins))
            .pipe(cleancss({
            advanced: false
        }))
            .pipe(clipEmptyFiles());
        if (this.taskConfig.dropCssFiles) {
            tasks.push(baseTask.pipe(clone())
                .pipe(gulp.dest(this.buildConfig.libFolder)));
        }
        tasks.push(baseTask.pipe(clone())
            .pipe(texttojs({
            ext: scssTsExtName,
            isExtensionAppended: false,
            template: (file) => {
                const content = file.contents.toString();
                const classNames = _classMaps[file.path];
                let exportClassNames = '';
                if (classNames) {
                    const classNamesLines = [
                        'const styles = {'
                    ];
                    const classKeys = Object.keys(classNames);
                    classKeys.forEach((key, index) => {
                        const value = classNames[key];
                        let line = '';
                        if (key.indexOf('-') !== -1) {
                            const message = `The local CSS class '${key}' is not camelCase and will not be type-safe.`;
                            this.taskConfig.warnOnCssInvalidPropertyName ?
                                this.logWarning(message) :
                                this.logVerbose(message);
                            line = `  '${key}': '${value}'`;
                        }
                        else {
                            line = `  ${key}: '${value}'`;
                        }
                        if ((index + 1) <= classKeys.length) {
                            line += ',';
                        }
                        classNamesLines.push(line);
                    });
                    let exportString = 'export default styles;';
                    if (this.taskConfig.moduleExportName === '') {
                        exportString = 'export = styles;';
                    }
                    else if (!!this.taskConfig.moduleExportName) {
                        exportString = `export const ${this.taskConfig.moduleExportName} = styles;`;
                    }
                    classNamesLines.push('};', '', exportString);
                    exportClassNames = classNamesLines.join(os_1.EOL);
                }
                let lines = [];
                lines.push(this.taskConfig.preamble || '');
                if (this.taskConfig.dropCssFiles) {
                    lines = lines.concat([
                        `require('./${path.basename(file.path, scssTsExtName)}.css');`,
                        exportClassNames
                    ]);
                }
                else if (!!content) {
                    lines = lines.concat([
                        'import { loadStyles } from \'@microsoft/load-themed-styles\';',
                        '',
                        exportClassNames,
                        '',
                        `loadStyles(${JSON.stringify(load_themed_styles_1.splitStyles(content))});`
                    ]);
                }
                lines.push(this.taskConfig.postamble || '');
                return (lines
                    .join(os_1.EOL)
                    .replace(new RegExp(`(${os_1.EOL}){3,}`, 'g'), `${os_1.EOL}${os_1.EOL}`)
                    .replace(new RegExp(`(${os_1.EOL})+$`, 'm'), os_1.EOL));
            }
        }))
            .pipe(gulp.dest('src')));
        return merge(tasks);
    }
    _generateModuleStub(cssFileName, json) {
        cssFileName = cssFileName.replace('.css', '.scss.ts');
        _classMaps[cssFileName] = json;
    }
    generateScopedName(name, fileName, css) {
        /* tslint:disable:typedef */
        const crypto = require('crypto');
        /* tslint:enable:typedef */
        return name + '_' + crypto.createHmac('sha1', fileName).update(css).digest('hex').substring(0, 8);
    }
}
exports.SassTask = SassTask;
function _patchSassUrl(url) {
    if (url[0] === '~') {
        url = 'node_modules/' + url.substr(1);
    }
    else if (url === 'stdin') {
        url = '';
    }
    return url;
}

//# sourceMappingURL=SassTask.js.map
